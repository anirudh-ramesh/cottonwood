C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE AS399X
OBJECT MODULE PLACED IN as399x.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe as399x.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          /*
   2           *****************************************************************************
   3           * Copyright by ams AG                                                       *
   4           * All rights are reserved.                                                  *
   5           *                                                                           *
   6           * IMPORTANT - PLEASE READ CAREFULLY BEFORE COPYING, INSTALLING OR USING     *
   7           * THE SOFTWARE.                                                             *
   8           *                                                                           *
   9           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       *
  10           * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         *
  11           * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS         *
  12           * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *
  13           * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     *
  14           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT          *
  15           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     *
  16           * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *
  17           * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *
  18           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     *
  19           * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      *
  20           *****************************************************************************
  21           */
  22          /*! \file
  23           *
  24           *  \author U. Herrmann (based on work by E.Grubmueller)
  25           *  \author T. Luecker (Substitute)
  26           *  \author B. Breinbauer
  27           *
  28           *   \brief Functions provided by the AS399x series chips
  29           *
  30           *   Functions provided by the AS399x series chips. All higher level
  31           *   and protocol work is contained in gen2.c and iso6b.c
  32           */
  33          #include "c8051F340.h"
  34          #include "as399x_config.h"
  35          #include "platform.h"
  36          #include "as399x.h"
  37          #include "as399x_public.h"
  38          #include "global.h"
  39          #include "as399x_com.h"
  40          #include "uart.h"
  41          #include "timer.h"
  42          #include "gen2.h"
  43          #include "stdlib.h"
  44          #include "string.h"
  45          #if VERBOSE_INIT
              #include <math.h>
              #endif
  48          
  49          /** Definition protocol read bit. */
  50          #define READ                      0x40
  51          /** Definition protocol continous bit */
  52          #define CONTINUOUS                 0x20
  53          
  54          #ifdef POWER_DETECTOR
              /* We handle the DAC values in the code like it is a 8 bit DAC from 0V to 3.2V, LSB = 12.5mV.
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 2   

               * But when we write to the DAC register of AS399x we have to convert our internal representation.
               * This is done in as399xWriteDAC() by the macro CONVERT_NAT_TO_DAC.
               * Side note: the DAC values 0x80 and 0x00 give the same DAC output voltage as they only differ in sign bi
             -t. */
              #if ARNIE
              /* Arnie has a different PA setup. Vapc1 is fixed and Vapc2 is controlled by DAC */
              #define MIN_DAC  16 /* corresponds to 0.2V Bias on PA */
              #define NOM_DAC 104 /* corresponds to 1.3V Bias on PA */
              #define MAX_DAC 232 /* corresponds to 2.9V Bias on PA */
              #else
              #define MIN_DAC 152 /* corresponds to 1.9V Bias on PA */
              #define NOM_DAC 160 /* corresponds to 2.0V Bias on PA */
              #define MAX_DAC 224 /* corresponds to 2.8V Bias on PA */
              #endif
              #endif
  70          
  71          /** Variable is used to store the IRQ status read from the AS399x */
  72          u8 DATA as399xIrqStatus = 0;
  73          
  74          /** Variable is used to store the AS399X_REG_FIFO status read from the AS399x */
  75          u8 DATA as399xFifoStatus = 0;
  76          
  77          /** This variable is used as flag to signal an data reception.
  78            *  It is a bit mask of the RESP_TXIRQ, RESP_RXIRQ, RESP_* values
  79            */
  80          volatile u16 DATA as399xResponse = 0;
  81          
  82          u8 as399xChipVersion;
  83          
  84          u32 as399xCurrentBaseFreq;
  85          
  86          static u8 as399xSavedSensRegs[2];
  87          static u8 as399xPowerDownRegs[AS399X_REG_ADC];
  88          static u8 as399xPowerDownRegs3[5][3]; /* 5 registers are 3 bytes deep */
  89          
  90          
  91          /** Is set to 1 in as399xAntennaPower if output power is on. In as399xCyclicPowerRegulation()
  92           * the output power is re-adjusted if output power is on. */
  93          static u8 outputPowerOn = 0;
  94          /** Counts the number of cycles as399xCyclicPowerRegulation() has been called. */
  95          static u16 outputPowerCounter;
  96          /** The outputPowerCounter will be reset to this value after underflow. */
  97          static u16 outputPowerCounterStart = OUTPUTPOWER_MAINCYCLES;
  98          /** If evalPowerRegulation is set to 1 the automatic power regulation will not be executed. (Should be use
             -d for evaluation purposes only.) */
  99          static u8 evalPowerRegulation = 0;
 100          
 101          #if RUN_ON_AS3992
 102          const u8 CODE as399xPredistortionData[252]={ 0x00,
 103              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 104              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 105              0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
 106              0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
 107              0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 108              0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 109              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 110              0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 111              0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 112              0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 113              0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 114              0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
 115              0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 3   

 116              0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 117              0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 118              0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
 119              0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 120              0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 121              0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
 122              0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
 123              0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 124              0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 125              0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 126              0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 127              0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 128              0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 129              0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
 130              0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 131              0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
 132              0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 133              0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 134              0xf8, 0xf9, 0xfa 
 135          };
 136          #endif
 137          #if VERBOSE_INIT
              static void as399xPrintRfpLine(void)
              {
                      s16 val;
                      s16 noiseval;
                      s16 ch_val_i;
                      s16 ch_val_q;
                      s16 rf;
              
                      noiseval = as399xGetReflectedPowerNoiseLevel();
                      val = as399xGetReflectedPower( );
                      ch_val_i = (s8)((val&0xff) - (noiseval&0xff));
                      ch_val_q = (s8)(((val>>8)&0xff) - ((noiseval>>8)&0xff));
                      rf = sqrt(ch_val_i * ch_val_i + ch_val_q * ch_val_q);
                      CON_print("rf=%hx ",rf);
              
                      CON_print("%hx", val);
              
                      for (val = -32; val <= 32 ; val ++)
                      {
                          if ( val == rf )
                          {
                              CON_print("A");
                              continue;
                          }
                          if ( val == ch_val_i && val == ch_val_q)
                          {
                              CON_print("X");
                              continue;
                          }
                          if ( val == ch_val_i )
                          {
                              CON_print("I");
                              continue;
                          }
                          if ( val == ch_val_q )
                          {
                              CON_print("Q");
                              continue;
                          }
                          if ( val == 0 )
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 4   

                          {
                              CON_print("0");
                              continue;
                          }
                          CON_print(" ");
                      }
                      CON_print("\n");
              }
              #endif
 187          /*------------------------------------------------------------------------- */
 188          u16 as399xInitialize(u32 baseFreq)
 189          {
 190   1          u8 myBuf[4];
 191   1      
 192   1      #if AS399X_DO_SELFTEST
 193   1          myBuf[0] = 0x55;
 194   1          myBuf[1] = 0xAA;
 195   1          myBuf[2] = 0x00;
 196   1          myBuf[3] = 0xFF;
 197   1          as399xContinuousWrite(AS399X_REG_PLLMAIN, myBuf, 4);
 198   1          memset(myBuf, 0, sizeof(myBuf));
 199   1          as399xContinuousRead(AS399X_REG_PLLMAIN, 4,myBuf);
 200   1          if ((myBuf[0]!=0x55) || 
 201   1              (myBuf[1]!=0xAA) || 
 202   1              (myBuf[2]!=0x00) || 
 203   1              (myBuf[3]!=0xFF))
 204   1          {
 205   2              CON_print("read regs: %hhx %hhx %hhx %hhx\n", myBuf[0], myBuf[1], myBuf[2], myBuf[3]);
 206   2              return 1; /* data bus interface pins not working */
 207   2          }
 208   1          EN(LOW);
 209   1          mdelay(1); /* Reset the registers again, values should change */
 210   1          EN(HIGH);
 211   1          mdelay(12);  /* AS3992 needs 12 ms to exit standby */
 212   1          as399xContinuousRead(AS399X_REG_PLLMAIN, 4,myBuf);
 213   1          if ((myBuf[0]==0x55) || 
 214   1              (myBuf[1]==0xAA) || 
 215   1              (myBuf[2]==0x00) || 
 216   1              (myBuf[3]==0xFF))
 217   1          {
 218   2              CON_print("EN pin failed\n");
 219   2              return 1; /* enable pin not working */
 220   2          }
 221   1      
 222   1          as399xClrResponse();
 223   1          as399xSingleWrite(AS399X_REG_IRQMASKREG, 0x20);
 224   1          as399xSingleWrite(AS399X_REG_TXLENGTHLOW, 0x02); /* 1bit transmission */
 225   1          as399xSingleCommand(AS399X_CMD_RESETFIFO);
 226   1          as399xSingleCommand(AS399X_CMD_TRANSM);
 227   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 228   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 229   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 230   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 231   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 232   1          as399xContinuousWrite(AS399X_REG_FIFO,myBuf,4);
 233   1      
 234   1          as399xWaitForResponse(RESP_FIFO);
 235   1          if ( !(as399xGetResponse() & RESP_FIFO) )
 236   1          {
 237   2              CON_print("IRQ pin / reading IRQ flags failed\n");
 238   2              return 1; /* Interrupt pin not working */
 239   2          }
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 5   

 240   1      
 241   1          as399xClrResponse();
 242   1      
 243   1          as399xReset(); /* Reset is necessary because of above bogus PLL register settings */
 244   1      
 245   1          as399xSingleCommand(AS399X_CMD_HOPMAINFREQ);
 246   1      #endif
 247   1      
 248   1          switch (as399xReadChipVersion())
 249   1          {
 250   2              case 0x30:
 251   2                  as399xChipVersion = AS3990;
 252   2      #if RUN_ON_AS3992
 253   2                  CON_print("Cannot run on AS3990\n");
 254   2                  return 0xf;
 255   2      #endif
 256   2                  break;
 257   2              case 0x38:
 258   2                  as399xChipVersion = AS3991;
 259   2      #if RUN_ON_AS3992
 260   2                  CON_print("Cannot run on AS3991\n");
 261   2                  return 0xf;
 262   2      #endif
 263   2                  break;
 264   2              case 0x50:
 265   2              case 0x51:
 266   2              case 0x55:
 267   2                  as399xChipVersion = AS3992;
 268   2      #if ! RUN_ON_AS3992
                          CON_print("Cannot run on AS3992\n");
                          return 0xf;
              #else
 272   2                  break;
 273   2      #endif
 274   2              default:
 275   2                  CON_print("Unknown chip %hhx\n",as399xReadChipVersion());
 276   2                  return 0xf;
 277   2          }
 278   1      
 279   1          /* chip status control 0x00 */
 280   1          /*STBY DIRECT AS399X_REG_DACEN - AGL AGC REC RF */
 281   1          /* 0     0     0    0  0   0   1   0  = 0x02 */
 282   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, 0x02);
 283   1      
 284   1          /*protocl control register 0x01 */
 285   1          /*RX_CRC_N DIR_MODE PROT1 PROT0 RX_COD1 RX_COD0 TARI1 TARI0 */
 286   1          /*   0         0      0     0     0        1      1     0      = 0x06 */
 287   1      #if 0
                  as399xSingleWrite(AS399X_REG_PROTOCOLCTRL, 0x02); /*smart ID change */
                  as399xSingleWrite(AS399X_REG_PROTOCOLCTRL, 0x46); /* for receiver measurments */
              #endif
 291   1          as399xSingleWrite(AS399X_REG_PROTOCOLCTRL, 0x06);
 292   1      
 293   1          /*TX options 0x02 */
 294   1          /*TX_PWD1 TX_PWD0 TX_ONE1 TX_ONE0 - - S1 S0 */
 295   1          /*   1       1       1      1     0 0 0  0   = 0xF0 */
 296   1          as399xSingleWrite(AS399X_REG_TXOPTGEN2, 0xF0);
 297   1      
 298   1      #ifdef LOWSUPPLY
 299   1          CON_print("LOW supply\n");
 300   1          myBuf[0]=as399xSingleRead(AS399X_REG_TRCALGEN2MISC);
 301   1          myBuf[0]|=0x40;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 6   

 302   1          as399xSingleWrite(AS399X_REG_TRCALGEN2MISC, myBuf[0]);
 303   1      #endif
 304   1      
 305   1      #ifdef SINGLEINP
 306   1          /*RX special settings 2 0x0A */
 307   1          /*GAIN5 - GAIN1 S_MIX IR1 IR0 */
 308   1          /*  0 0 0 0 1     1    0   0 = 0x0C */
 309   1          as399xSingleWrite(AS399X_REG_RXSPECIAL2, 0x0C);
 310   1      #if VERBOSE_INIT
                  CON_print("SINLGEINP\n");
              #endif
 313   1      
 314   1      #endif
 315   1      
 316   1      #ifdef BALANCEDINP
                  /*RX special settings 2 0x0A */
                  /*GAIN5 - GAIN1 S_MIX IR1 IR0 */
                  /*  0 0 0 0 1     0    0   1 = 0x09 */
                  as399xSingleWrite(AS399X_REG_RXSPECIAL2, 0x09);
              #if ROGER || MICROREADER
                  as399xSingleWrite(AS399X_REG_RXSPECIAL2, 0x08);
              #endif
              #if VERBOSE_INIT
                  CON_print("BALANCED INP\n");
              #endif
              #endif
 328   1      
 329   1      #ifdef LOWSUPPLY
 330   1          CON_print("LOW supply\n");
 331   1          myBuf[0]=as399xSingleRead(AS399X_REG_RXSPECIAL2);
 332   1          myBuf[0]|=0x02;
 333   1          as399xSingleWrite(AS399X_REG_RXSPECIAL2, myBuf[0]);
 334   1      #endif
 335   1      
 336   1      #ifdef INTPA
 337   1          /*REGULATOR and IO control 0x0B */
 338   1          /*IO_LOW REG2V1 REG2V0 EXT4 EXT3 EXT2 EXT1 EXT0 */
 339   1          /*  0       1      0     1   1    0    0    0   = 0x58 */
 340   1          /* PA 14mA */
 341   1          as399xSingleWrite(AS399X_REG_IOCONTROL, 0x58);
 342   1      
 343   1      #if RUN_ON_AS3992
 344   1          /*TX pre-distortion 0x13*/
 345   1          as399xWritePredistortion(as399xPredistortionData);
 346   1      #endif
 347   1      
 348   1          /*Modulator Control Register 0x15 */
 349   1          /*TRFON1 TRFON0 TPRESET TXLEVEL4-TXLEVEL0 */
 350   1          /*   0     0       0      0       0 1 1 1  =0x07 */
 351   1          myBuf[0] = 0x01;
 352   1      
 353   1          /*LIN_MODE PR_ASK MOD_DEP5-MOD_DEP0 */
 354   1          /*    0      1      0 1     1 1 0 1   = 0x5D */
 355   1          myBuf[1] = 0x5D;
 356   1      #if !RUN_ON_AS3992
                  /*E_AMOD MAIN_MOD AUXMOD - - ELFP ASKRATE1 ASKRATE0 */
                  /*  0       1       0    0 0  0      0        0      =0x48 */
                  myBuf[2] = 0x40; /*changed to route to main for 20 dDm */
              #else
 361   1          /*E_AMOD MAIN_MOD AUXMOD - USE_CORR ELFP ASKRATE1 ASKRATE0 */
 362   1          /*  0       1       0    0     1      0        0      =0x48 */
 363   1          myBuf[2] = 0x48; /*changed to route to main for 20 dDm */
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 7   

 364   1      #endif
 365   1          as399xContinuousWrite(AS399X_REG_MODULATORCTRL, myBuf, 3);
 366   1      
 367   1          /*PLL Main Register 0x16 */
 368   1          /*AI2X   REF_FREQ     BBBB  */
 369   1          /* 1      110 (50kHz) 0000  = 0xe0 */
 370   1          myBuf[2] = 0xe0; /* changed to 50 kHz reference and increase internal PA bias */
 371   1          /* BBBB BB AA */
 372   1          /* 1101 10 00 = 0xd8 */
 373   1          myBuf[1] = 0xd8;
 374   1          /* AAAAAAAA */
 375   1          /*  0x4f */
 376   1          myBuf[0] = 0x4f;
 377   1          as399xContinuousWrite(AS399X_REG_PLLMAIN, myBuf, 3);
 378   1      
 379   1      #if VERBOSE_INIT
                  CON_print("INTPA\n");
              #endif
 382   1      #endif
 383   1      
 384   1      #ifdef EXTPA
                  /*PLL Main Register 0x16 */
                  /*AI2X   REF_FREQ     BBBB  */
                  /* 0      110 (50kHz) 0000  = 0xe0 */
                  myBuf[2] = 0x60; /* changed to 50 kHz reference */
                  /* BBBB BB AA */
                  /* 1101 10 00 = 0xd8 */
                  myBuf[1] = 0xd8;
                  /* AAAAAAAA */
                  /*  0x4f */
                  myBuf[0] = 0x4f;
                  as399xContinuousWrite(AS399X_REG_PLLMAIN, myBuf, 3);
              
                  /*REGULATOR and IO control 0x0B */
                  /*IO_LOW REG2V1 REG2V0 EXT4 EXT3 EXT2 EXT1 EXT0 */
                  /*  0       0      0     0   0    0    1    0   = 0x02 */
                  /* PA 14mA */
                  as399xSingleWrite(AS399X_REG_IOCONTROL, 0x02);
              
                  /*Modulator Control Register 0x15 */
                  /*TRFON1 TRFON0 TPRESET TXLEVEL4-TXLEVEL0 */
                  /*   0     0       0      0       0 1 1 1  =0x07 */
                  myBuf[0] = 0x01;
              #if ROGER || MICROREADER
                  myBuf[0] = 0x06; /* reduce the power to be in the mask */
              #endif
              #if ROLAND || ARNIE
                  myBuf[0] = 0x0d; /* reduce the power to be in the mask */
              #endif
                  /*LIN_MODE PR_ASK MOD_DEP5-MOD_DEP0 */
                  /*    0      1      0 1     1 1 0 1   = 0x5D */
                  myBuf[1] = 0x5D;
                  /*E_AMOD MAIN_MOD AUXMOD - - ELFP ASKRATE1 ASKRATE0 */
                  /*  0       0       1    0 0  0      0        0      =0x20 */
                  myBuf[2] = 0x20;
                  as399xContinuousWrite(AS399X_REG_MODULATORCTRL, myBuf, 3);
              #if VERBOSE_INIT
                  CON_print("EXTPA\n");
              #endif
              #endif
 424   1      
 425   1      #if MICROREADER
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 8   

                  myBuf[0] = as399xSingleRead(AS399X_REG_IOCONTROL);
                  /*REGULATOR and IO control 0x0B */
                  /*IO_LOW REG2V1 REG2V0 EXT4 EXT3 EXT2 EXT1 EXT0 */
                  /*  0       1      1     0   0    0    1    0   = 0x02 */
                  /* PA 14mA */
                  myBuf[0] |= 0x60;
                  as399xSingleWrite(AS399X_REG_IOCONTROL, myBuf[0]);
              #endif
 434   1      
 435   1      #if ROLAND || ARNIE
                  myBuf[0] = as399xSingleRead(AS399X_REG_IOCONTROL);
                  /*REGULATOR and IO control 0x0B */
                  /*IO_LOW REG2V1 REG2V0 EXT4 EXT3 EXT2 EXT1 EXT0 */
                  /*  0       0      1     0   0    0    1    0   = 0x02 */
                  /* PA 14mA */
                  myBuf[0] |= 0x20;
                  as399xSingleWrite(AS399X_REG_IOCONTROL, myBuf[0]);
              #endif
 444   1      
 445   1          /*Interrupt Mask register 0x0D */
 446   1          /*= 0x3F */
 447   1          as399xSingleWrite(AS399X_REG_IRQMASKREG, 0x37);
 448   1      
 449   1      #ifdef INTVCO
 450   1          myBuf[0] = 0x03;   /* high cp current, no SYS clock */
 451   1          myBuf[1] = 0x84;   /* */
 452   1      #if ROLAND || ARNIE
                  myBuf[2] = 0x4A;   /* external TCXO AC coupled to OSCO */
              #else
 455   1          myBuf[2] = 0x0A;
 456   1      #endif
 457   1      
 458   1          as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, myBuf, 3);
 459   1      #if VERBOSE_INIT
                  CON_print("INTVCO\n");
              #endif
 462   1      #endif
 463   1      #ifdef EXTVCO
                  myBuf[0] = 0x01;   /* low  cp current, no sys clk */
                  myBuf[1] = 0x0C;   /* */
                  myBuf[2] = 0x00;   /* */
                  as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, myBuf, 3);
              #if VERBOSE_INIT
                  CON_print("EXTVCO\n");
              #endif
              #endif
 472   1      
 473   1          myBuf[0] = 0x00; /* 0x0C: digital lines on OAD */
 474   1          myBuf[1] = 0x00;
 475   1          myBuf[2] = 0x00;
 476   1          as399xContinuousWrite(AS399X_REG_TESTSETTING, myBuf, 3);
 477   1      
 478   1      #ifdef POWER_DETECTOR
                  as399xSingleWrite(AS399X_REG_DAC, NOM_DAC);
                  as399xSetTxPower(240);      // init output power to 24dBm
              #endif
 482   1          
 483   1          as399xSelectLinkFrequency(0x0);
 484   1          /* Give base freq. a reasonable value */
 485   1          as399xSetBaseFrequency(AS399X_REG_PLLMAIN,baseFreq);
 486   1          as399xSetSensitivity(-76);
 487   1      
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 9   

 488   1      #if AS399X_DO_SELFTEST
 489   1          /* Now that the chip is configured with correct ref frequency the PLL 
 490   1             should lock */
 491   1          mdelay(20);
 492   1          myBuf[0]=as399xSingleRead(AS399X_REG_AGCINTERNALSTATUS);
 493   1          if ((myBuf[0] & 0x01) != 0x01) 
 494   1          {
 495   2              return 2; /* Crystal not stable */
 496   2          }
 497   1          if (!(myBuf[0] & 0x02)) 
 498   1          { 
 499   2             return 3; /* PLL not locked */
 500   2          }
 501   1      
 502   1      
 503   1      #if VERBOSE_INIT
                  {
                      /* Do this now, after everyting else should be configured */
                      u32 i = 100;
                      while(i--){
                          as399xPrintRfpLine();
                      }
                      for( i = 860000UL; i< 960000UL ;i+=1000UL)
                      {
                          CON_print("%hx%hx ",(u16)(i>>16),(u16)(i&0xffff));
                          as399xSetBaseFrequency(AS399X_REG_PLLMAIN,i);
                          as399xPrintRfpLine();
                      }
                  }
              #endif
 518   1      #endif
 519   1          return 0;
 520   1      }
 521          
 522          /*------------------------------------------------------------------------- */
 523          /** External Interrupt Function
 524            * The AS3990 uses the external interrupt to signal the uC that
 525            *  something happened. The interrupt function reads the AS3990
 526            * IRQ status. If the signals fifo bit is set it reads the AS3990
 527            * AS399X_REG_FIFO status.
 528            * The interrupt function sets the flags if an event occours.
 529            */
 530          void extInt(void) interrupt 0
 531          {
 532   1          u8 DATA istat, istat2;
 533   1          as399xIrqStatus = as399xSingleReadIrq(AS399X_REG_IRQSTATUS);
 534   1          istat2 = as399xSingleReadIrq(AS399X_REG_IRQSTATUS);
 535   1          as399xFifoStatus = 0;
 536   1      
 537   1          istat = ((as399xIrqStatus | istat2) & 0x3f); /* regular interrupts, make sure to use all which are rea
             -d out */
 538   1      
 539   1          if (as399xIrqStatus & (AS399X_IRQ_TX | AS399X_IRQ_RX))
 540   1          {
 541   2              istat |= ((as399xIrqStatus & 0xc0) & ~istat2); /* tx and rx irq have only happened if they disappe
             -ar at second read */
 542   2          }
 543   1      
 544   1          as399xIrqStatus = istat;
 545   1      
 546   1          if (istat & AS399X_IRQ_FIFO)
 547   1          {
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 10  

 548   2              as399xFifoStatus = as399xSingleReadIrq(AS399X_REG_FIFOSTATUS);
 549   2              if (( as399xFifoStatus &0x1f ) >= 18)
 550   2              { /* high fifo level bit is not working, need to calculate manually */
 551   3                  as399xFifoStatus |= AS399X_FIFOSTAT_HIGHLEVEL;
 552   3              }
 553   2              if (( as399xFifoStatus &0x1f ) <= 6)
 554   2              { /* low fifo level bit is not working, need to calculate manually */
 555   3                  as399xFifoStatus |= AS399X_FIFOSTAT_LOWLEVEL;
 556   3              }
 557   2          }
 558   1      
 559   1          as399xResponse |= istat | (as399xFifoStatus << 8 );
 560   1          //CON_print("isr %hx", as399xResponse);
 561   1      }
 562          
 563          /* The following functions could be used to push the spi communication out of the ISR. But this is a littl
             -e
 564           * because you have to ensure that the irq status registers are checked regularly otherwise IR status info
             -rmation
 565           * might get lost.
 566           * Therefore we keep the current setup. */
 567          //u16 as399xGetResponse(void)
 568          //{
 569          //    //for(; extIntCount; extIntCount--)
 570          //    if(extIntCount)
 571          //        lastCount = 0;
 572          //    while(extIntCount)
 573          //    {
 574          //        u8 DATA istat, istat2;
 575          //        if(!lastCount)
 576          //            lastCount = extIntCount;
 577          //        as399xIrqStatus = as399xGetIRQStatus();
 578          //        istat2 = as399xGetIRQStatus();
 579          //        lastirq = as399xIrqStatus;
 580          //        lastistat2 = istat2;
 581          //        as399xFifoStatus = 0;
 582          //        //CON_print("i: %hhx %hhx\n", as399xIrqStatus, istat2);
 583          //
 584          //        istat = ((as399xIrqStatus | istat2) & 0x3f); /* regular interrupts, make sure to use all which a
             -re read out */
 585          //
 586          //        if (as399xIrqStatus & (AS399X_IRQ_TX | AS399X_IRQ_RX))
 587          //        {
 588          //            istat |= ((as399xIrqStatus & 0xc0) & ~istat2); /* tx and rx irq have only happened if they d
             -isappear at second read */
 589          //        }
 590          //
 591          //        as399xIrqStatus = istat;
 592          //        lastistat = istat;
 593          //
 594          //        if (istat & AS399X_IRQ_FIFO)
 595          //        {
 596          //            as399xFifoStatus = as399xGetFIFOStatus();
 597          //            if (( as399xFifoStatus &0x1f ) >= 18)
 598          //            { /* high fifo level bit is not working, need to calculate manually */
 599          //                as399xFifoStatus |= AS399X_FIFOSTAT_HIGHLEVEL;
 600          //            }
 601          //            if (( as399xFifoStatus &0x1f ) <= 6)
 602          //            { /* low fifo level bit is not working, need to calculate manually */
 603          //                as399xFifoStatus |= AS399X_FIFOSTAT_LOWLEVEL;
 604          //            }
 605          //        }
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 11  

 606          //
 607          //        as399xResponse |= istat | (as399xFifoStatus << 8 );
 608          //        extIntCount--;
 609          //    }
 610          //    return as399xResponse;
 611          //}
 612          //
 613          //void as399xClrResponseMask(u16 mask)
 614          //{
 615          //    as399xResponse&=~(mask);
 616          //}
 617          //
 618          //void as399xClrResponse(void)
 619          //{
 620          //    as399xResponse = 0;
 621          //}
 622          
 623          /*------------------------------------------------------------------------- */
 624          u8 as399xReadChipVersion(void)
 625          {
 626   1          return(as399xSingleRead(AS399X_REG_VERSION));
 627   1      }
 628          
 629          /*------------------------------------------------------------------------- */
 630          void as399xSingleCommand(u8 command)
 631          {
 632   1          DISEXTIRQ();
 633   1          writeReadAS399x( &command, 1, 0 , 0 , STOP_SGL, 1);
 634   1          ENEXTIRQ();
 635   1      }
 636          
 637          
 638          /*------------------------------------------------------------------------- */
 639          void as399xContinuousCommand(u8 *commands, s8 len)
 640          {
 641   1          DISEXTIRQ();
 642   1          writeReadAS399x( commands, len, 0 , 0 , STOP_SGL, 1);
 643   1          ENEXTIRQ();
 644   1      }
 645          
 646          
 647          /*------------------------------------------------------------------------- */
 648          void as399xSingleWriteNoStop(u8 address, u8 value)
 649          {
 650   1          u8 buf[2];
 651   1          buf[0] = address;
 652   1          buf[1] = value;
 653   1          writeReadAS399x( buf, 2, 0 , 0 , STOP_NONE, 1);
 654   1      }
 655          
 656          /*------------------------------------------------------------------------- */
 657          void as399xContinuousRead(u8 address, s8 len, u8 *readbuf)
 658          {
 659   1          DISEXTIRQ();
 660   1          address |= READ|CONTINUOUS;
 661   1          writeReadAS399x( &address, 1, readbuf , len , STOP_CONT, 1);
 662   1          ENEXTIRQ();
 663   1      }
 664          
 665          /*------------------------------------------------------------------------- */
 666          void as399xFifoRead(s8 len, u8 *readbuf)
 667          {
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 12  

 668   1      #if COMMUNICATION_SERIAL
                  u8 address = (AS399X_REG_FIFO - 1) | READ ;
                  DISEXTIRQ();
                  writeReadAS399x( &address, 1, &address , 1 , STOP_NONE, 1);
                  address = (AS399X_REG_FIFO ) | READ | CONTINUOUS ;
                  writeReadAS399x( &address, 1, readbuf , len , STOP_CONT, 0);
                  ENEXTIRQ();
              #else
 676   1          as399xContinuousRead(AS399X_REG_FIFO, len , readbuf);
 677   1      #endif
 678   1      }
 679          
 680          
 681          u8 as399xSingleRead(u8 address)
 682          {
 683   1          u8 readdata;
 684   1      
 685   1          DISEXTIRQ();
 686   1          address |= READ;
 687   1          writeReadAS399x( &address, 1, &readdata , 1 , STOP_SGL, 1);
 688   1      
 689   1          ENEXTIRQ();
 690   1          return(readdata);
 691   1      }
 692          
 693          
 694          u8 as399xSingleReadIrq(u8 address)
 695          {
 696   1          u8 readdata;
 697   1      
 698   1          DISEXTIRQ();
 699   1          address |= READ;
 700   1          writeReadAS399xIsr( address, &readdata );
 701   1      
 702   1          ENEXTIRQ();
 703   1          return(readdata);
 704   1      }
 705          
 706          
 707          /*------------------------------------------------------------------------- */
 708          void as399xWritePredistortion(const u8 buf[252])
 709          {
 710   1          u8 address, version;
 711   1          version = as399xReadChipVersion();
 712   1          address = (AS399X_REG_VERSION | CONTINUOUS);
 713   1          DISEXTIRQ();
 714   1          writeReadAS399x( &address, 1, 0 , 0 , STOP_NONE, 1);
 715   1          writeReadAS399x( &version, 1, 0 , 0 , STOP_NONE, 0);
 716   1          writeReadAS399x( buf+1, 251, 0 , 0 , STOP_CONT, 0);
 717   1          ENEXTIRQ();
 718   1      }
 719          
 720          void as399xContinuousWrite(u8 address, u8 *buf, s8 len)
 721          {
 722   1          address |= CONTINUOUS;
 723   1          DISEXTIRQ();
 724   1          writeReadAS399x( &address, 1, 0 , 0 , STOP_NONE, 1);
 725   1          writeReadAS399x( buf, len, 0 , 0 , STOP_CONT, 0);
 726   1          ENEXTIRQ();
 727   1      }
 728          
 729          void as399xSingleWrite(u8 address, u8 value)
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 13  

 730          {
 731   1          u8 buf[2];
 732   1          buf[0] = address;
 733   1          buf[1] = value;
 734   1          DISEXTIRQ();
 735   1          writeReadAS399x( buf, 2, 0 , 0 , STOP_SGL, 1);
 736   1          ENEXTIRQ();
 737   1      }
 738          
 739          /*------------------------------------------------------------------------- */
 740          void as399xCommandContinuousAddress(u8 *command, u8 com_len,
 741                                       u8 address, u8 *buf, u8 buf_len)
 742          {
 743   1          address |= CONTINUOUS;
 744   1          DISEXTIRQ();
 745   1          writeReadAS399x( command, com_len, 0 , 0 , STOP_NONE, 1);
 746   1          writeReadAS399x( &address, 1, 0 , 0 , STOP_NONE, 0);
 747   1          writeReadAS399x( buf, buf_len, 0 , 0 , STOP_CONT, 0);
 748   1          ENEXTIRQ();
 749   1      }
 750          
 751          /*------------------------------------------------------------------------- */
 752          void as399xSwitchToIdleMode(void)
 753          {
 754   1          as399xSingleCommand(AS399X_CMD_IDLE);
 755   1      }
 756          
 757          void as399xWaitForResponseTimed(u16 waitMask, u16 counter)
 758          {
 759   1          while (((as399xResponse & waitMask) == 0) && (counter))
 760   1          {
 761   2              if (TIMER_IS_DONE())
 762   2              {
 763   3                  timerStart_us(1000);
 764   3                  counter--;
 765   3              }
 766   2          }
 767   1          if (counter==0)
 768   1          {
 769   2              as399xReset();
 770   2      #if !UARTSUPPORT
 771   2              CON_print("TI O T %x %x\n", as399xResponse, waitMask);
 772   2      #endif
 773   2              as399xResponse = RESP_NORESINTERRUPT;
 774   2          }
 775   1      
 776   1      }
 777              
 778          void as399xWaitForResponse(u16 waitMaskOrig)
 779          {
 780   1          u16 counter;
 781   1          u16 DATA waitMask = waitMaskOrig;
 782   1          for (counter=0; counter < 0xFFFD; counter++)
 783   1          {
 784   2              if ((as399xResponse & waitMask) != 0)
 785   2                  break;
 786   2          }
 787   1          if (counter > 0xFFF0)
 788   1          {
 789   2              as399xReset();
 790   2      #if !UARTSUPPORT
 791   2              CON_print("TI O %x %x\n", as399xResponse, waitMask);
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 14  

 792   2              //as399xDebugResponse();
 793   2      #endif
 794   2              as399xResponse = RESP_NORESINTERRUPT;
 795   2          }
 796   1      }
 797          
 798          #if ISO6B
 799          void as399xEnterDirectMode()
 800          {
 801   1          u8 temp;
 802   1          u8 buf[3];
 803   1          /* workaround for reset bug in Protocol Register 1 */
 804   1          temp = as399xSingleRead(AS399X_REG_RXSPECIAL2);
 805   1          /*  Set to ISO 6B, Bit clock and data; Tari 25us */
 806   1          as399xSingleWrite(AS399X_REG_PROTOCOLCTRL, 0x22);
 807   1          as399xSingleWrite (AS399X_REG_RXSPECIAL2,temp); /* Finish workaround */
 808   1      
 809   1          as399xContinuousRead(AS399X_REG_MODULATORCTRL, 3, buf);
 810   1          buf[1] &= ~0x40;      // disable PR_ASK, it's not supported in ISO 6B
 811   1          as399xContinuousWrite(AS399X_REG_MODULATORCTRL, buf, 3);
 812   1      
 813   1          as399xSingleWrite(AS399X_REG_IRQMASKREG, 0x00); /* mask Irqs */
 814   1      
 815   1          temp = as399xSingleRead(AS399X_REG_STATUSCTRL);
 816   1          as399xSelectLinkFrequency(0); /*  Set to 40kHz Link frequency */
 817   1          as399xSingleCommand(AS399X_CMD_RESETFIFO);
 818   1          as399xSingleCommand(AS399X_CMD_ENABLERX);
 819   1          temp |= 0x43;
 820   1      #if COMMUNICATION_SERIAL
                  /* enter direct mode, rf on, rx on, NO STOPCONDITION !!! */
                  as399xSingleWrite(AS399X_REG_STATUSCTRL, temp);
              #else
 824   1          /* enter direct mode, rf on, rx on, NO STOPCONDITION !!! */
 825   1          as399xSingleWriteNoStop(AS399X_REG_STATUSCTRL, temp);
 826   1      #endif
 827   1          AS399X_ENABLE_SENDER(); /* Disable receiver (IO2 low) and drive also IO3 low. */
 828   1          mdelay(1); /* AS3992 seems to need this */
 829   1          DISEXTIRQ(); /* disable Interrrupt */
 830   1          setPortDirect();
 831   1      }
 832          
 833          void as399xExitDirectMode()
 834          {
 835   1          u8 buf[3];
 836   1          as399xClrResponse();
 837   1      #if COMMUNICATION_SERIAL
                  /* exit direct mode, rf on, rx on */
                  as399xSingleWrite(AS399X_REG_STATUSCTRL, 0x03);
              #endif
 841   1          AS399X_ENABLE_SENDER();
 842   1          setPortNormal();
 843   1          as399xContinuousRead(AS399X_REG_MODULATORCTRL, 3, buf);
 844   1          buf[1] |= 0x40;      // enable PR_ASK again for Gen2
 845   1          as399xContinuousWrite(AS399X_REG_MODULATORCTRL, buf, 3);
 846   1      
 847   1          /* clear Irq flags and unmask Irqs */
 848   1          as399xSingleRead(AS399X_REG_IRQSTATUS);
 849   1          as399xClrResponse();
 850   1          as399xSingleWrite(AS399X_REG_IRQMASKREG, AS399X_IRQ_MASK_ALL);
 851   1      
 852   1          ENEXTIRQ();
 853   1      }
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 15  

 854          #endif
 855          
 856          void as399xSelectLinkFrequency(u8 a)
 857          {
 858   1          u8 reg;
 859   1      
 860   1      #if RUN_ON_AS3992
 861   1          if ( a == 0)
 862   1          { /* bypass for 40 kHz */
 863   2              as399xSingleWrite(AS399X_REG_RXSPECIAL,0x40);
 864   2          }
 865   1          if ( a == 6)
 866   1          { /* bypass for 160 kHz */
 867   2              as399xSingleWrite(AS399X_REG_RXSPECIAL,0x80);
 868   2          }
 869   1      #endif
 870   1      
 871   1          reg = as399xSingleRead(AS399X_REG_RXOPTGEN2);
 872   1      
 873   1          reg &= ~0xf0;
 874   1          reg |= (a<<4);
 875   1          as399xSingleWrite(AS399X_REG_RXOPTGEN2, reg);
 876   1      }
 877          
 878          static void as399xLockPLL(void)
 879          {
 880   1          u8 buf[3];
 881   1          u8 var;
 882   1          u16 i;
 883   1      
 884   1          if(as399xChipVersion!=AS3990)
 885   1          {
 886   2              u8 vco_voltage;
 887   2              as399xContinuousRead(AS399X_REG_TESTSETTING, 3, buf);
 888   2              buf[2] &= ~0x01; buf[1] &= ~0xc0; buf[1] |= 0x40; /* have vco_ri in aglstatus */
 889   2              as399xContinuousWrite(AS399X_REG_TESTSETTING, buf, 3);
 890   2      
 891   2              i = 0;
 892   2              do
 893   2              {
 894   3                  i++;
 895   3                  udelay(100);  /* wait for pll locking */
 896   3                  var=as399xSingleRead(AS399X_REG_AGCINTERNALSTATUS);
 897   3              } while ( (var & 0x02)==0 && (i<100));/* wait for PLL to be locked and give a few attempts */
 898   2      
 899   2              as399xContinuousRead(AS399X_REG_CLSYSAOCPCTRL, 3, buf);
 900   2              buf[1] |= 0x08; /* set mvco bit */
 901   2              as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, buf, 3);
 902   2              udelay(200);
 903   2              vco_voltage = as399xSingleRead(AS399X_REG_AGLSTATUS) & 0x07; 
 904   2      
 905   2              buf[1] &= ~0x08; /* reset mvco bit */
 906   2              as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, buf, 3);
 907   2      
 908   2              /* if we are in the guardband area of an pll segment switch to a segment which fits better */
 909   2              if ( vco_voltage <= 1 || vco_voltage >= 6 )
 910   2              {
 911   3                  i=0;
 912   3                  do
 913   3                  {
 914   4                      i++;
 915   4                      buf[1] &= ~(0x80);   /* reset the auto bit */
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 16  

 916   4                      as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, buf, 3);
 917   4                      buf[1] |= 0x80;   /* set the auto Bit */
 918   4                      as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, buf, 3);
 919   4                      mdelay(10);  /* Please keep in mind, that the Auto Bit procedure will take app. 6 ms where
             -by the locktime of PLL is just 400us */
 920   4                      var=as399xSingleRead(AS399X_REG_AGCINTERNALSTATUS);
 921   4                  } while ( (var & 0x02)==0 && (i<3));/* wait for PLL to be locked and give a few attempts */
 922   3              }
 923   2          }
 924   1      }
 925          
 926          /*------------------------------------------------------------------------- */
 927          void as399xSetBaseFrequency(u8 regs, u32 frequency)
 928          {
 929   1          u8 buf[3];
 930   1          u8 statusreg;
 931   1          u16 ref, i, j, x, reg_A,reg_B;
 932   1          u32 divisor;
 933   1      
 934   1          as399xCurrentBaseFreq = frequency;
 935   1          statusreg= as399xSingleRead(AS399X_REG_STATUSCTRL);
 936   1          as399xSingleWrite(AS399X_REG_STATUSCTRL,statusreg&0xfe);
 937   1          if (regs== AS399X_REG_PLLMAIN)
 938   1          {
 939   2              as399xContinuousRead(AS399X_REG_PLLMAIN, 3, buf);
 940   2              switch (buf[2]& 0x70)
 941   2              {
 942   3              case 0x00: {
 943   4                  ref=500;
 944   4              } break;
 945   3              case 0x10: {
 946   4                  ref=250;
 947   4              } break;
 948   3              case 0x40: {
 949   4                  ref=200;
 950   4              } break;
 951   3              case 0x50: {
 952   4                  ref=100;
 953   4              } break;
 954   3              case 0x60: {
 955   4                  ref=50;
 956   4              } break;
 957   3              case 0x70: {
 958   4                  ref=25;
 959   4              } break;
 960   3              default: {
 961   4                  ref=0;
 962   4              }
 963   3              }
 964   2          }
 965   1          divisor=frequency/ref;
 966   1      
 967   1          i = 0x3FFF & (divisor >> 6); /* division by 64 */
 968   1          x = (i<<6)+ i;
 969   1          if (divisor > x)
 970   1          {
 971   2              x += 65;
 972   2              i++;
 973   2          }
 974   1          x -= divisor;
 975   1          j = i;
 976   1          do
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 17  

 977   1          {
 978   2              if (x >= 33)
 979   2              {
 980   3                  i--;
 981   3                  x -= 33;
 982   3              }
 983   2              if (x >= 32)
 984   2              {
 985   3                  j--;
 986   3                  x -= 32;
 987   3              }
 988   2          } while (x >= 32);
 989   1          if (x > 16) 
 990   1          {            /* subtract 32 from x if it is larger than 16 */
 991   2              x -= 32; /* this yields more closely matched A and B values */
 992   2              j--;
 993   2          }
 994   1      
 995   1          reg_A = i - x;
 996   1          reg_B = j + x;
 997   1          if (regs==AS399X_REG_PLLMAIN)
 998   1          {
 999   2              buf[2] = (buf[2] & 0xF0) | ((u8)((reg_B >> 6) & 0x0F));
1000   2              buf[1] = (u8)((reg_B << 2) & 0xFC) |  (u8)((reg_A >> 8) & 0x03);
1001   2              buf[0] = (u8)reg_A;
1002   2      
1003   2              as399xContinuousWrite(AS399X_REG_PLLMAIN, buf, 3);
1004   2          }
1005   1          as399xLockPLL();
1006   1          as399xSingleWrite(AS399X_REG_STATUSCTRL,statusreg);
1007   1      }
1008          
1009          /*------------------------------------------------------------------------- */
1010          void as399xMemoryDump(void)
1011          {
1012   1          u8 error,i;
1013   1          u8 readbuf[4];
1014   1      
1015   1          for (i=0;i<0x1F;i++)
1016   1          {
1017   2              CON_print("\nreg %hhx   ",i);
1018   2      
1019   2              if (i==0x12 || i==0x14 || i==0x15 || i==0x16 || i==0x17 )
1020   2              {
1021   3                  as399xContinuousRead(i, 3, readbuf);
1022   3                  CON_print("%hhx ",readbuf[2]);
1023   3                  CON_print("%hhx ",readbuf[1]);
1024   3                  CON_print("%hhx ",readbuf[0]);
1025   3              }
1026   2              else
1027   2              {
1028   3                  error = as399xSingleRead(i);
1029   3                  CON_print("%hhx",error);
1030   3              }
1031   2          }
1032   1      }
1033          
1034          void as399xReset(void)
1035          {
1036   1          as399xEnterPowerDownMode();
1037   1          mdelay(1);
1038   1          as399xExitPowerDownMode();
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 18  

1039   1      }
1040          
1041          
1042          void as399xAntennaPower( u8 on )
1043          {
1044   1          u8 val, dac = 0;
1045   1          unsigned count;
1046   1      
1047   1          val = as399xSingleRead(AS399X_REG_STATUSCTRL);
1048   1      
1049   1          outputPowerOn = on;     //keep state of output power for as399xCyclicPowerRegulation()
1050   1      
1051   1          if (on)
1052   1          {
1053   2              if (val & 0x01)
1054   2                  return;         // antenna power is already turned on.
1055   2      #if ROGER 
                      DCDC(LOW);  
                      udelay(5); /* To avoid current spikes */
              #endif
1059   2      #ifdef EXTPA
                      EN_PA(HIGH);
                      udelay(200); /* Give PA LDO time to get to maximum power */
              #endif
1063   2      #ifdef POWER_DETECTOR
                      /* set DAC to lowest value */
                      dac = as399xReadDAC();
                      as399xWriteDAC(MIN_DAC);
                      val |= 0x21; /* DAC & rf_on enable */
                      EN_BIAS = 1;
                      as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
                      /* ramp up DAC smoothly (100mV steps), otherwise we will get spikes in spectrum */
                      for (count = MIN_DAC+4; count < dac; count += 4)
                      {
                          as399xWriteDAC(count);
                          udelay(10);
                      }
                      as399xWriteDAC(dac);        /* ensure that the initial DAC value is set again */
                      udelay(100); /* PA has to settle after new dac voltage */
              #else
1079   2              val |= 1;
1080   2              as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
1081   2      #endif
1082   2          }
1083   1          else
1084   1          {
1085   2              if (!(val & 0x01))
1086   2                  return;         // antenna power is already turned off.
1087   2      #ifdef POWER_DETECTOR
                      /* ramp DAC down */
                      dac = as399xReadDAC();
                      for (count = dac; count >= MIN_DAC+4; count -= 4)
                      {
                          as399xWriteDAC(count);
                          udelay(10);
                      }
                      val &= ~0x20; /* DAC disable */
                      as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
                      EN_BIAS = 0;
                      as399xWriteDAC(dac);        /* keep dac value for later power up */
              #endif
1100   2              val &= ~1;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 19  

1101   2              as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
1102   2              /* Wait for antenna being switched off */
1103   2              count = 500;
1104   2              while(count-- && (as399xSingleRead(AS399X_REG_AGCINTERNALSTATUS) & 0x04))
1105   2              {
1106   3                  mdelay(1);
1107   3              }
1108   2      #ifdef EXTPA
                      EN_PA(LOW);
              #endif
1111   2      #if ROGER
                      DCDC(HIGH);  
              #endif
1114   2          }
1115   1      
1116   1          if(on) /* according to standard we have to wait 1.5ms before issuing commands  */
1117   1      #if ROLAND
                      mdelay(6);          // MOT wants to have higher dwell time
              #else
1120   1              mdelay(1.5);        //TODO: define dwell time via GUI
1121   1      #endif
1122   1      }
1123          
1124          static u8 as399xGetRawRSSI( void )
1125          {
1126   1          u8 value;
1127   1      
1128   1          as399xSingleCommand(AS399X_CMD_BLOCKRX);
1129   1          as399xSingleCommand(AS399X_CMD_ENABLERX);
1130   1      #if RUN_ON_AS3992
1131   1          udelay(500); /* According to architecture note we have to wait here at least 100us
1132   1                          however experiments show 350us to be necessary on AS3992 */
1133   1      #else
                  udelay(100); /* According to architecture note we have to wait here at least 100us */
              #endif
1136   1          value = as399xSingleRead(AS399X_REG_RSSILEVELS);
1137   1          as399xSingleCommand(AS399X_CMD_BLOCKRX);
1138   1          return value;
1139   1      }
1140          
1141          void as399xSaveSensitivity( )
1142          {
1143   1          as399xSavedSensRegs[0] = as399xSingleRead(AS399X_REG_TRCALGEN2MISC);
1144   1          as399xSavedSensRegs[1] = as399xSingleRead(AS399X_REG_RXSPECIAL2);
1145   1      }
1146          
1147          void as399xRestoreSensitivity( )
1148          {
1149   1           as399xSingleWrite(AS399X_REG_TRCALGEN2MISC,as399xSavedSensRegs[0]);
1150   1           as399xSingleWrite(AS399X_REG_RXSPECIAL2   ,as399xSavedSensRegs[1]);
1151   1      }
1152          
1153          s8 as399xGetSensitivity( )
1154          {
1155   1          s8 sensitivity = 0;
1156   1      #if RUN_ON_AS3992
1157   1          u8 reg0a, reg05, gain;
1158   1      
1159   1          reg05 = as399xSingleRead(AS399X_REG_TRCALGEN2MISC);
1160   1          reg0a = as399xSingleRead(AS399X_REG_RXSPECIAL2);
1161   1      
1162   1          if ((reg0a & 0x04))
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 20  

1163   1          { /* single ended input mixer*/
1164   2              sensitivity -= 72;
1165   2              if ( reg0a & 1 ) /* mixer input attenuation */
1166   2              {
1167   3                  sensitivity += 5;
1168   3              }
1169   2          }
1170   1          else
1171   1          { /* differential input mixer */
1172   2              sensitivity -= 66;
1173   2              if ( reg0a & 1 )  /* mixer attenuation */
1174   2              {
1175   3                  sensitivity += 8;
1176   3              }
1177   2              if ( reg0a & 2)  /* differential mixer gain increase */
1178   2              {
1179   3                  sensitivity -= 10;
1180   3              }
1181   2          }
1182   1          gain = (reg0a >> 6) * 3;
1183   1          if ( reg05 & 0x80 )
1184   1          { /* RX Gain direction: increase */
1185   2              sensitivity -= gain;
1186   2          }
1187   1          else
1188   1          {
1189   2              sensitivity += gain;
1190   2          }
1191   1          return sensitivity;
1192   1      #else
                  u8 reg0a;
                  reg0a   = as399xSingleRead(AS399X_REG_RXSPECIAL2);
                  if ((reg0a & 0x04))
                  { /* single ended input mixer*/
                      if(reg0a & 1)
                      { /* attenuation on */
                          sensitivity -= 67;
                      }
                      else
                      {
                          sensitivity -= 72;
                      }
                  }
                  else
                  { /* differential input mixer */
                      if(reg0a & 1)
                      { /* attenuation on */
                          sensitivity -= 58;
                      }
                      else
                      {
                          sensitivity -= 66;
                      }
                  }
                  sensitivity += (reg0a >> 6) * 3;
                  return sensitivity;
              #endif
1220   1      }
1221          s8 as399xSetSensitivity( s8 minimumSignal )
1222          {
1223   1      #if RUN_ON_AS3992
1224   1          u8 reg0a, reg05, gain;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 21  

1225   1      
1226   1          reg05 = as399xSingleRead(AS399X_REG_TRCALGEN2MISC);
1227   1          reg0a = as399xSingleRead(AS399X_REG_RXSPECIAL2);
1228   1      
1229   1          reg0a &= ~0xc3;
1230   1          if ((reg0a & 0x04))
1231   1          { /* single ended input mixer*/
1232   2              minimumSignal += 72;
1233   2              if ( minimumSignal > 5 ) 
1234   2              {
1235   3                  minimumSignal -= 5; /* mixer input attenuation */
1236   3                  reg0a |= 1;
1237   3              }
1238   2          }
1239   1          else
1240   1          { /* differential input mixer */
1241   2              minimumSignal += 66;
1242   2              if ( minimumSignal >= 8 )  /* mixer attenuation */
1243   2              {
1244   3                  minimumSignal -= 8;
1245   3                  reg0a |= 1;
1246   3              }
1247   2              if ( minimumSignal <= -10 )  /* differential mixer gain increase */
1248   2              {
1249   3                  minimumSignal += 10;
1250   3                  reg0a |= 2;
1251   3              }
1252   2          }
1253   1          if ( minimumSignal > 0)
1254   1          {
1255   2              reg05 &= ~0x80; /* RX Gain direction: decrease */
1256   2              gain = minimumSignal / 3;
1257   2              if ( gain>3 ) gain = 3;
1258   2              minimumSignal -= gain*3;
1259   2              
1260   2          }
1261   1          else
1262   1          {
1263   2              reg05 |= 0x80; /* RX Gain direction: increase */
1264   2              gain = (-minimumSignal+2) / 3;
1265   2              if ( gain>3 ) gain = 3;
1266   2              minimumSignal += gain*3;
1267   2          }
1268   1          reg0a |= (gain<<6);
1269   1          as399xSingleWrite(AS399X_REG_TRCALGEN2MISC,reg05);
1270   1          as399xSingleWrite(AS399X_REG_RXSPECIAL2   ,reg0a);
1271   1          return minimumSignal;
1272   1      #else
                  u8 reg0a, gain;
                  reg0a   = as399xSingleRead(AS399X_REG_RXSPECIAL2);
                  reg0a &= ~0xc1;
                  if ((reg0a & 0x04))
                  { /* single ended input mixer*/
                      if(minimumSignal < -67)
                      {
                          minimumSignal += 72;
                      }
                      else
                      {
                          reg0a |= 1; /* attenuation on */
                          minimumSignal += 67;
                      }
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 22  

                  }
                  else
                  { /* differential input mixer */
                      if(minimumSignal < -58)
                      {
                          minimumSignal += 66;
                      }
                      else
                      {
                          reg0a |= 1; /* attenuation on */
                          minimumSignal += 58;
                      }
                  }
                  if ( minimumSignal > 0)
                  {
                      gain = minimumSignal / 3;
                      if ( gain>3 ) gain = 3;
                      minimumSignal -= gain*3;
                      reg0a |= (gain<<6);
                  }
                  as399xSingleWrite(AS399X_REG_RXSPECIAL2   ,reg0a);
                  return minimumSignal;
              #endif
1310   1      }
1311          
1312          void as399xGetRSSI( u16 num_of_ms_to_scan, u8 *rawIQ, s8* dBm )
1313          {
1314   1          u8 valstat;
1315   1          u8 rawVal, reg0a;
1316   1          u8 regFilter;
1317   1      #if RUN_ON_AS3992
1318   1          u16 num_of_reads = num_of_ms_to_scan/2; /* as399xGetRawRSSI() delays 500us*/
1319   1          u8 reg05;
1320   1      #else
                  u16 num_of_reads = num_of_ms_to_scan/10; /* as399xGetRawRSSI() delays 100us*/
              #endif 
1323   1          s8 sum;
1324   1      
1325   1          if (num_of_reads == 0) num_of_reads = 1;
1326   1          valstat = as399xSingleRead(AS399X_REG_STATUSCTRL);
1327   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, 2 ); /* Receiver on and transmitter are off */
1328   1          regFilter = as399xSingleRead(AS399X_REG_RXSPECIAL);
1329   1      #if RUN_ON_AS3992
1330   1          as399xSingleWrite(AS399X_REG_RXSPECIAL, 0xff ); /* Optimal filter settings */
1331   1      #else
                  as399xSingleWrite(AS399X_REG_RXSPECIAL, 0x01 ); /* Optimal filter settings */
              #endif
1334   1          if(!(valstat & 0x02)) mdelay(10); /* rec_on needs about 6ms settling time, to be sure wait 10 ms */
1335   1      
1336   1          sum = 0;
1337   1          while (num_of_reads--)
1338   1          {
1339   2              u8 temp;
1340   2              rawVal = as399xGetRawRSSI();
1341   2              temp = (rawVal&0x0f) + (rawVal>>4);
1342   2              if (temp > sum)
1343   2              {
1344   3                  sum = temp;
1345   3                  *rawIQ = rawVal;
1346   3              }
1347   2          }
1348   1      
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 23  

1349   1          if (sum == 0)
1350   1          { /* short exit, below formula does not work for 0 value */
1351   2              *dBm   = -128;
1352   2              *rawIQ = 0;
1353   2              goto end;
1354   2          }
1355   1      
1356   1      #if RUN_ON_AS3992
1357   1          sum += (sum>>3); /* ~2.2*meanRSSI, here we calculate 2.25*meanRSSI, should not matter with a range 0..
             -30 */
1358   1          reg0a = as399xSingleRead(AS399X_REG_RXSPECIAL2);
1359   1          reg05 = as399xSingleRead(AS399X_REG_TRCALGEN2MISC);
1360   1          if ((reg0a & 0x04))
1361   1          { /* single ended input mixer*/
1362   2              sum -= 75;
1363   2              if ((reg0a & 0x01)) sum += 5; /* attenuation */
1364   2          }
1365   1          else
1366   1          { /* differential input mixer */
1367   2              sum -= 71;
1368   2              if ((reg0a & 0x02)) sum -= 10; /* differential mixer gain increase */
1369   2              if ((reg0a & 0x01)) sum += 8; /* attenuation */
1370   2          }
1371   1          /* Gain in/de-crease */
1372   1          if (reg05 & 0x80)
1373   1          {
1374   2              sum -= 3*(reg0a>>6);
1375   2          }
1376   1          else
1377   1          {
1378   2              sum += 3*(reg0a>>6);
1379   2          }
1380   1      #else
                  reg0a   = as399xSingleRead(AS399X_REG_RXSPECIAL2);
                  switch (reg0a & 0x05)
                  {
                      case 0: sum-=68; break; /* actually -67.5 */
                      case 1: sum-=59; break;
                      case 4: sum-=71; break; /* actually -70.5 */
                      case 5: sum-=65; break;
                  }
                  sum += 3*(reg0a>>6);
              #endif
1391   1          *dBm = sum;
1392   1      
1393   1      end:
1394   1          as399xSingleWrite(AS399X_REG_RXSPECIAL, regFilter ); /* Restore filter */
1395   1          as399xSingleWrite(AS399X_REG_STATUSCTRL,valstat);
1396   1          if(valstat & 1) mdelay(6); /* according to standard we have to wait 1.5ms before issuing commands  */
1397   1          return;
1398   1      }
1399          /* ADC Values are in sign magnitude representation -> convert */
1400          #define CONVERT_ADC_TO_NAT(A) (((A)&0x80)?((A)&0x7f):(0 - ((A)&0x7f)))
1401          s8 as399xGetADC( void )
1402          {
1403   1          s8 val;
1404   1          as399xSingleCommand(AS399X_CMD_TRIGGERADCCON);
1405   1          udelay(20); /* according to spec */
1406   1          val = as399xSingleRead(AS399X_REG_ADC);
1407   1          val = CONVERT_ADC_TO_NAT(val);
1408   1          return val;
1409   1      }
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 24  

1410          
1411          /* DAC Values are in sign magnitude representation - convert */
1412          #define CONVERT_NAT_TO_DAC(A) (((A)&0x80)?(A):(0x7f - ((A)&0x7f)))
1413          #define CONVERT_DAC_TO_NAT(A) (((A)&0x80)?(A):(0x7f - ((A)&0x7f)))
1414          void as399xWriteDAC( u8 natVal )
1415          {
1416   1              u8 dacVal = CONVERT_NAT_TO_DAC(natVal);
1417   1          as399xSingleWrite(AS399X_REG_DAC, dacVal);
1418   1      }
1419          u8 as399xReadDAC( void )
1420          {
1421   1              u8 dac, nat;
1422   1              dac = as399xSingleRead(AS399X_REG_DAC);
1423   1              nat = CONVERT_DAC_TO_NAT(dac);
1424   1              return nat;
1425   1      }
1426          
1427          u16 as399xGetADC_mV( void )
1428          {
1429   1          s8 val;
1430   1          u16 mV;
1431   1          val = as399xGetADC();
1432   1      
1433   1          mV = val + 0x80;
1434   1          mV = 12 * mV + mV / 2; /*12.5 mV per division*/
1435   1      
1436   1          //CON_print("adc : %hx mV\n",mV);
1437   1          return mV;
1438   1      }
1439          
1440          u16 as399xGetReflectedPower( void )
1441          {
1442   1          u16 value;
1443   1          s8 adcVal;
1444   1          u8 reg[3],reg14Temp,valstat;
1445   1          valstat = as399xSingleRead(AS399X_REG_STATUSCTRL);
1446   1          as399xContinuousRead(AS399X_REG_CLSYSAOCPCTRL, 3, reg);
1447   1          reg14Temp = reg[0];
1448   1          reg[0] &= ~0x30; /* disable the OAD pin outputs */
1449   1          as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, reg,3);
1450   1      
1451   1          /* measure the value */
1452   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, valstat | 0x3 ); /* Receiver and transmitter are on */
1453   1          as399xSingleCommand(AS399X_CMD_BLOCKRX); /* Reset the receiver - otherwise the I values seem to oscill
             -ate */
1454   1          //mdelay(1);
1455   1          as399xSingleCommand(AS399X_CMD_ENABLERX);
1456   1          as399xSingleWrite(AS399X_REG_MEASURE_SELECTOR, 0x01); /* Mixer A DC */
1457   1      #if ROLAND || ARNIE // TODO: check if we can reduce wait time for all boards (also in as399xGetReflectedPo
             -werNoiseLevel)
                  udelay(1000);
              #else
1460   1          mdelay(2); /* settling time, test showed this is not necessary on LEO but it might on other boards*/
1461   1      #endif
1462   1          adcVal = as399xGetADC();
1463   1          value = adcVal;
1464   1          as399xSingleWrite(AS399X_REG_MEASURE_SELECTOR, 0x02); /* Mixer B DC */
1465   1      #if ROLAND || ARNIE
                  udelay(1000);
              #else
1468   1          mdelay(2); /* settling time, test showed this is not necessary on LEO but it might on other boards*/
1469   1      #endif
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 25  

1470   1          adcVal = as399xGetADC();
1471   1      
1472   1          /* mask out shifted in sign bits */
1473   1          value = (value &0xff) | (adcVal<<8);
1474   1          as399xContinuousRead(AS399X_REG_CLSYSAOCPCTRL, 3, reg); /* restore the values */
1475   1          reg[0]=reg14Temp;
1476   1          as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, reg,3);
1477   1          as399xSingleWrite(AS399X_REG_STATUSCTRL,valstat);
1478   1          return value;
1479   1      }
1480          
1481          u16 as399xGetReflectedPowerNoiseLevel( void )
1482          {
1483   1          u16 value;
1484   1              s8 i_0, q_0;
1485   1          u8 reg[3],reg14Temp,valstat;
1486   1          valstat = as399xSingleRead(AS399X_REG_STATUSCTRL);
1487   1          as399xContinuousRead(AS399X_REG_CLSYSAOCPCTRL, 3, reg);
1488   1          reg14Temp = reg[0];
1489   1          reg[0] &= ~0x30; /* disable the OAD pin outputs */
1490   1          as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, reg,3);
1491   1      
1492   1              /* First measure the offset which might appear with disabled antenna */
1493   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, (valstat | 2) & (~1) ); /* Field off, receiver on */
1494   1          as399xSingleCommand(AS399X_CMD_BLOCKRX); /* Reset the receiver - otherwise the I values seem to oscill
             -ate */
1495   1          //mdelay(1);
1496   1          as399xSingleCommand(AS399X_CMD_ENABLERX);
1497   1          as399xSingleWrite(AS399X_REG_MEASURE_SELECTOR, 0x01); /* Mixer A DC */
1498   1      #if ROLAND || ARNIE
                  udelay(1000);
              #else
1501   1          mdelay(2); /* settling time, test showed this is not necessary on LEO but it might on other boards*/
1502   1      #endif
1503   1          i_0 = as399xGetADC();
1504   1          as399xSingleWrite(AS399X_REG_MEASURE_SELECTOR, 0x02); /* Mixer B DC */
1505   1      #if ROLAND || ARNIE
                  udelay(1000);
              #else
1508   1          mdelay(2); /* settling time, test showed this is not necessary on LEO but it might on other boards*/
1509   1      #endif
1510   1          q_0 = as399xGetADC();
1511   1      
1512   1          value = (i_0 & 0xff) | (q_0<<8);
1513   1          as399xContinuousRead(AS399X_REG_CLSYSAOCPCTRL, 3, reg); /* restore the values */
1514   1          reg[0]=reg14Temp;
1515   1          as399xContinuousWrite(AS399X_REG_CLSYSAOCPCTRL, reg,3);
1516   1          as399xSingleWrite(AS399X_REG_STATUSCTRL,valstat);
1517   1          return value;
1518   1      }
1519          
1520          #ifdef POWER_DETECTOR
              
              /** Points to the entry in dBm2Setting which represents the current power setting. */
              struct powerDetectorSetting *currPDSet;
              /** Index of currPDSet in dBm2Setting table. */
              u8 currPDSetIndex;
              
              /** This table keeps the mean values between to adjacent values of dBm2Setting.
               * When regulating the power in as399xAdaptTxPower() the DAC will not be modified,
               * when the measured ADC voltage is inside the correlating hysteresis values in
               * dBm2SettingHysteresis. */
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 26  

              u16 dBm2SettingHysteresis[POWER_TABLE_SIZE-1];
              
              /**
               * This is an lookup table for the output power. The index of the table equals the
               * desired output power in dBm (eg: index 2 in the table contains settings for 2dBm
               * output power).
               */
              #if ROLAND
              struct powerDetectorSetting dBm2Setting[POWER_TABLE_SIZE]={
                  {0x0F,449}, //0dBm
                  {0x0F,456},
                  {0x0F,473},
                  {0x0F,481},
                  {0x0F,504},
                  {0x0F,524}, //5dBm
                  {0x0F,544},
                  {0x0F,576},
                  {0x0F,595},
                  {0x0F,631},
                  {0x0F,657}, //10dBm
                  {0x0F,690},
                  {0x0F,728},
                  {0x0F,757},
                  {0x0F,806},
                  {0x0F,840}, //15dBm
                  {0x0F,890},
                  {0x0F,952},
                  {0x0F,1017},
                  {0x0F,1110},
                  {0x0F,1210},//20dBm
                  {0x0F,1341},
                  {0x0F,1490},
                  {0x0F,1673},
                  {0x0F,1879},
                  {0x0F,2137},//25dBm
                  {0x0D,2402},
                  {0x0B,2732},
                  {0x09,3114},
                  {0x08,3553},
                  {0x08,3972},//30dBm
              };
              #elif ARNIE
              struct powerDetectorSetting dBm2Setting[POWER_TABLE_SIZE]={
                  {0x0E,358}, //0dBm
                  {0x0E,368},
                  {0x0E,383},
                  {0x0E,395},
                  {0x0E,405},
                  {0x0E,417}, //5dBm
                  {0x0E,428},
                  {0x0E,441},
                  {0x0E,457},
                  {0x0E,475},
                  {0x0F,495}, //10dBm
                  {0x0F,523},
                  {0x0F,554},
                  {0x0F,590},
                  {0x0F,630},
                  {0x0F,680}, //15dBm
                  {0x0F,735},
                  {0x0F,800},
                  {0x0F,871},
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 27  

                  {0x0F,979},
                  {0x0F,1066},//20dBm
                  {0x0F,1193},
                  {0x0F,1310},
                  {0x0F,1443},
                  {0x0E,1585},
                  {0x0C,1750},//25dBm
                  {0x0C,1963},
                  {0x0A,2180},
                  {0x0A,2430},
                  {0x06,2676},
                  {0x05,2950},//30dBm
              };
              #endif
              
              s16 as399xSetTxPower(s16 des)
              {
                  s16 act;
                  u8 reg[3], dac = NOM_DAC;
              
                  act = (des + 5) / 10;       /* ensure correct rounding up */
                  if (act < 0) act = 0;
                  if (act > 30) act = 30;     //Todo: limit power differently for different boards?
              
                  currPDSet = dBm2Setting + act;
                  currPDSetIndex = act;
              
                  /* Set up to register val */
                  as399xContinuousRead(AS399X_REG_MODULATORCTRL, 3, reg);
                  reg[0] = reg[0] & 0xe0 | currPDSet->reg15_1;
                  as399xContinuousWrite(AS399X_REG_MODULATORCTRL, reg, 3);
                  as399xWriteDAC(dac);
              
                  /* Adapt PA bias voltage */
                  if(outputPowerOn == 0)
                  {
                      as399xAntennaPower(1);
                      as399xAdaptTxPower();
                      as399xAntennaPower(0);
                  }
                  else
                  {
                      as399xAdaptTxPower();
                  }
              
                  return act * 10;
              }
              
              void as399xUpdateTxPower(u8 dBm, u8 reg15, u16 mV)
              {
                  //update output power settings
                  dBm2Setting[dBm].reg15_1 = reg15;
                  dBm2Setting[dBm].adcVoltage_mV = mV;
                  //update output power hysteresis table
                  if (dBm < (POWER_TABLE_SIZE - 1))
                      dBm2SettingHysteresis[dBm] = (u16)((dBm2Setting[dBm+1].adcVoltage_mV - dBm2Setting[dBm].adcVoltage
             -_mV) / 2)
                              + dBm2Setting[dBm].adcVoltage_mV;
                  else
                      dBm2SettingHysteresis[dBm-1] = (u16)((dBm2Setting[dBm].adcVoltage_mV - dBm2Setting[dBm-1].adcVolta
             -ge_mV) / 2)
                              + dBm2Setting[dBm-1].adcVoltage_mV;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 28  

              }
              
              void calcTxPowerHysteresis(void)
              {
                  u8 i;
                  for( i=0; i<POWER_TABLE_SIZE-1; i++)
                  {
                      dBm2SettingHysteresis[i] = (u16)((dBm2Setting[i+1].adcVoltage_mV - dBm2Setting[i].adcVoltage_mV) /
             - 2)
                              + dBm2Setting[i].adcVoltage_mV;
                  }
              }
              
              #define DELTA(A,B) (((A)>(B))?((A)-(B)):((B)-(A)))
              void as399xAdaptTxPower(void)
              {
                  u16 mV, best_mV;
                  s8 dir;
                  u8 dac = as399xReadDAC();
                  u8 improvement = 1;
                  static u8 calcHysteresis = 1;
              
                  if ( calcHysteresis )
                  {
                      calcTxPowerHysteresis();
                      calcHysteresis = 0;
                  }
              
                  as399xSingleWrite(AS399X_REG_MEASURE_SELECTOR, 0x03); /* ADC pin */
              #if ROLAND
                  SWITCH_POST_PA(SWITCH_POST_PA_PD);
              #endif
                  //CON_print("desired %hx mV\n",currPDSet->adcVoltage_mV);
              
                  if ( dac <= MIN_DAC ) dac = MIN_DAC + 1;
                  if ( dac >= MAX_DAC ) dac = MAX_DAC - 1;
              
                  //CON_print("dac = %hhx ",dac);
                  as399xWriteDAC(dac);
                  best_mV = as399xGetADC_mV();
              
                  // check if we are inside a hysteresis area around the target value
                  // hysteresis area is half the distance to next target value.
                  if (currPDSetIndex > 1 && currPDSetIndex < (POWER_TABLE_SIZE - 1))
                  {
              //        CON_print("adapt tx power best_mV= %hx,  prev= %hx,  next= %x\n", best_mV,
              //                dBm2SettingHysteresis[currPDSetIndex-1], dBm2SettingHysteresis[currPDSetIndex]);
                      if ( best_mV > dBm2SettingHysteresis[currPDSetIndex-1] && best_mV < dBm2SettingHysteresis[currPDSe
             -tIndex])
                          return;
                  }
              
                  if ( best_mV > currPDSet->adcVoltage_mV )
                      dir = -1;
                  else
                      dir = 1;
              
                  while ( improvement )
                  {
                      if ( dac == MIN_DAC ) break;
                      if ( dac == MAX_DAC ) break;
              
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 29  

                      //CON_print("dac = %hhx ",dac + dir);
                      as399xWriteDAC(dac + dir);
                      mV = as399xGetADC_mV();
              
                      if ( DELTA(mV,currPDSet->adcVoltage_mV)
                              <= DELTA(best_mV,currPDSet->adcVoltage_mV))
                      {
                          best_mV = mV;
                          dac += dir;
                          if ( dac == 0x80 )
                              dac += dir;                     /* DAC values 0x80 and 0x00 have the same output voltage (only differ in sign b
             -it). In our nat representation this corresponds
                                                                               with the values 0x80 and 0x7F. Whenever we hit 0x80 we skip it by proceeding to 
             -the next value. */
                      }else{
                          improvement = 0;
                      }
                  }
              #if ROLAND
                  SWITCH_POST_PA(SWITCH_POST_PA_TUNING);
              #endif
                  //CON_print("best dac %hhx : %hx mV\n",dac,best_mV);
                  as399xWriteDAC(dac);
              }
              
              void as399xCyclicPowerRegulation(void)
              {
                  if (outputPowerOn && !evalPowerRegulation)
                  {
                      if (outputPowerCounter)
                      {
                          outputPowerCounter--;
                      }
                      else
                      {
                          outputPowerCounter = outputPowerCounterStart;
                          as399xAdaptTxPower();
                      }
                  }
              }
              
              void as399xInitCyclicPowerRegulation(u16 initCounter)
              {
                  //CON_print("counter: %hx \n", outputPowerCounterStart);
                  outputPowerCounter = initCounter;
                  outputPowerCounterStart = initCounter;
              }
              
              void as399xEvalPowerRegulation(u8 eval)
              {
                  evalPowerRegulation = eval;
              }
              
              #endif
1765          
1766          void as399xEnterStandbyMode()
1767          {
1768   1          u8 val;
1769   1          val = as399xSingleRead(AS399X_REG_STATUSCTRL);
1770   1          
1771   1          if (val & 0x80) /* already in standby */
1772   1              return;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 30  

1773   1      
1774   1          val |= 0x80;
1775   1      
1776   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
1777   1      }
1778          void as399xExitStandbyMode()
1779          {
1780   1          u8 val;
1781   1          val = as399xSingleRead(AS399X_REG_STATUSCTRL);
1782   1          
1783   1          if (!(val & 0x80)) /* not in standby */
1784   1              return;
1785   1      
1786   1          val &= ~0x80;
1787   1      
1788   1          as399xSingleWrite(AS399X_REG_STATUSCTRL, val);
1789   1      
1790   1          mdelay(1);
1791   1      
1792   1          as399xLockPLL();
1793   1      }
1794          
1795          
1796          void as399xEnterPowerDownMode()
1797          {
1798   1          u8 i;
1799   1          u8 reg3cnt = 0;
1800   1          int count;
1801   1      
1802   1      #if ROLAND
                  if (!(P4 & 0x02)) return;
              #else
1805   1          if (!ENABLE) return;
1806   1      #endif
1807   1      
1808   1          /* Switch off antenna */
1809   1          as399xPowerDownRegs[0] = as399xSingleRead(0);
1810   1          as399xSingleWrite(0, as399xPowerDownRegs[0] & (~0x03));
1811   1          for (i=1;i<AS399X_REG_ADC;i++)
1812   1          {
1813   2              if(  i==AS399X_REG_TESTSETTING   || i==AS399X_REG_CLSYSAOCPCTRL 
1814   2                || i==AS399X_REG_MODULATORCTRL || i==AS399X_REG_PLLMAIN 
1815   2                || i==AS399X_REG_PLLAUX )
1816   2              {
1817   3                  as399xContinuousRead(i, 3, as399xPowerDownRegs3[reg3cnt++]);
1818   3              }
1819   2              else
1820   2              {
1821   3                  as399xPowerDownRegs[i] = as399xSingleRead(i);
1822   3              }
1823   2          }
1824   1          /* Wait for antenna being switched off */
1825   1          count = 500;
1826   1          while(count-- && (as399xSingleRead(AS399X_REG_AGCINTERNALSTATUS) & 0x04))
1827   1          {
1828   2              mdelay(1);
1829   2          }
1830   1          EN(LOW);
1831   1      }
1832          void as399xExitPowerDownMode()
1833          {
1834   1          u8 i;
C51 COMPILER V9.51   AS399X                                                                01/02/2014 09:27:24 PAGE 31  

1835   1          u8 reg3cnt = 0;
1836   1      
1837   1      #if ROLAND
                  if (P4 & 0x02) return;
              #else
1840   1          if (ENABLE) return;
1841   1      #endif
1842   1      
1843   1          EN(HIGH);
1844   1          mdelay(12);  /* AS3992 needs 12 ms to exit standby */
1845   1          reg3cnt = 0;
1846   1          /* Do not switch on antenna before PLL is locked.*/
1847   1          as399xSingleWrite(0, as399xPowerDownRegs[0] & (~0x03));
1848   1          for (i=1;i<AS399X_REG_ADC;i++)
1849   1          {
1850   2              if(  i==AS399X_REG_TESTSETTING   || i==AS399X_REG_CLSYSAOCPCTRL 
1851   2                || i==AS399X_REG_MODULATORCTRL || i==AS399X_REG_PLLMAIN 
1852   2                || i==AS399X_REG_PLLAUX )
1853   2              {
1854   3                  as399xContinuousWrite(i, as399xPowerDownRegs3[reg3cnt++], 3);
1855   3              }
1856   2              else
1857   2              {
1858   3                  as399xSingleWrite(i, as399xPowerDownRegs[i]);
1859   3              }
1860   2          }
1861   1          udelay(300);        /* without delay pll locking might fail --> spurs in spectrum */
1862   1          as399xLockPLL();
1863   1          as399xSingleWrite(0, as399xPowerDownRegs[0]);
1864   1      
1865   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3898    ----
   CONSTANT SIZE    =    460    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     57     134
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
