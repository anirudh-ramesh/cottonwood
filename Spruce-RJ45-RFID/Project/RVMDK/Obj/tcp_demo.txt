; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\tcp_demo.o --depend=.\Obj\tcp_demo.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\tcp_demo.crf ..\..\Source\src\tcp_demo.c]
                          THUMB

                          AREA ||i.TCP_Cmd||, CODE, READONLY, ALIGN=2

                  TCP_Cmd PROC
;;;146    */
;;;147    void TCP_Cmd(struct tcp_demo_appstate *s)
000000  b530              PUSH     {r4,r5,lr}
;;;148    {
000002  b08d              SUB      sp,sp,#0x34
000004  4605              MOV      r5,r0
;;;149    	uint8_t Cmd[50],i;
;;;150    	memcpy(Cmd, uip_appdata, uip_len);//将接受到命令保存在cmd数组中
000006  4814              LDR      r0,|L1.88|
000008  8802              LDRH     r2,[r0,#0]  ; uip_len
00000a  4814              LDR      r0,|L1.92|
00000c  6801              LDR      r1,[r0,#0]  ; uip_appdata
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy
;;;151    	for(i=0;i<uip_len;i++)	//通过usart2 发送给RFID
000014  2400              MOVS     r4,#0
000016  e00d              B        |L1.52|
                  |L1.24|
;;;152     {
;;;153    	  USART_SendData(USART2, Cmd[i]);
000018  f81d1004          LDRB     r1,[sp,r4]
00001c  4810              LDR      r0,|L1.96|
00001e  f7fffffe          BL       USART_SendData
;;;154     	  while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET) { }
000022  bf00              NOP      
                  |L1.36|
000024  2180              MOVS     r1,#0x80
000026  480e              LDR      r0,|L1.96|
000028  f7fffffe          BL       USART_GetFlagStatus
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L1.36|
000030  1c60              ADDS     r0,r4,#1              ;151
000032  b2c4              UXTB     r4,r0                 ;151
                  |L1.52|
000034  4808              LDR      r0,|L1.88|
000036  8800              LDRH     r0,[r0,#0]            ;151  ; uip_len
000038  4284              CMP      r4,r0                 ;151
00003a  dbed              BLT      |L1.24|
;;;155      }
;;;156    			 
;;;157    	cmd_delay();	 //等待接受数据
00003c  f7fffffe          BL       cmd_delay
;;;158    	s->textptr =ReceiveNum;	//返回数据
000040  4808              LDR      r0,|L1.100|
000042  6068              STR      r0,[r5,#4]
;;;159    	s->textlen =F_count;	  //返回数据长度
000044  4808              LDR      r0,|L1.104|
000046  8800              LDRH     r0,[r0,#0]  ; F_count
000048  60a8              STR      r0,[r5,#8]
;;;160    	R_count=0; //清零 重新计算
00004a  2000              MOVS     r0,#0
00004c  4907              LDR      r1,|L1.108|
00004e  7008              STRB     r0,[r1,#0]
;;;161    	F_count=0;//清零 重新计算
000050  4905              LDR      r1,|L1.104|
000052  8008              STRH     r0,[r1,#0]
;;;162    
;;;163    /*	uint8_t cmd; 
;;;164    	if ((uip_len == 5) && (memcmp("cmd ", uip_appdata, 4) == 0))
;;;165    	{
;;;166    		cmd = ((uint8_t *)uip_appdata)[4]; 
;;;167    		switch(cmd)
;;;168    		{
;;;169    		   case '1': SendCmd1(); break;
;;;170    		   case '2': SendCmd2(); break;
;;;171    		   case '3': SendCmd3(); break;
;;;172    		   default : break;
;;;173    		          
;;;174    		}
;;;175    			s->textptr =ReceiveNum;
;;;176    			s->textlen =F_count;
;;;177    			R_count=0;
;;;178    			F_count=0;
;;;179    	}
;;;180    
;;;181    	else
;;;182    	{
;;;183    	  s->textptr = "Unknow Command!\r\n";
;;;184          s->textlen = strlen((char *)s->textptr);
;;;185    	}*/	
;;;186    	
;;;187    						   
;;;188    }
000054  b00d              ADD      sp,sp,#0x34
000056  bd30              POP      {r4,r5,pc}
;;;189    
                          ENDP

                  |L1.88|
                          DCD      uip_len
                  |L1.92|
                          DCD      uip_appdata
                  |L1.96|
                          DCD      0x40004400
                  |L1.100|
                          DCD      ReceiveNum
                  |L1.104|
                          DCD      F_count
                  |L1.108|
                          DCD      R_count

                          AREA ||i.aborted||, CODE, READONLY, ALIGN=1

                  aborted PROC
;;;87     */
;;;88     static void aborted(void)
000000  4770              BX       lr
;;;89     {
;;;90     	;
;;;91     }
;;;92     
                          ENDP


                          AREA ||i.acked||, CODE, READONLY, ALIGN=2

                  acked PROC
;;;243    */
;;;244    static void acked(void)
000000  490c              LDR      r1,|L3.52|
;;;245    {
;;;246    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  6809              LDR      r1,[r1,#0]  ; uip_conn
000004  f101001c          ADD      r0,r1,#0x1c
;;;247    
;;;248    	switch(s->state)
000008  7801              LDRB     r1,[r0,#0]
00000a  b121              CBZ      r1,|L3.22|
00000c  2901              CMP      r1,#1
00000e  d005              BEQ      |L3.28|
000010  2902              CMP      r1,#2
000012  d10c              BNE      |L3.46|
000014  e008              B        |L3.40|
                  |L3.22|
;;;249    	{
;;;250    		case STATE_CMD:		 /* 在命令状态 */
;;;251    			s->textlen = 0;
000016  2100              MOVS     r1,#0
000018  6081              STR      r1,[r0,#8]
;;;252    
;;;253    			/* 
;;;254    				只在命令状态打印调试信息 
;;;255    				避免发送测试时，影响通信速度		
;;;256    			*/
;;;257    		//printf("uip_acked!\r\n");
;;;258    			break;
00001a  e008              B        |L3.46|
                  |L3.28|
;;;259    
;;;260    		case STATE_TX_TEST:
;;;261    			s->textptr = test_data;	/* 连续发送 */
00001c  4906              LDR      r1,|L3.56|
00001e  6041              STR      r1,[r0,#4]
;;;262    			s->textlen = 1400;
000020  f44f61af          MOV      r1,#0x578
000024  6081              STR      r1,[r0,#8]
;;;263    			break;
000026  e002              B        |L3.46|
                  |L3.40|
;;;264    
;;;265    		case STATE_RX_TEST:
;;;266    			s->textlen = 0;
000028  2100              MOVS     r1,#0
00002a  6081              STR      r1,[r0,#8]
;;;267    			break;
00002c  bf00              NOP      
                  |L3.46|
00002e  bf00              NOP                            ;258
;;;268    	}
;;;269    }	 					
000030  4770              BX       lr
;;;270    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      uip_conn
                  |L3.56|
                          DCD      ||.bss||

                          AREA ||i.closed||, CODE, READONLY, ALIGN=1

                  closed PROC
;;;97     
;;;98     static void closed(void)
000000  4770              BX       lr
;;;99     {
;;;100    	;
;;;101    }
;;;102    
                          ENDP


                          AREA ||i.connected||, CODE, READONLY, ALIGN=2

                  connected PROC
;;;108    */
;;;109    static void connected(void)
000000  b510              PUSH     {r4,lr}
;;;110    {   unsigned char a[2]; 
;;;111    	/*
;;;112    		uip_conn结构体有一个"appstate"字段指向应用程序自定义的结构体。
;;;113    		声明一个s指针，是为了便于使用。
;;;114    
;;;115    		不需要再单独为每个uip_conn分配内存，这个已经在uip中分配好了。
;;;116    		在uip.c 中 的相关代码如下：
;;;117    			struct uip_conn *uip_conn;
;;;118    			struct uip_conn uip_conns[UIP_CONNS]; //UIP_CONNS缺省=10
;;;119    		定义了1个连接的数组，支持同时创建几个连接。
;;;120    		uip_conn是一个全局的指针，指向当前的tcp或udp连接。
;;;121    	*/
;;;122    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4807              LDR      r0,|L5.32|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;123    
;;;124    	//memset(test_data, 0x55, 2048);
;;;125    
;;;126    	s->state = STATE_CMD;
00000a  2000              MOVS     r0,#0
00000c  7020              STRB     r0,[r4,#0]
;;;127    	s->textlen = 0;
00000e  60a0              STR      r0,[r4,#8]
;;;128    
;;;129    	s->textptr = "Great! Connect success!\n";
000010  a004              ADR      r0,|L5.36|
000012  6060              STR      r0,[r4,#4]
;;;130    	s->textlen =strlen((char *)s->textptr);
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       strlen
00001a  60a0              STR      r0,[r4,#8]
;;;131    	
;;;132    	//senddata();
;;;133    	
;;;134    	//a[0]=0x0d; a[1]=0x0a;
;;;135    	//s->textptr = a;
;;;136    	//s->textlen = 2;
;;;137    
;;;138    }
00001c  bd10              POP      {r4,pc}
;;;139    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      uip_conn
                  |L5.36|
000024  47726561742120436f6e6e6563742073756363657373210a00        DCB      "Great! Connect success!\n",0
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.newdata||, CODE, READONLY, ALIGN=2

                  newdata PROC
;;;195    */
;;;196    static void newdata(void)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  481a              LDR      r0,|L6.108|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;199    	
;;;200    	if (s->state == STATE_CMD)
00000a  7820              LDRB     r0,[r4,#0]
00000c  b918              CBNZ     r0,|L6.22|
;;;201    	{
;;;202    	//	printf("uip_newdata!\r\n");
;;;203    		TCP_Cmd(s);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       TCP_Cmd
000014  e029              B        |L6.106|
                  |L6.22|
;;;204    	}
;;;205    	else if (s->state == STATE_TX_TEST)	/* 上传测试状态 */
000016  7820              LDRB     r0,[r4,#0]
000018  2801              CMP      r0,#1
00001a  d10c              BNE      |L6.54|
;;;206    	{
;;;207    		/* 在发送测试状态，如果收到PC机发送的任意数据，则退出测试状态 */
;;;208    		if ((uip_len == 1) && (((uint8_t *)uip_appdata)[0] == 'A'))
00001c  4814              LDR      r0,|L6.112|
00001e  8800              LDRH     r0,[r0,#0]  ; uip_len
000020  2801              CMP      r0,#1
000022  d104              BNE      |L6.46|
000024  4813              LDR      r0,|L6.116|
000026  6800              LDR      r0,[r0,#0]  ; uip_appdata
000028  7800              LDRB     r0,[r0,#0]
00002a  2841              CMP      r0,#0x41
00002c  d01d              BEQ      |L6.106|
                  |L6.46|
;;;209    		{
;;;210    			;/* 继续测试 */
;;;211    		}
;;;212    		else
;;;213    		{
;;;214    			/* 退到命令状态 */
;;;215    	   		s->state = STATE_CMD;
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
;;;216    			s->textlen = 0;
000032  60a0              STR      r0,[r4,#8]
000034  e019              B        |L6.106|
                  |L6.54|
;;;217    		}
;;;218    	}
;;;219    	else if (s->state == STATE_RX_TEST)	/* 下传测试状态 */
000036  7820              LDRB     r0,[r4,#0]
000038  2802              CMP      r0,#2
00003a  d116              BNE      |L6.106|
;;;220    	{				
;;;221    		if ((uip_len == 4) && (memcmp("stop", uip_appdata, 4) == 0))
00003c  480c              LDR      r0,|L6.112|
00003e  8800              LDRH     r0,[r0,#0]  ; uip_len
000040  2804              CMP      r0,#4
000042  d10a              BNE      |L6.90|
000044  2204              MOVS     r2,#4
000046  480b              LDR      r0,|L6.116|
000048  6801              LDR      r1,[r0,#0]  ; uip_appdata
00004a  a00b              ADR      r0,|L6.120|
00004c  f7fffffe          BL       memcmp
000050  b918              CBNZ     r0,|L6.90|
;;;222    		{
;;;223    			/* 退到命令状态 */
;;;224    	   		s->state = STATE_CMD;
000052  2000              MOVS     r0,#0
000054  7020              STRB     r0,[r4,#0]
;;;225    			s->textlen = 0;
000056  60a0              STR      r0,[r4,#8]
000058  e007              B        |L6.106|
                  |L6.90|
;;;226    		}
;;;227    		else
;;;228    		{
;;;229    			static int sLen;
;;;230    
;;;231    			sLen = uip_len;
00005a  4805              LDR      r0,|L6.112|
00005c  8800              LDRH     r0,[r0,#0]  ; uip_len
00005e  4908              LDR      r1,|L6.128|
000060  6008              STR      r0,[r1,#0]  ; sLen
;;;232    			s->textptr = (uint8_t *)&sLen;		/* 配合PC机测试软件，应答接收到的数据长度 */
000062  4608              MOV      r0,r1
000064  6060              STR      r0,[r4,#4]
;;;233    			s->textlen = 4;
000066  2004              MOVS     r0,#4
000068  60a0              STR      r0,[r4,#8]
                  |L6.106|
;;;234    		}
;;;235    	}
;;;236    }
00006a  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L6.108|
                          DCD      uip_conn
                  |L6.112|
                          DCD      uip_len
                  |L6.116|
                          DCD      uip_appdata
                  |L6.120|
000078  73746f7000        DCB      "stop",0
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L6.128|
                          DCD      ||.data||

                          AREA ||i.senddata||, CODE, READONLY, ALIGN=2

                  senddata PROC
;;;276    */
;;;277    static void senddata(void)
000000  b510              PUSH     {r4,lr}
;;;278    {
;;;279    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4806              LDR      r0,|L7.28|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;280    
;;;281    	if (s->textlen > 0)
00000a  68a0              LDR      r0,[r4,#8]
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L7.24|
;;;282    	{
;;;283    		/*
;;;284    			这个函数将向网络发送TCP数据包,
;;;285    				s->textptr : 发送的数据包缓冲区指针
;;;286    				s->textlen ：数据包的大小（单位字节）
;;;287    		*/
;;;288    		uip_send(s->textptr, s->textlen);
000010  e9d40101          LDRD     r0,r1,[r4,#4]
000014  f7fffffe          BL       uip_send
                  |L7.24|
;;;289    	}
;;;290    }
000018  bd10              POP      {r4,pc}
;;;291    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      uip_conn

                          AREA ||i.tcp_demo_appcall||, CODE, READONLY, ALIGN=2

                  tcp_demo_appcall PROC
;;;37     */
;;;38     void tcp_demo_appcall(void)
000000  b510              PUSH     {r4,lr}
;;;39     {
;;;40     	if (uip_aborted())
000002  4823              LDR      r0,|L8.144|
000004  7800              LDRB     r0,[r0,#0]  ; uip_flags
000006  f0100f20          TST      r0,#0x20
00000a  d001              BEQ      |L8.16|
;;;41     	{
;;;42     	//	printf("uip_aborted!\r\n");
;;;43     		aborted();
00000c  f7fffffe          BL       aborted
                  |L8.16|
;;;44     	}
;;;45     
;;;46     	if (uip_timedout())
000010  481f              LDR      r0,|L8.144|
000012  7800              LDRB     r0,[r0,#0]  ; uip_flags
000014  f0100f80          TST      r0,#0x80
000018  d001              BEQ      |L8.30|
;;;47     	{
;;;48     	//	printf("uip_timedout!\r\n");
;;;49     		timedout();
00001a  f7fffffe          BL       timedout
                  |L8.30|
;;;50     	}
;;;51     
;;;52     	if (uip_closed())
00001e  481c              LDR      r0,|L8.144|
000020  7800              LDRB     r0,[r0,#0]  ; uip_flags
000022  f0100f10          TST      r0,#0x10
000026  d001              BEQ      |L8.44|
;;;53     	{
;;;54     	//	printf("uip_closed!\r\n");
;;;55     		closed();
000028  f7fffffe          BL       closed
                  |L8.44|
;;;56     	}
;;;57     
;;;58     	if (uip_connected())
00002c  4818              LDR      r0,|L8.144|
00002e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000030  f0100f40          TST      r0,#0x40
000034  d001              BEQ      |L8.58|
;;;59     	{
;;;60     	//	printf("uip_connected!\r\n");
;;;61     		connected();
000036  f7fffffe          BL       connected
                  |L8.58|
;;;62     	}
;;;63     
;;;64     	if (uip_acked())
00003a  4815              LDR      r0,|L8.144|
00003c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00003e  f0100f01          TST      r0,#1
000042  d001              BEQ      |L8.72|
;;;65     	{
;;;66     		acked();
000044  f7fffffe          BL       acked
                  |L8.72|
;;;67     	}
;;;68     
;;;69     	/* 接收到一个新的TCP数据包，准备需要发送数据 */
;;;70     	if (uip_newdata())
000048  4811              LDR      r0,|L8.144|
00004a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00004c  f0100f02          TST      r0,#2
000050  d001              BEQ      |L8.86|
;;;71     	{
;;;72     		newdata();
000052  f7fffffe          BL       newdata
                  |L8.86|
;;;73     	}
;;;74     
;;;75     	/* 当需要重发、新数据到达、数据包送达、连接建立时，通知uip发送数据 */
;;;76     	if (uip_rexmit() ||	uip_newdata() || uip_acked() ||	uip_connected() || uip_poll())
000056  480e              LDR      r0,|L8.144|
000058  7800              LDRB     r0,[r0,#0]  ; uip_flags
00005a  f0100f04          TST      r0,#4
00005e  d113              BNE      |L8.136|
000060  480b              LDR      r0,|L8.144|
000062  7800              LDRB     r0,[r0,#0]  ; uip_flags
000064  f0100f02          TST      r0,#2
000068  d10e              BNE      |L8.136|
00006a  4809              LDR      r0,|L8.144|
00006c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00006e  f0100f01          TST      r0,#1
000072  d109              BNE      |L8.136|
000074  4806              LDR      r0,|L8.144|
000076  7800              LDRB     r0,[r0,#0]  ; uip_flags
000078  f0100f40          TST      r0,#0x40
00007c  d104              BNE      |L8.136|
00007e  4804              LDR      r0,|L8.144|
000080  7800              LDRB     r0,[r0,#0]  ; uip_flags
000082  f0100f08          TST      r0,#8
000086  d001              BEQ      |L8.140|
                  |L8.136|
;;;77     	{
;;;78     		senddata();
000088  f7fffffe          BL       senddata
                  |L8.140|
;;;79     	}
;;;80     }
00008c  bd10              POP      {r4,pc}
;;;81     
                          ENDP

00008e  0000              DCW      0x0000
                  |L8.144|
                          DCD      uip_flags

                          AREA ||i.timedout||, CODE, READONLY, ALIGN=1

                  timedout PROC
;;;92     
;;;93     static void timedout(void)
000000  4770              BX       lr
;;;94     {
;;;95     	;
;;;96     }
;;;97     
                          ENDP


                          AREA ||i.uip_log||, CODE, READONLY, ALIGN=2

                  uip_log PROC
;;;298    */
;;;299    void uip_log(char *m)
000000  b510              PUSH     {r4,lr}
;;;300    {
000002  4604              MOV      r4,r0
;;;301    	printf("uIP log message: %s\r\n", m);
000004  4621              MOV      r1,r4
000006  a002              ADR      r0,|L10.16|
000008  f7fffffe          BL       __2printf
;;;302    }
00000c  bd10              POP      {r4,pc}
;;;303    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
000010  754950206c6f67206d6573736167653a2025730d0a00        DCB      "uIP log message: %s\r\n",0
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  test_data
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  sLen
                          DCD      0x00000000
