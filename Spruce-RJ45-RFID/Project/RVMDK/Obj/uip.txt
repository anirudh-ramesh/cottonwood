; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\uip.o --depend=.\Obj\uip.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\uip.crf ..\..\Libraries\uIP-1.0\uip\uip.c]
                          THUMB

                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;279    static u16_t
;;;280    chksum(u16_t sum, const u8_t *data, u16_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;281    {
;;;282      u16_t t;
;;;283      const u8_t *dataptr;
;;;284      const u8_t *last_byte;
;;;285    
;;;286      dataptr = data;
000002  460c              MOV      r4,r1
;;;287      last_byte = data + len - 1;
000004  188e              ADDS     r6,r1,r2
000006  1e75              SUBS     r5,r6,#1
;;;288    
;;;289      while(dataptr < last_byte) {	/* At least two more bytes */
000008  e00b              B        |L1.34|
                  |L1.10|
;;;290        t = (dataptr[0] << 8) + dataptr[1];
00000a  7866              LDRB     r6,[r4,#1]
00000c  7827              LDRB     r7,[r4,#0]
00000e  eb062607          ADD      r6,r6,r7,LSL #8
000012  b2b3              UXTH     r3,r6
;;;291        sum += t;
000014  18c6              ADDS     r6,r0,r3
000016  b2b0              UXTH     r0,r6
;;;292        if(sum < t) {
000018  4298              CMP      r0,r3
00001a  da01              BGE      |L1.32|
;;;293          sum++;		/* carry */
00001c  1c46              ADDS     r6,r0,#1
00001e  b2b0              UXTH     r0,r6
                  |L1.32|
;;;294        }
;;;295        dataptr += 2;
000020  1ca4              ADDS     r4,r4,#2
                  |L1.34|
000022  42ac              CMP      r4,r5                 ;289
000024  d3f1              BCC      |L1.10|
;;;296      }
;;;297    
;;;298      if(dataptr == last_byte) {
000026  42ac              CMP      r4,r5
000028  d10a              BNE      |L1.64|
;;;299        t = (dataptr[0] << 8) + 0;
00002a  7826              LDRB     r6,[r4,#0]
00002c  2700              MOVS     r7,#0
00002e  eb072606          ADD      r6,r7,r6,LSL #8
000032  b2b3              UXTH     r3,r6
;;;300        sum += t;
000034  18c6              ADDS     r6,r0,r3
000036  b2b0              UXTH     r0,r6
;;;301        if(sum < t) {
000038  4298              CMP      r0,r3
00003a  da01              BGE      |L1.64|
;;;302          sum++;		/* carry */
00003c  1c46              ADDS     r6,r0,#1
00003e  b2b0              UXTH     r0,r6
                  |L1.64|
;;;303        }
;;;304      }
;;;305    
;;;306      /* Return sum in host byte order. */
;;;307      return sum;
;;;308    }
000040  bdf0              POP      {r4-r7,pc}
;;;309    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;1882   u16_t
;;;1883   htons(u16_t val)
000000  4601              MOV      r1,r0
;;;1884   {
;;;1885     return HTONS(val);
000002  0208              LSLS     r0,r1,#8
000004  ea402021          ORR      r0,r0,r1,ASR #8
000008  b280              UXTH     r0,r0
;;;1886   }
00000a  4770              BX       lr
;;;1887   /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_add32||, CODE, READONLY, ALIGN=2

                  uip_add32 PROC
;;;248    void
;;;249    uip_add32(u8_t *op32, u16_t op16)
000000  78c2              LDRB     r2,[r0,#3]
;;;250    {
;;;251      uip_acc32[3] = op32[3] + (op16 & 0xff);
000002  440a              ADD      r2,r2,r1
000004  4b19              LDR      r3,|L3.108|
000006  70da              STRB     r2,[r3,#3]
;;;252      uip_acc32[2] = op32[2] + (op16 >> 8);
000008  7882              LDRB     r2,[r0,#2]
00000a  eb022221          ADD      r2,r2,r1,ASR #8
00000e  709a              STRB     r2,[r3,#2]
;;;253      uip_acc32[1] = op32[1];
000010  7842              LDRB     r2,[r0,#1]
000012  705a              STRB     r2,[r3,#1]
;;;254      uip_acc32[0] = op32[0];
000014  7802              LDRB     r2,[r0,#0]
000016  701a              STRB     r2,[r3,#0]
;;;255    
;;;256      if(uip_acc32[2] < (op16 >> 8)) {
000018  461a              MOV      r2,r3
00001a  7892              LDRB     r2,[r2,#2]  ; uip_acc32
00001c  ebb22f21          CMP      r2,r1,ASR #8
000020  da0a              BGE      |L3.56|
;;;257        ++uip_acc32[1];
000022  461a              MOV      r2,r3
000024  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000026  1c52              ADDS     r2,r2,#1
000028  705a              STRB     r2,[r3,#1]
;;;258        if(uip_acc32[1] == 0) {
00002a  461a              MOV      r2,r3
00002c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00002e  b91a              CBNZ     r2,|L3.56|
;;;259          ++uip_acc32[0];
000030  461a              MOV      r2,r3
000032  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000034  1c52              ADDS     r2,r2,#1
000036  701a              STRB     r2,[r3,#0]
                  |L3.56|
;;;260        }
;;;261      }
;;;262    
;;;263    
;;;264      if(uip_acc32[3] < (op16 & 0xff)) {
000038  4a0c              LDR      r2,|L3.108|
00003a  78d2              LDRB     r2,[r2,#3]  ; uip_acc32
00003c  b2cb              UXTB     r3,r1
00003e  429a              CMP      r2,r3
000040  da12              BGE      |L3.104|
;;;265        ++uip_acc32[2];
000042  4a0a              LDR      r2,|L3.108|
000044  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000046  1c52              ADDS     r2,r2,#1
000048  4b08              LDR      r3,|L3.108|
00004a  709a              STRB     r2,[r3,#2]
;;;266        if(uip_acc32[2] == 0) {
00004c  461a              MOV      r2,r3
00004e  7892              LDRB     r2,[r2,#2]  ; uip_acc32
000050  b952              CBNZ     r2,|L3.104|
;;;267          ++uip_acc32[1];
000052  461a              MOV      r2,r3
000054  7852              LDRB     r2,[r2,#1]  ; uip_acc32
000056  1c52              ADDS     r2,r2,#1
000058  705a              STRB     r2,[r3,#1]
;;;268          if(uip_acc32[1] == 0) {
00005a  461a              MOV      r2,r3
00005c  7852              LDRB     r2,[r2,#1]  ; uip_acc32
00005e  b91a              CBNZ     r2,|L3.104|
;;;269    	++uip_acc32[0];
000060  461a              MOV      r2,r3
000062  7812              LDRB     r2,[r2,#0]  ; uip_acc32
000064  1c52              ADDS     r2,r2,#1
000066  701a              STRB     r2,[r3,#0]
                  |L3.104|
;;;270          }
;;;271        }
;;;272      }
;;;273    }
000068  4770              BX       lr
;;;274    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      uip_acc32

                          AREA ||i.uip_add_rcv_nxt||, CODE, READONLY, ALIGN=2

                  uip_add_rcv_nxt PROC
;;;671    static void
;;;672    uip_add_rcv_nxt(u16_t n)
000000  b510              PUSH     {r4,lr}
;;;673    {
000002  4604              MOV      r4,r0
;;;674      uip_add32(uip_conn->rcv_nxt, n);
000004  4621              MOV      r1,r4
000006  480d              LDR      r0,|L4.60|
000008  6800              LDR      r0,[r0,#0]  ; uip_conn
00000a  3008              ADDS     r0,r0,#8
00000c  f7fffffe          BL       uip_add32
;;;675      uip_conn->rcv_nxt[0] = uip_acc32[0];
000010  480b              LDR      r0,|L4.64|
000012  7800              LDRB     r0,[r0,#0]  ; uip_acc32
000014  4909              LDR      r1,|L4.60|
000016  6809              LDR      r1,[r1,#0]  ; uip_conn
000018  7208              STRB     r0,[r1,#8]
;;;676      uip_conn->rcv_nxt[1] = uip_acc32[1];
00001a  4809              LDR      r0,|L4.64|
00001c  7841              LDRB     r1,[r0,#1]  ; uip_acc32
00001e  4807              LDR      r0,|L4.60|
000020  6800              LDR      r0,[r0,#0]  ; uip_conn
000022  7241              STRB     r1,[r0,#9]
;;;677      uip_conn->rcv_nxt[2] = uip_acc32[2];
000024  4806              LDR      r0,|L4.64|
000026  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000028  4804              LDR      r0,|L4.60|
00002a  6800              LDR      r0,[r0,#0]  ; uip_conn
00002c  7281              STRB     r1,[r0,#0xa]
;;;678      uip_conn->rcv_nxt[3] = uip_acc32[3];
00002e  4804              LDR      r0,|L4.64|
000030  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
000032  4802              LDR      r0,|L4.60|
000034  6800              LDR      r0,[r0,#0]  ; uip_conn
000036  72c1              STRB     r1,[r0,#0xb]
;;;679    }
000038  bd10              POP      {r4,pc}
;;;680    /*---------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      uip_conn
                  |L4.64|
                          DCD      uip_acc32

                          AREA ||i.uip_chksum||, CODE, READONLY, ALIGN=1

                  uip_chksum PROC
;;;310    u16_t
;;;311    uip_chksum(u16_t *data, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;313      return htons(chksum(0, (u8_t *)data, len));
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       chksum
000010  4606              MOV      r6,r0
000012  f7fffffe          BL       htons
;;;314    }
000016  bd70              POP      {r4-r6,pc}
;;;315    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_connect||, CODE, READONLY, ALIGN=2

                  uip_connect PROC
;;;406    struct uip_conn *
;;;407    uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
000000  b530              PUSH     {r4,r5,lr}
;;;408    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;409      register struct uip_conn *conn, *cconn;
;;;410    
;;;411      /* Find an unused local port. */
;;;412     again:
000006  bf00              NOP      
                  |L6.8|
;;;413      ++lastport;
000008  4843              LDR      r0,|L6.280|
00000a  8800              LDRH     r0,[r0,#0]  ; lastport
00000c  1c40              ADDS     r0,r0,#1
00000e  4942              LDR      r1,|L6.280|
000010  8008              STRH     r0,[r1,#0]
;;;414    
;;;415      if(lastport >= 32000) {
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]  ; lastport
000016  f5b04ffa          CMP      r0,#0x7d00
00001a  db02              BLT      |L6.34|
;;;416        lastport = 4096;
00001c  f44f5080          MOV      r0,#0x1000
000020  8008              STRH     r0,[r1,#0]
                  |L6.34|
;;;417      }
;;;418    
;;;419      /* Check if this port is already in use, and if so try to find
;;;420         another one. */
;;;421      for(c = 0; c < UIP_CONNS; ++c) {
000022  2000              MOVS     r0,#0
000024  493c              LDR      r1,|L6.280|
000026  1d89              ADDS     r1,r1,#6
000028  7008              STRB     r0,[r1,#0]
00002a  e018              B        |L6.94|
                  |L6.44|
;;;422        conn = &uip_conns[c];
00002c  483a              LDR      r0,|L6.280|
00002e  1d80              ADDS     r0,r0,#6
000030  7800              LDRB     r0,[r0,#0]  ; c
000032  eb000080          ADD      r0,r0,r0,LSL #2
000036  4939              LDR      r1,|L6.284|
000038  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;423        if(conn->tcpstateflags != UIP_CLOSED &&
00003c  7e60              LDRB     r0,[r4,#0x19]
00003e  b138              CBZ      r0,|L6.80|
;;;424           conn->lport == htons(lastport)) {
000040  4835              LDR      r0,|L6.280|
000042  8800              LDRH     r0,[r0,#0]  ; lastport
000044  f7fffffe          BL       htons
000048  88a1              LDRH     r1,[r4,#4]
00004a  4288              CMP      r0,r1
00004c  d100              BNE      |L6.80|
;;;425          goto again;
00004e  e7db              B        |L6.8|
                  |L6.80|
000050  4831              LDR      r0,|L6.280|
000052  1d80              ADDS     r0,r0,#6              ;421
000054  7800              LDRB     r0,[r0,#0]            ;421  ; c
000056  1c40              ADDS     r0,r0,#1              ;421
000058  492f              LDR      r1,|L6.280|
00005a  1d89              ADDS     r1,r1,#6              ;421
00005c  7008              STRB     r0,[r1,#0]            ;421
                  |L6.94|
00005e  482e              LDR      r0,|L6.280|
000060  1d80              ADDS     r0,r0,#6              ;421
000062  7800              LDRB     r0,[r0,#0]            ;421  ; c
000064  2828              CMP      r0,#0x28              ;421
000066  dbe1              BLT      |L6.44|
;;;426        }
;;;427      }
;;;428    
;;;429      conn = 0;
000068  2400              MOVS     r4,#0
;;;430      for(c = 0; c < UIP_CONNS; ++c) {
00006a  2000              MOVS     r0,#0
00006c  492a              LDR      r1,|L6.280|
00006e  1d89              ADDS     r1,r1,#6
000070  7008              STRB     r0,[r1,#0]
000072  e01b              B        |L6.172|
                  |L6.116|
;;;431        cconn = &uip_conns[c];
000074  4828              LDR      r0,|L6.280|
000076  1d80              ADDS     r0,r0,#6
000078  7800              LDRB     r0,[r0,#0]  ; c
00007a  eb000080          ADD      r0,r0,r0,LSL #2
00007e  4927              LDR      r1,|L6.284|
000080  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;432        if(cconn->tcpstateflags == UIP_CLOSED) {
000084  7e68              LDRB     r0,[r5,#0x19]
000086  b908              CBNZ     r0,|L6.140|
;;;433          conn = cconn;
000088  462c              MOV      r4,r5
;;;434          break;
00008a  e014              B        |L6.182|
                  |L6.140|
;;;435        }
;;;436        if(cconn->tcpstateflags == UIP_TIME_WAIT) {
00008c  7e68              LDRB     r0,[r5,#0x19]
00008e  2807              CMP      r0,#7
000090  d105              BNE      |L6.158|
;;;437          if(conn == 0 ||
000092  b11c              CBZ      r4,|L6.156|
;;;438    	 cconn->timer > conn->timer) {
000094  7ea8              LDRB     r0,[r5,#0x1a]
000096  7ea1              LDRB     r1,[r4,#0x1a]
000098  4288              CMP      r0,r1
00009a  dd00              BLE      |L6.158|
                  |L6.156|
;;;439    	conn = cconn;
00009c  462c              MOV      r4,r5
                  |L6.158|
00009e  481e              LDR      r0,|L6.280|
0000a0  1d80              ADDS     r0,r0,#6              ;430
0000a2  7800              LDRB     r0,[r0,#0]            ;430  ; c
0000a4  1c40              ADDS     r0,r0,#1              ;430
0000a6  491c              LDR      r1,|L6.280|
0000a8  1d89              ADDS     r1,r1,#6              ;430
0000aa  7008              STRB     r0,[r1,#0]            ;430
                  |L6.172|
0000ac  481a              LDR      r0,|L6.280|
0000ae  1d80              ADDS     r0,r0,#6              ;430
0000b0  7800              LDRB     r0,[r0,#0]            ;430  ; c
0000b2  2828              CMP      r0,#0x28              ;430
0000b4  dbde              BLT      |L6.116|
                  |L6.182|
0000b6  bf00              NOP                            ;434
;;;440          }
;;;441        }
;;;442      }
;;;443    
;;;444      if(conn == 0) {
0000b8  b90c              CBNZ     r4,|L6.190|
;;;445        return 0;
0000ba  2000              MOVS     r0,#0
                  |L6.188|
;;;446      }
;;;447    
;;;448      conn->tcpstateflags = UIP_SYN_SENT;
;;;449    
;;;450      conn->snd_nxt[0] = iss[0];
;;;451      conn->snd_nxt[1] = iss[1];
;;;452      conn->snd_nxt[2] = iss[2];
;;;453      conn->snd_nxt[3] = iss[3];
;;;454    
;;;455      conn->initialmss = conn->mss = UIP_TCP_MSS;
;;;456    
;;;457      conn->len = 1;   /* TCP length of the SYN is one. */
;;;458      conn->nrtx = 0;
;;;459      conn->timer = 1; /* Send the SYN next time around. */
;;;460      conn->rto = UIP_RTO;
;;;461      conn->sa = 0;
;;;462      conn->sv = 16;   /* Initial value of the RTT variance. */
;;;463      conn->lport = htons(lastport);
;;;464      conn->rport = rport;
;;;465      uip_ipaddr_copy(&conn->ripaddr, ripaddr);
;;;466    
;;;467      return conn;
;;;468    }
0000bc  bd30              POP      {r4,r5,pc}
                  |L6.190|
0000be  2002              MOVS     r0,#2                 ;448
0000c0  7660              STRB     r0,[r4,#0x19]         ;448
0000c2  4815              LDR      r0,|L6.280|
0000c4  1f00              SUBS     r0,r0,#4              ;450
0000c6  7800              LDRB     r0,[r0,#0]            ;450  ; iss
0000c8  7320              STRB     r0,[r4,#0xc]          ;450
0000ca  4813              LDR      r0,|L6.280|
0000cc  1f00              SUBS     r0,r0,#4              ;451
0000ce  7841              LDRB     r1,[r0,#1]            ;451  ; iss
0000d0  7361              STRB     r1,[r4,#0xd]          ;451
0000d2  7881              LDRB     r1,[r0,#2]            ;452  ; iss
0000d4  73a1              STRB     r1,[r4,#0xe]          ;452
0000d6  78c1              LDRB     r1,[r0,#3]            ;453  ; iss
0000d8  73e1              STRB     r1,[r4,#0xf]          ;453
0000da  f64070ca          MOV      r0,#0xfca             ;455
0000de  8260              STRH     r0,[r4,#0x12]         ;455
0000e0  82a0              STRH     r0,[r4,#0x14]         ;455
0000e2  2001              MOVS     r0,#1                 ;457
0000e4  8220              STRH     r0,[r4,#0x10]         ;457
0000e6  2000              MOVS     r0,#0                 ;458
0000e8  76e0              STRB     r0,[r4,#0x1b]         ;458
0000ea  2001              MOVS     r0,#1                 ;459
0000ec  76a0              STRB     r0,[r4,#0x1a]         ;459
0000ee  2003              MOVS     r0,#3                 ;460
0000f0  7620              STRB     r0,[r4,#0x18]         ;460
0000f2  2000              MOVS     r0,#0                 ;461
0000f4  75a0              STRB     r0,[r4,#0x16]         ;461
0000f6  2010              MOVS     r0,#0x10              ;462
0000f8  75e0              STRB     r0,[r4,#0x17]         ;462
0000fa  4807              LDR      r0,|L6.280|
0000fc  8800              LDRH     r0,[r0,#0]            ;463  ; lastport
0000fe  f7fffffe          BL       htons
000102  80a0              STRH     r0,[r4,#4]            ;463
000104  80e3              STRH     r3,[r4,#6]            ;464
000106  bf00              NOP                            ;465
000108  8810              LDRH     r0,[r2,#0]            ;465
00010a  8020              STRH     r0,[r4,#0]            ;465
00010c  8850              LDRH     r0,[r2,#2]            ;465
00010e  8060              STRH     r0,[r4,#2]            ;465
000110  bf00              NOP                            ;465
000112  4620              MOV      r0,r4                 ;467
000114  e7d2              B        |L6.188|
;;;469    #endif /* UIP_ACTIVE_OPEN */
                          ENDP

000116  0000              DCW      0x0000
                  |L6.280|
                          DCD      ||.data||+0x2e
                  |L6.284|
                          DCD      uip_conns

                          AREA ||i.uip_init||, CODE, READONLY, ALIGN=2

                  uip_init PROC
;;;378    void
;;;379    uip_init(void)
000000  2000              MOVS     r0,#0
;;;380    {
;;;381      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4917              LDR      r1,|L7.96|
000004  7008              STRB     r0,[r1,#0]
000006  e00a              B        |L7.30|
                  |L7.8|
;;;382        uip_listenports[c] = 0;
000008  2000              MOVS     r0,#0
00000a  4916              LDR      r1,|L7.100|
00000c  4a14              LDR      r2,|L7.96|
00000e  7812              LDRB     r2,[r2,#0]  ; c
000010  f8210012          STRH     r0,[r1,r2,LSL #1]
000014  4812              LDR      r0,|L7.96|
000016  7800              LDRB     r0,[r0,#0]            ;381  ; c
000018  1c40              ADDS     r0,r0,#1              ;381
00001a  4911              LDR      r1,|L7.96|
00001c  7008              STRB     r0,[r1,#0]            ;381
                  |L7.30|
00001e  4810              LDR      r0,|L7.96|
000020  7800              LDRB     r0,[r0,#0]            ;381  ; c
000022  2828              CMP      r0,#0x28              ;381
000024  dbf0              BLT      |L7.8|
;;;383      }
;;;384      for(c = 0; c < UIP_CONNS; ++c) {
000026  2000              MOVS     r0,#0
000028  490d              LDR      r1,|L7.96|
00002a  7008              STRB     r0,[r1,#0]
00002c  e00d              B        |L7.74|
                  |L7.46|
;;;385        uip_conns[c].tcpstateflags = UIP_CLOSED;
00002e  2000              MOVS     r0,#0
000030  490b              LDR      r1,|L7.96|
000032  7809              LDRB     r1,[r1,#0]  ; c
000034  eb010181          ADD      r1,r1,r1,LSL #2
000038  4a0b              LDR      r2,|L7.104|
00003a  eb0201c1          ADD      r1,r2,r1,LSL #3
00003e  7648              STRB     r0,[r1,#0x19]
000040  4807              LDR      r0,|L7.96|
000042  7800              LDRB     r0,[r0,#0]            ;384  ; c
000044  1c40              ADDS     r0,r0,#1              ;384
000046  4906              LDR      r1,|L7.96|
000048  7008              STRB     r0,[r1,#0]            ;384
                  |L7.74|
00004a  4805              LDR      r0,|L7.96|
00004c  7800              LDRB     r0,[r0,#0]            ;384  ; c
00004e  2828              CMP      r0,#0x28              ;384
000050  dbed              BLT      |L7.46|
;;;386      }
;;;387    #if UIP_ACTIVE_OPEN
;;;388      lastport = 1024;
000052  f44f6080          MOV      r0,#0x400
000056  4902              LDR      r1,|L7.96|
000058  1f89              SUBS     r1,r1,#6
00005a  8008              STRH     r0,[r1,#0]
;;;389    #endif /* UIP_ACTIVE_OPEN */
;;;390    
;;;391    #if UIP_UDP
;;;392      for(c = 0; c < UIP_UDP_CONNS; ++c) {
;;;393        uip_udp_conns[c].lport = 0;
;;;394      }
;;;395    #endif /* UIP_UDP */
;;;396    
;;;397    
;;;398      /* IPv4 initialization. */
;;;399    #if UIP_FIXEDADDR == 0
;;;400      /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
;;;401    #endif /* UIP_FIXEDADDR */
;;;402    
;;;403    }
00005c  4770              BX       lr
;;;404    /*---------------------------------------------------------------------------*/
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      ||.data||+0x34
                  |L7.100|
                          DCD      uip_listenports
                  |L7.104|
                          DCD      uip_conns

                          AREA ||i.uip_ipchksum||, CODE, READONLY, ALIGN=2

                  uip_ipchksum PROC
;;;317    u16_t
;;;318    uip_ipchksum(void)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320      u16_t sum;
;;;321    
;;;322      sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
000002  2214              MOVS     r2,#0x14
000004  4906              LDR      r1,|L8.32|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
00000c  4604              MOV      r4,r0
;;;323      DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
;;;324      return (sum == 0) ? 0xffff : htons(sum);
00000e  b914              CBNZ     r4,|L8.22|
000010  f64f70ff          MOV      r0,#0xffff
000014  e002              B        |L8.28|
                  |L8.22|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       htons
                  |L8.28|
00001c  b280              UXTH     r0,r0
;;;325    }
00001e  bd10              POP      {r4,pc}
;;;326    #endif
                          ENDP

                  |L8.32|
                          DCD      uip_buf+0xe

                          AREA ||i.uip_listen||, CODE, READONLY, ALIGN=2

                  uip_listen PROC
;;;528    void
;;;529    uip_listen(u16_t port)
000000  2100              MOVS     r1,#0
;;;530    {
;;;531      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0c              LDR      r2,|L9.52|
000004  7011              STRB     r1,[r2,#0]
000006  e010              B        |L9.42|
                  |L9.8|
;;;532        if(uip_listenports[c] == 0) {
000008  490b              LDR      r1,|L9.56|
00000a  4a0a              LDR      r2,|L9.52|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  b929              CBNZ     r1,|L9.32|
;;;533          uip_listenports[c] = port;
000014  4908              LDR      r1,|L9.56|
000016  4a07              LDR      r2,|L9.52|
000018  7812              LDRB     r2,[r2,#0]  ; c
00001a  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L9.30|
;;;534          return;
;;;535        }
;;;536      }
;;;537    }
00001e  4770              BX       lr
                  |L9.32|
000020  4904              LDR      r1,|L9.52|
000022  7809              LDRB     r1,[r1,#0]            ;531  ; c
000024  1c49              ADDS     r1,r1,#1              ;531
000026  4a03              LDR      r2,|L9.52|
000028  7011              STRB     r1,[r2,#0]            ;531
                  |L9.42|
00002a  4902              LDR      r1,|L9.52|
00002c  7809              LDRB     r1,[r1,#0]            ;531  ; c
00002e  2928              CMP      r1,#0x28              ;531
000030  dbea              BLT      |L9.8|
000032  e7f4              B        |L9.30|
;;;538    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L9.52|
                          DCD      ||.data||+0x34
                  |L9.56|
                          DCD      uip_listenports

                          AREA ||i.uip_process||, CODE, READONLY, ALIGN=2

                  uip_process PROC
;;;681    void
;;;682    uip_process(u8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;683    {
000002  4605              MOV      r5,r0
;;;684      register struct uip_conn *uip_connr = uip_conn;
000004  48fe              LDR      r0,|L10.1024|
000006  6804              LDR      r4,[r0,#0]  ; uip_conn
;;;685    
;;;686    #if UIP_UDP
;;;687      if(flag == UIP_UDP_SEND_CONN) {
;;;688        goto udp_send;
;;;689      }
;;;690    #endif /* UIP_UDP */
;;;691    
;;;692      uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
000008  48fe              LDR      r0,|L10.1028|
00000a  49ff              LDR      r1,|L10.1032|
00000c  6008              STR      r0,[r1,#0]  ; uip_appdata
00000e  49ff              LDR      r1,|L10.1036|
000010  6008              STR      r0,[r1,#0]  ; uip_sappdata
;;;693    
;;;694      /* Check if we were invoked because of a poll request for a
;;;695         particular connection. */
;;;696      if(flag == UIP_POLL_REQUEST) {
000012  2d03              CMP      r5,#3
000014  d10e              BNE      |L10.52|
;;;697        if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
000016  7e60              LDRB     r0,[r4,#0x19]
000018  f000000f          AND      r0,r0,#0xf
00001c  2803              CMP      r0,#3
00001e  d107              BNE      |L10.48|
;;;698           !uip_outstanding(uip_connr)) {
000020  8a20              LDRH     r0,[r4,#0x10]
000022  b928              CBNZ     r0,|L10.48|
;;;699    	uip_flags = UIP_POLL;
000024  2008              MOVS     r0,#8
000026  49fa              LDR      r1,|L10.1040|
000028  7008              STRB     r0,[r1,#0]
;;;700    	UIP_APPCALL();
00002a  f7fffffe          BL       tcp_server_appcall
                  |L10.46|
;;;701    	goto appsend;
00002e  e3fd              B        |L10.2092|
                  |L10.48|
;;;702        }
;;;703        goto drop;
000030  f000bfbb          B.W      |L10.4010|
                  |L10.52|
;;;704    
;;;705        /* Check if we were invoked because of the perodic timer fireing. */
;;;706      } else if(flag == UIP_TIMER) {
000034  2d02              CMP      r5,#2
000036  d171              BNE      |L10.284|
;;;707    #if UIP_REASSEMBLY
;;;708        if(uip_reasstmr != 0) {
;;;709          --uip_reasstmr;
;;;710        }
;;;711    #endif /* UIP_REASSEMBLY */
;;;712        /* Increase the initial sequence number. */
;;;713        if(++iss[3] == 0) {
000038  48f6              LDR      r0,|L10.1044|
00003a  78c0              LDRB     r0,[r0,#3]  ; iss
00003c  1c40              ADDS     r0,r0,#1
00003e  f01000ff          ANDS     r0,r0,#0xff
000042  49f4              LDR      r1,|L10.1044|
000044  70c8              STRB     r0,[r1,#3]
000046  d111              BNE      |L10.108|
;;;714          if(++iss[2] == 0) {
000048  4608              MOV      r0,r1
00004a  7880              LDRB     r0,[r0,#2]  ; iss
00004c  1c40              ADDS     r0,r0,#1
00004e  f01000ff          ANDS     r0,r0,#0xff
000052  7088              STRB     r0,[r1,#2]
000054  d10a              BNE      |L10.108|
;;;715    	if(++iss[1] == 0) {
000056  4608              MOV      r0,r1
000058  7840              LDRB     r0,[r0,#1]  ; iss
00005a  1c40              ADDS     r0,r0,#1
00005c  f01000ff          ANDS     r0,r0,#0xff
000060  7048              STRB     r0,[r1,#1]
000062  d103              BNE      |L10.108|
;;;716    	  ++iss[0];
000064  4608              MOV      r0,r1
000066  7800              LDRB     r0,[r0,#0]  ; iss
000068  1c40              ADDS     r0,r0,#1
00006a  7008              STRB     r0,[r1,#0]
                  |L10.108|
;;;717    	}
;;;718          }
;;;719        }
;;;720    
;;;721        /* Reset the length variables. */
;;;722        uip_len = 0;
00006c  2000              MOVS     r0,#0
00006e  49ea              LDR      r1,|L10.1048|
000070  8008              STRH     r0,[r1,#0]
;;;723        uip_slen = 0;
000072  49ea              LDR      r1,|L10.1052|
000074  8008              STRH     r0,[r1,#0]
;;;724    
;;;725        /* Check if the connection is in a state in which we simply wait
;;;726           for the connection to time out. If so, we increase the
;;;727           connection's timer and remove the connection if it times
;;;728           out. */
;;;729        if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
000076  7e60              LDRB     r0,[r4,#0x19]
000078  2807              CMP      r0,#7
00007a  d002              BEQ      |L10.130|
;;;730           uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
00007c  7e60              LDRB     r0,[r4,#0x19]
00007e  2805              CMP      r0,#5
000080  d108              BNE      |L10.148|
                  |L10.130|
;;;731          ++(uip_connr->timer);
000082  7ea0              LDRB     r0,[r4,#0x1a]
000084  1c40              ADDS     r0,r0,#1
000086  76a0              STRB     r0,[r4,#0x1a]
;;;732          if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
000088  7ea0              LDRB     r0,[r4,#0x1a]
00008a  2878              CMP      r0,#0x78
00008c  d161              BNE      |L10.338|
;;;733    	uip_connr->tcpstateflags = UIP_CLOSED;
00008e  2000              MOVS     r0,#0
000090  7660              STRB     r0,[r4,#0x19]
000092  e05e              B        |L10.338|
                  |L10.148|
;;;734          }
;;;735        } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
000094  7e60              LDRB     r0,[r4,#0x19]
000096  2800              CMP      r0,#0
000098  d05b              BEQ      |L10.338|
;;;736          /* If the connection has outstanding data, we increase the
;;;737    	 connection's timer and see if it has reached the RTO value
;;;738    	 in which case we retransmit. */
;;;739          if(uip_outstanding(uip_connr)) {
00009a  8a20              LDRH     r0,[r4,#0x10]
00009c  2800              CMP      r0,#0
00009e  d04d              BEQ      |L10.316|
;;;740    	if(uip_connr->timer-- == 0) {
0000a0  7ea0              LDRB     r0,[r4,#0x1a]
0000a2  1e41              SUBS     r1,r0,#1
0000a4  76a1              STRB     r1,[r4,#0x1a]
0000a6  2800              CMP      r0,#0
0000a8  d153              BNE      |L10.338|
;;;741    	  if(uip_connr->nrtx == UIP_MAXRTX ||
0000aa  7ee0              LDRB     r0,[r4,#0x1b]
0000ac  2808              CMP      r0,#8
0000ae  d008              BEQ      |L10.194|
;;;742    	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
0000b0  7e60              LDRB     r0,[r4,#0x19]
0000b2  2802              CMP      r0,#2
0000b4  d002              BEQ      |L10.188|
;;;743    	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
0000b6  7e60              LDRB     r0,[r4,#0x19]
0000b8  2801              CMP      r0,#1
0000ba  d110              BNE      |L10.222|
                  |L10.188|
;;;744    	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
0000bc  7ee0              LDRB     r0,[r4,#0x1b]
0000be  2805              CMP      r0,#5
0000c0  d10d              BNE      |L10.222|
                  |L10.194|
;;;745    	    uip_connr->tcpstateflags = UIP_CLOSED;
0000c2  2000              MOVS     r0,#0
0000c4  7660              STRB     r0,[r4,#0x19]
;;;746    
;;;747    	    /* We call UIP_APPCALL() with uip_flags set to
;;;748    	       UIP_TIMEDOUT to inform the application that the
;;;749    	       connection has timed out. */
;;;750    	    uip_flags = UIP_TIMEDOUT;
0000c6  2080              MOVS     r0,#0x80
0000c8  49d1              LDR      r1,|L10.1040|
0000ca  7008              STRB     r0,[r1,#0]
;;;751    	    UIP_APPCALL();
0000cc  f7fffffe          BL       tcp_server_appcall
;;;752    
;;;753    	    /* We also send a reset packet to the remote host. */
;;;754    	    BUF->flags = TCP_RST | TCP_ACK;
0000d0  2114              MOVS     r1,#0x14
0000d2  48cc              LDR      r0,|L10.1028|
0000d4  3836              SUBS     r0,r0,#0x36
0000d6  f880102f          STRB     r1,[r0,#0x2f]
;;;755    	    goto tcp_send_nodata;
0000da  f000bed3          B.W      |L10.3716|
                  |L10.222|
;;;756    	  }
;;;757    
;;;758    	  /* Exponential backoff. */
;;;759    	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
0000de  7ee0              LDRB     r0,[r4,#0x1b]
0000e0  2804              CMP      r0,#4
0000e2  dd01              BLE      |L10.232|
;;;760    					 4:
0000e4  2104              MOVS     r1,#4
0000e6  e000              B        |L10.234|
                  |L10.232|
;;;761    					 uip_connr->nrtx);
0000e8  7ee1              LDRB     r1,[r4,#0x1b]
                  |L10.234|
0000ea  2003              MOVS     r0,#3
0000ec  4088              LSLS     r0,r0,r1
0000ee  76a0              STRB     r0,[r4,#0x1a]
;;;762    	  ++(uip_connr->nrtx);
0000f0  7ee0              LDRB     r0,[r4,#0x1b]
0000f2  1c40              ADDS     r0,r0,#1
0000f4  76e0              STRB     r0,[r4,#0x1b]
;;;763    
;;;764    	  /* Ok, so we need to retransmit. We do this differently
;;;765    	     depending on which state we are in. In ESTABLISHED, we
;;;766    	     call upon the application so that it may prepare the
;;;767    	     data for the retransmit. In SYN_RCVD, we resend the
;;;768    	     SYNACK that we sent earlier and in LAST_ACK we have to
;;;769    	     retransmit our FINACK. */
;;;770    	  UIP_STAT(++uip_stat.tcp.rexmit);
0000f6  48ca              LDR      r0,|L10.1056|
0000f8  8cc0              LDRH     r0,[r0,#0x26]
0000fa  1c40              ADDS     r0,r0,#1
0000fc  b281              UXTH     r1,r0
0000fe  48c8              LDR      r0,|L10.1056|
000100  84c1              STRH     r1,[r0,#0x26]
;;;771    	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
000102  7e60              LDRB     r0,[r4,#0x19]
000104  f000000f          AND      r0,r0,#0xf
000108  2809              CMP      r0,#9
00010a  d222              BCS      |L10.338|
00010c  e8dff000          TBB      [pc,r0]
000110  2105070d          DCB      0x21,0x05,0x07,0x0d
000114  13211421          DCB      0x13,0x21,0x14,0x21
000118  1500              DCB      0x15,0x00
;;;772    	  case UIP_SYN_RCVD:
;;;773    	    /* In the SYN_RCVD state, we should retransmit our
;;;774                   SYNACK. */
;;;775    	    goto tcp_send_synack;
00011a  e366              B        |L10.2026|
                  |L10.284|
00011c  e01a              B        |L10.340|
;;;776    
;;;777    #if UIP_ACTIVE_OPEN
;;;778    	  case UIP_SYN_SENT:
;;;779    	    /* In the SYN_SENT state, we retransmit out SYN. */
;;;780    	    BUF->flags = 0;
00011e  2100              MOVS     r1,#0
000120  48b8              LDR      r0,|L10.1028|
000122  3836              SUBS     r0,r0,#0x36
000124  f880102f          STRB     r1,[r0,#0x2f]
;;;781    	    goto tcp_send_syn;
000128  e364              B        |L10.2036|
;;;782    #endif /* UIP_ACTIVE_OPEN */
;;;783    
;;;784    	  case UIP_ESTABLISHED:
;;;785    	    /* In the ESTABLISHED state, we call upon the application
;;;786                   to do the actual retransmit after which we jump into
;;;787                   the code for sending out the packet (the apprexmit
;;;788                   label). */
;;;789    	    uip_flags = UIP_REXMIT;
00012a  2004              MOVS     r0,#4
00012c  49b8              LDR      r1,|L10.1040|
00012e  7008              STRB     r0,[r1,#0]
;;;790    	    UIP_APPCALL();
000130  f7fffffe          BL       tcp_server_appcall
;;;791    	    goto apprexmit;
000134  e3e5              B        |L10.2306|
;;;792    
;;;793    	  case UIP_FIN_WAIT_1:
;;;794    	  case UIP_CLOSING:
000136  bf00              NOP      
;;;795    	  case UIP_LAST_ACK:
000138  bf00              NOP      
;;;796    	    /* In all these states we should retransmit a FINACK. */
;;;797    	    goto tcp_send_finack;
00013a  e3e3              B        |L10.2308|
                  |L10.316|
;;;798    
;;;799    	  }
;;;800    	}
;;;801          } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
00013c  7e60              LDRB     r0,[r4,#0x19]
00013e  f000000f          AND      r0,r0,#0xf
000142  2803              CMP      r0,#3
000144  d105              BNE      |L10.338|
;;;802    	/* If there was no need for a retransmission, we poll the
;;;803               application for new data. */
;;;804    	uip_flags = UIP_POLL;
000146  2008              MOVS     r0,#8
000148  49b1              LDR      r1,|L10.1040|
00014a  7008              STRB     r0,[r1,#0]
;;;805    	UIP_APPCALL();
00014c  f7fffffe          BL       tcp_server_appcall
;;;806    	goto appsend;
000150  e76d              B        |L10.46|
                  |L10.338|
;;;807          }
;;;808        }
;;;809        goto drop;
000152  e76d              B        |L10.48|
                  |L10.340|
;;;810      }
;;;811    #if UIP_UDP
;;;812      if(flag == UIP_UDP_TIMER) {
;;;813        if(uip_udp_conn->lport != 0) {
;;;814          uip_conn = NULL;
;;;815          uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;816          uip_len = uip_slen = 0;
;;;817          uip_flags = UIP_POLL;
;;;818          UIP_UDP_APPCALL();
;;;819          goto udp_send;
;;;820        } else {
;;;821          goto drop;
;;;822        }
;;;823      }
;;;824    #endif
;;;825    
;;;826      /* This is where the input processing starts. */
;;;827      UIP_STAT(++uip_stat.ip.recv);
000154  48b2              LDR      r0,|L10.1056|
000156  8840              LDRH     r0,[r0,#2]  ; uip_stat
000158  1c40              ADDS     r0,r0,#1
00015a  49b1              LDR      r1,|L10.1056|
00015c  8048              STRH     r0,[r1,#2]
;;;828    
;;;829      /* Start of IP input header processing code. */
;;;830    
;;;831    #if UIP_CONF_IPV6
;;;832      /* Check validity of the IP header. */
;;;833      if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
;;;834        UIP_STAT(++uip_stat.ip.drop);
;;;835        UIP_STAT(++uip_stat.ip.vhlerr);
;;;836        UIP_LOG("ipv6: invalid version.");
;;;837        goto drop;
;;;838      }
;;;839    #else /* UIP_CONF_IPV6 */
;;;840      /* Check validity of the IP header. */
;;;841      if(BUF->vhl != 0x45)  { /* IP version and header length. */
00015e  48a9              LDR      r0,|L10.1028|
000160  3836              SUBS     r0,r0,#0x36
000162  7b80              LDRB     r0,[r0,#0xe]  ; uip_buf
000164  2845              CMP      r0,#0x45
000166  d00b              BEQ      |L10.384|
;;;842        UIP_STAT(++uip_stat.ip.drop);
000168  4608              MOV      r0,r1
00016a  8800              LDRH     r0,[r0,#0]  ; uip_stat
00016c  1c40              ADDS     r0,r0,#1
00016e  8008              STRH     r0,[r1,#0]
;;;843        UIP_STAT(++uip_stat.ip.vhlerr);
000170  4608              MOV      r0,r1
000172  88c0              LDRH     r0,[r0,#6]  ; uip_stat
000174  1c40              ADDS     r0,r0,#1
000176  80c8              STRH     r0,[r1,#6]
;;;844        UIP_LOG("ip: invalid version or header length.");
000178  a0aa              ADR      r0,|L10.1060|
00017a  f7fffffe          BL       uip_log
;;;845        goto drop;
00017e  e757              B        |L10.48|
                  |L10.384|
;;;846      }
;;;847    #endif /* UIP_CONF_IPV6 */
;;;848    
;;;849      /* Check the size of the packet. If the size reported to us in
;;;850         uip_len is smaller the size reported in the IP header, we assume
;;;851         that the packet has been corrupted in transit. If the size of
;;;852         uip_len is larger than the size reported in the IP packet header,
;;;853         the packet has been padded and we set uip_len to the correct
;;;854         value.. */
;;;855    
;;;856      if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
000180  48a0              LDR      r0,|L10.1028|
000182  3836              SUBS     r0,r0,#0x36
000184  7c41              LDRB     r1,[r0,#0x11]
000186  7c00              LDRB     r0,[r0,#0x10]
000188  eb012000          ADD      r0,r1,r0,LSL #8
00018c  49a2              LDR      r1,|L10.1048|
00018e  8809              LDRH     r1,[r1,#0]  ; uip_len
000190  4288              CMP      r0,r1
000192  dc08              BGT      |L10.422|
;;;857        uip_len = (BUF->len[0] << 8) + BUF->len[1];
000194  489b              LDR      r0,|L10.1028|
000196  3836              SUBS     r0,r0,#0x36
000198  7c41              LDRB     r1,[r0,#0x11]
00019a  7c00              LDRB     r0,[r0,#0x10]
00019c  eb012000          ADD      r0,r1,r0,LSL #8
0001a0  499d              LDR      r1,|L10.1048|
0001a2  8008              STRH     r0,[r1,#0]
0001a4  e003              B        |L10.430|
                  |L10.422|
;;;858    #if UIP_CONF_IPV6
;;;859        uip_len += 40; /* The length reported in the IPv6 header is the
;;;860    		      length of the payload that follows the
;;;861    		      header. However, uIP uses the uip_len variable
;;;862    		      for holding the size of the entire packet,
;;;863    		      including the IP header. For IPv4 this is not a
;;;864    		      problem as the length field in the IPv4 header
;;;865    		      contains the length of the entire packet. But
;;;866    		      for IPv6 we need to add the size of the IPv6
;;;867    		      header (40 bytes). */
;;;868    #endif /* UIP_CONF_IPV6 */
;;;869      } else {
;;;870        UIP_LOG("ip: packet shorter than reported in IP header.");
0001a6  a0a9              ADR      r0,|L10.1100|
0001a8  f7fffffe          BL       uip_log
;;;871        goto drop;
0001ac  e740              B        |L10.48|
                  |L10.430|
;;;872      }
;;;873    
;;;874    #if !UIP_CONF_IPV6
;;;875      /* Check the fragment flag. */
;;;876      if((BUF->ipoffset[0] & 0x3f) != 0 ||
0001ae  4895              LDR      r0,|L10.1028|
0001b0  3836              SUBS     r0,r0,#0x36
0001b2  7d00              LDRB     r0,[r0,#0x14]
0001b4  f0100f3f          TST      r0,#0x3f
0001b8  d103              BNE      |L10.450|
;;;877         BUF->ipoffset[1] != 0) {
0001ba  4892              LDR      r0,|L10.1028|
0001bc  3836              SUBS     r0,r0,#0x36
0001be  7d40              LDRB     r0,[r0,#0x15]
0001c0  b160              CBZ      r0,|L10.476|
                  |L10.450|
;;;878    #if UIP_REASSEMBLY
;;;879        uip_len = uip_reass();
;;;880        if(uip_len == 0) {
;;;881          goto drop;
;;;882        }
;;;883    #else /* UIP_REASSEMBLY */
;;;884        UIP_STAT(++uip_stat.ip.drop);
0001c2  4897              LDR      r0,|L10.1056|
0001c4  8800              LDRH     r0,[r0,#0]  ; uip_stat
0001c6  1c40              ADDS     r0,r0,#1
0001c8  4995              LDR      r1,|L10.1056|
0001ca  8008              STRH     r0,[r1,#0]
;;;885        UIP_STAT(++uip_stat.ip.fragerr);
0001cc  4608              MOV      r0,r1
0001ce  8980              LDRH     r0,[r0,#0xc]  ; uip_stat
0001d0  1c40              ADDS     r0,r0,#1
0001d2  8188              STRH     r0,[r1,#0xc]
;;;886        UIP_LOG("ip: fragment dropped.");
0001d4  a0a9              ADR      r0,|L10.1148|
0001d6  f7fffffe          BL       uip_log
;;;887        goto drop;
0001da  e729              B        |L10.48|
                  |L10.476|
;;;888    #endif /* UIP_REASSEMBLY */
;;;889      }
;;;890    #endif /* UIP_CONF_IPV6 */
;;;891    
;;;892      if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
0001dc  48ad              LDR      r0,|L10.1172|
0001de  8800              LDRH     r0,[r0,#0]  ; uip_hostaddr
0001e0  49ad              LDR      r1,|L10.1176|
0001e2  8809              LDRH     r1,[r1,#0]  ; all_zeroes_addr
0001e4  4288              CMP      r0,r1
0001e6  d105              BNE      |L10.500|
0001e8  48aa              LDR      r0,|L10.1172|
0001ea  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
0001ec  49aa              LDR      r1,|L10.1176|
0001ee  8849              LDRH     r1,[r1,#2]  ; all_zeroes_addr
0001f0  4288              CMP      r0,r1
0001f2  d013              BEQ      |L10.540|
                  |L10.500|
;;;893        /* If we are configured to use ping IP address configuration and
;;;894           hasn't been assigned an IP address yet, we accept all ICMP
;;;895           packets. */
;;;896    #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
;;;897        if(BUF->proto == UIP_PROTO_ICMP) {
;;;898          UIP_LOG("ip: possible ping config packet received.");
;;;899          goto icmp_input;
;;;900        } else {
;;;901          UIP_LOG("ip: packet dropped since no address assigned.");
;;;902          goto drop;
;;;903        }
;;;904    #endif /* UIP_PINGADDRCONF */
;;;905    
;;;906      } else {
;;;907        /* If IP broadcast support is configured, we check for a broadcast
;;;908           UDP packet, which may be destined to us. */
;;;909    #if UIP_BROADCAST
;;;910        DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
;;;911        if(BUF->proto == UIP_PROTO_UDP &&
;;;912           uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
;;;913           /*&&
;;;914    	 uip_ipchksum() == 0xffff*/) {
;;;915          goto udp_input;
;;;916        }
;;;917    #endif /* UIP_BROADCAST */
;;;918    
;;;919        /* Check if the packet is destined for our IP address. */
;;;920    #if !UIP_CONF_IPV6
;;;921        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
0001f4  4883              LDR      r0,|L10.1028|
0001f6  3836              SUBS     r0,r0,#0x36
0001f8  8bc0              LDRH     r0,[r0,#0x1e]
0001fa  49a6              LDR      r1,|L10.1172|
0001fc  8809              LDRH     r1,[r1,#0]  ; uip_hostaddr
0001fe  4288              CMP      r0,r1
000200  d106              BNE      |L10.528|
000202  4880              LDR      r0,|L10.1028|
000204  3836              SUBS     r0,r0,#0x36
000206  8c00              LDRH     r0,[r0,#0x20]
000208  49a2              LDR      r1,|L10.1172|
00020a  8849              LDRH     r1,[r1,#2]  ; uip_hostaddr
00020c  4288              CMP      r0,r1
00020e  d005              BEQ      |L10.540|
                  |L10.528|
;;;922          UIP_STAT(++uip_stat.ip.drop);
000210  4883              LDR      r0,|L10.1056|
000212  8800              LDRH     r0,[r0,#0]  ; uip_stat
000214  1c40              ADDS     r0,r0,#1
000216  4982              LDR      r1,|L10.1056|
000218  8008              STRH     r0,[r1,#0]
;;;923          goto drop;
00021a  e709              B        |L10.48|
                  |L10.540|
;;;924        }
;;;925    #else /* UIP_CONF_IPV6 */
;;;926        /* For IPv6, packet reception is a little trickier as we need to
;;;927           make sure that we listen to certain multicast addresses (all
;;;928           hosts multicast address, and the solicited-node multicast
;;;929           address) as well. However, we will cheat here and accept all
;;;930           multicast packets that are sent to the ff02::/16 addresses. */
;;;931        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
;;;932           BUF->destipaddr[0] != HTONS(0xff02)) {
;;;933          UIP_STAT(++uip_stat.ip.drop);
;;;934          goto drop;
;;;935        }
;;;936    #endif /* UIP_CONF_IPV6 */
;;;937      }
;;;938    
;;;939    #if !UIP_CONF_IPV6
;;;940      if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
00021c  f7fffffe          BL       uip_ipchksum
000220  f5a0417f          SUB      r1,r0,#0xff00
000224  39ff              SUBS     r1,r1,#0xff
000226  d00c              BEQ      |L10.578|
;;;941    				    checksum. */
;;;942        UIP_STAT(++uip_stat.ip.drop);
000228  487d              LDR      r0,|L10.1056|
00022a  8800              LDRH     r0,[r0,#0]  ; uip_stat
00022c  1c40              ADDS     r0,r0,#1
00022e  497c              LDR      r1,|L10.1056|
000230  8008              STRH     r0,[r1,#0]
;;;943        UIP_STAT(++uip_stat.ip.chkerr);
000232  4608              MOV      r0,r1
000234  89c0              LDRH     r0,[r0,#0xe]  ; uip_stat
000236  1c40              ADDS     r0,r0,#1
000238  81c8              STRH     r0,[r1,#0xe]
;;;944        UIP_LOG("ip: bad checksum.");
00023a  a098              ADR      r0,|L10.1180|
00023c  f7fffffe          BL       uip_log
;;;945        goto drop;
000240  e6f6              B        |L10.48|
                  |L10.578|
;;;946      }
;;;947    #endif /* UIP_CONF_IPV6 */
;;;948    
;;;949    
;;;950      if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
000242  4870              LDR      r0,|L10.1028|
000244  3836              SUBS     r0,r0,#0x36
000246  7dc0              LDRB     r0,[r0,#0x17]
000248  2806              CMP      r0,#6
00024a  d100              BNE      |L10.590|
;;;951    				       proceed with TCP input
;;;952    				       processing. */
;;;953        goto tcp_input;
00024c  e062              B        |L10.788|
                  |L10.590|
;;;954      }
;;;955    
;;;956    #if UIP_UDP
;;;957      if(BUF->proto == UIP_PROTO_UDP) {
;;;958        goto udp_input;
;;;959      }
;;;960    #endif /* UIP_UDP */
;;;961    
;;;962    #if !UIP_CONF_IPV6
;;;963      /* ICMPv4 processing code follows. */
;;;964      if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
00024e  486d              LDR      r0,|L10.1028|
000250  3836              SUBS     r0,r0,#0x36
000252  7dc0              LDRB     r0,[r0,#0x17]
000254  2801              CMP      r0,#1
000256  d00c              BEQ      |L10.626|
;;;965    					here. */
;;;966        UIP_STAT(++uip_stat.ip.drop);
000258  4871              LDR      r0,|L10.1056|
00025a  8800              LDRH     r0,[r0,#0]  ; uip_stat
00025c  1c40              ADDS     r0,r0,#1
00025e  4970              LDR      r1,|L10.1056|
000260  8008              STRH     r0,[r1,#0]
;;;967        UIP_STAT(++uip_stat.ip.protoerr);
000262  4608              MOV      r0,r1
000264  8a00              LDRH     r0,[r0,#0x10]  ; uip_stat
000266  1c40              ADDS     r0,r0,#1
000268  8208              STRH     r0,[r1,#0x10]
;;;968        UIP_LOG("ip: neither tcp nor icmp.");
00026a  a091              ADR      r0,|L10.1200|
00026c  f7fffffe          BL       uip_log
;;;969        goto drop;
000270  e6de              B        |L10.48|
                  |L10.626|
;;;970      }
;;;971    
;;;972    #if UIP_PINGADDRCONF
;;;973     icmp_input:
;;;974    #endif /* UIP_PINGADDRCONF */
;;;975      UIP_STAT(++uip_stat.icmp.recv);
000272  486b              LDR      r0,|L10.1056|
000274  8a80              LDRH     r0,[r0,#0x14]
000276  1c40              ADDS     r0,r0,#1
000278  b281              UXTH     r1,r0
00027a  4869              LDR      r0,|L10.1056|
00027c  8281              STRH     r1,[r0,#0x14]
;;;976    
;;;977      /* ICMP echo (i.e., ping) processing. This is simple, we only change
;;;978         the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
;;;979         checksum before we return the packet. */
;;;980      if(ICMPBUF->type != ICMP_ECHO) {
00027e  4861              LDR      r0,|L10.1028|
000280  3836              SUBS     r0,r0,#0x36
000282  f8900022          LDRB     r0,[r0,#0x22]
000286  2808              CMP      r0,#8
000288  d00e              BEQ      |L10.680|
;;;981        UIP_STAT(++uip_stat.icmp.drop);
00028a  4865              LDR      r0,|L10.1056|
00028c  8a40              LDRH     r0,[r0,#0x12]  ; uip_stat
00028e  1c40              ADDS     r0,r0,#1
000290  4963              LDR      r1,|L10.1056|
000292  8248              STRH     r0,[r1,#0x12]
;;;982        UIP_STAT(++uip_stat.icmp.typeerr);
000294  4608              MOV      r0,r1
000296  8b00              LDRH     r0,[r0,#0x18]
000298  1c40              ADDS     r0,r0,#1
00029a  b281              UXTH     r1,r0
00029c  4860              LDR      r0,|L10.1056|
00029e  8301              STRH     r1,[r0,#0x18]
;;;983        UIP_LOG("icmp: not icmp echo.");
0002a0  a08a              ADR      r0,|L10.1228|
0002a2  f7fffffe          BL       uip_log
;;;984        goto drop;
0002a6  e6c3              B        |L10.48|
                  |L10.680|
;;;985      }
;;;986    
;;;987      /* If we are configured to use ping IP address assignment, we use
;;;988         the destination IP address of this ping packet and assign it to
;;;989         ourself. */
;;;990    #if UIP_PINGADDRCONF
;;;991      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
;;;992        uip_hostaddr[0] = BUF->destipaddr[0];
;;;993        uip_hostaddr[1] = BUF->destipaddr[1];
;;;994      }
;;;995    #endif /* UIP_PINGADDRCONF */
;;;996    
;;;997      ICMPBUF->type = ICMP_ECHO_REPLY;
0002a8  2100              MOVS     r1,#0
0002aa  4856              LDR      r0,|L10.1028|
0002ac  3836              SUBS     r0,r0,#0x36
0002ae  f8801022          STRB     r1,[r0,#0x22]
;;;998    
;;;999      if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
0002b2  8c80              LDRH     r0,[r0,#0x24]
0002b4  f64f71f7          MOV      r1,#0xfff7
0002b8  4288              CMP      r0,r1
0002ba  db08              BLT      |L10.718|
;;;1000       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
0002bc  4851              LDR      r0,|L10.1028|
0002be  3836              SUBS     r0,r0,#0x36
0002c0  8c80              LDRH     r0,[r0,#0x24]
0002c2  3009              ADDS     r0,r0,#9
0002c4  b281              UXTH     r1,r0
0002c6  484f              LDR      r0,|L10.1028|
0002c8  3836              SUBS     r0,r0,#0x36
0002ca  8481              STRH     r1,[r0,#0x24]
0002cc  e007              B        |L10.734|
                  |L10.718|
;;;1001     } else {
;;;1002       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
0002ce  484d              LDR      r0,|L10.1028|
0002d0  3836              SUBS     r0,r0,#0x36
0002d2  8c80              LDRH     r0,[r0,#0x24]
0002d4  3008              ADDS     r0,r0,#8
0002d6  b281              UXTH     r1,r0
0002d8  484a              LDR      r0,|L10.1028|
0002da  3836              SUBS     r0,r0,#0x36
0002dc  8481              STRH     r1,[r0,#0x24]
                  |L10.734|
;;;1003     }
;;;1004   
;;;1005     /* Swap IP addresses. */
;;;1006     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
0002de  bf00              NOP      
0002e0  4848              LDR      r0,|L10.1028|
0002e2  3836              SUBS     r0,r0,#0x36
0002e4  8b41              LDRH     r1,[r0,#0x1a]
0002e6  83c1              STRH     r1,[r0,#0x1e]
0002e8  8b81              LDRH     r1,[r0,#0x1c]
0002ea  8401              STRH     r1,[r0,#0x20]
0002ec  bf00              NOP      
;;;1007     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
0002ee  bf00              NOP      
0002f0  4868              LDR      r0,|L10.1172|
0002f2  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
0002f4  4843              LDR      r0,|L10.1028|
0002f6  3836              SUBS     r0,r0,#0x36
0002f8  8341              STRH     r1,[r0,#0x1a]
0002fa  4866              LDR      r0,|L10.1172|
0002fc  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
0002fe  4841              LDR      r0,|L10.1028|
000300  3836              SUBS     r0,r0,#0x36
000302  8381              STRH     r1,[r0,#0x1c]
000304  bf00              NOP      
;;;1008   
;;;1009     UIP_STAT(++uip_stat.icmp.sent);
000306  4846              LDR      r0,|L10.1056|
000308  8ac0              LDRH     r0,[r0,#0x16]
00030a  1c40              ADDS     r0,r0,#1
00030c  b281              UXTH     r1,r0
00030e  4844              LDR      r0,|L10.1056|
000310  82c1              STRH     r1,[r0,#0x16]
;;;1010     goto send;
000312  e3f3              B        |L10.2812|
                  |L10.788|
;;;1011   
;;;1012     /* End of IPv4 input header processing code. */
;;;1013   #else /* !UIP_CONF_IPV6 */
;;;1014   
;;;1015     /* This is IPv6 ICMPv6 processing code. */
;;;1016     DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
;;;1017   
;;;1018     if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
;;;1019   					 here. */
;;;1020       UIP_STAT(++uip_stat.ip.drop);
;;;1021       UIP_STAT(++uip_stat.ip.protoerr);
;;;1022       UIP_LOG("ip: neither tcp nor icmp6.");
;;;1023       goto drop;
;;;1024     }
;;;1025   
;;;1026     UIP_STAT(++uip_stat.icmp.recv);
;;;1027   
;;;1028     /* If we get a neighbor solicitation for our address we should send
;;;1029        a neighbor advertisement message back. */
;;;1030     if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
;;;1031       if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
;;;1032   
;;;1033         if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
;;;1034   	/* Save the sender's address in our neighbor list. */
;;;1035   	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
;;;1036         }
;;;1037   
;;;1038         /* We should now send a neighbor advertisement back to where the
;;;1039   	 neighbor solicication came from. */
;;;1040         ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
;;;1041         ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
;;;1042   
;;;1043         ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
;;;1044   
;;;1045         uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
;;;1046         uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
;;;1047         ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
;;;1048         ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
;;;1049         memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
;;;1050         ICMPBUF->icmpchksum = 0;
;;;1051         ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1052         goto send;
;;;1053   
;;;1054       }
;;;1055       goto drop;
;;;1056     } else if(ICMPBUF->type == ICMP6_ECHO) {
;;;1057       /* ICMP echo (i.e., ping) processing. This is simple, we only
;;;1058          change the ICMP type from ECHO to ECHO_REPLY and update the
;;;1059          ICMP checksum before we return the packet. */
;;;1060   
;;;1061       ICMPBUF->type = ICMP6_ECHO_REPLY;
;;;1062   
;;;1063       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1064       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1065       ICMPBUF->icmpchksum = 0;
;;;1066       ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1067   
;;;1068       UIP_STAT(++uip_stat.icmp.sent);
;;;1069       goto send;
;;;1070     } else {
;;;1071       DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
;;;1072       UIP_STAT(++uip_stat.icmp.drop);
;;;1073       UIP_STAT(++uip_stat.icmp.typeerr);
;;;1074       UIP_LOG("icmp: unknown ICMP message.");
;;;1075       goto drop;
;;;1076     }
;;;1077   
;;;1078     /* End of IPv6 ICMP processing. */
;;;1079   
;;;1080   #endif /* !UIP_CONF_IPV6 */
;;;1081   
;;;1082   #if UIP_UDP
;;;1083     /* UDP input processing. */
;;;1084    udp_input:
;;;1085     /* UDP processing is really just a hack. We don't do anything to the
;;;1086        UDP/IP headers, but let the UDP application do all the hard
;;;1087        work. If the application sets uip_slen, it has a packet to
;;;1088        send. */
;;;1089   #if UIP_UDP_CHECKSUMS
;;;1090     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1091     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1092     if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
;;;1093       UIP_STAT(++uip_stat.udp.drop);
;;;1094       UIP_STAT(++uip_stat.udp.chkerr);
;;;1095       UIP_LOG("udp: bad checksum.");
;;;1096       goto drop;
;;;1097     }
;;;1098   #else /* UIP_UDP_CHECKSUMS */
;;;1099     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1100   #endif /* UIP_UDP_CHECKSUMS */
;;;1101   
;;;1102     /* Demultiplex this UDP packet between the UDP "connections". */
;;;1103     for(uip_udp_conn = &uip_udp_conns[0];
;;;1104         uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
;;;1105         ++uip_udp_conn) {
;;;1106       /* If the local UDP port is non-zero, the connection is considered
;;;1107          to be used. If so, the local port number is checked against the
;;;1108          destination port number in the received packet. If the two port
;;;1109          numbers match, the remote port number is checked if the
;;;1110          connection is bound to a remote port. Finally, if the
;;;1111          connection is bound to a remote IP address, the source IP
;;;1112          address of the packet is checked. */
;;;1113       if(uip_udp_conn->lport != 0 &&
;;;1114          UDPBUF->destport == uip_udp_conn->lport &&
;;;1115          (uip_udp_conn->rport == 0 ||
;;;1116           UDPBUF->srcport == uip_udp_conn->rport) &&
;;;1117          (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
;;;1118   	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
;;;1119   	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
;;;1120         goto udp_found;
;;;1121       }
;;;1122     }
;;;1123     UIP_LOG("udp: no matching connection found");
;;;1124     goto drop;
;;;1125   
;;;1126    udp_found:
;;;1127     uip_conn = NULL;
;;;1128     uip_flags = UIP_NEWDATA;
;;;1129     uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1130     uip_slen = 0;
;;;1131     UIP_UDP_APPCALL();
;;;1132    udp_send:
;;;1133     if(uip_slen == 0) {
;;;1134       goto drop;
;;;1135     }
;;;1136     uip_len = uip_slen + UIP_IPUDPH_LEN;
;;;1137   
;;;1138   #if UIP_CONF_IPV6
;;;1139     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1140        length. */
;;;1141     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1142     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1143   #else /* UIP_CONF_IPV6 */
;;;1144     BUF->len[0] = (uip_len >> 8);
;;;1145     BUF->len[1] = (uip_len & 0xff);
;;;1146   #endif /* UIP_CONF_IPV6 */
;;;1147   
;;;1148     BUF->ttl = uip_udp_conn->ttl;
;;;1149     BUF->proto = UIP_PROTO_UDP;
;;;1150   
;;;1151     UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
;;;1152     UDPBUF->udpchksum = 0;
;;;1153   
;;;1154     BUF->srcport  = uip_udp_conn->lport;
;;;1155     BUF->destport = uip_udp_conn->rport;
;;;1156   
;;;1157     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1158     uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
;;;1159   
;;;1160     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
;;;1161   
;;;1162   #if UIP_UDP_CHECKSUMS
;;;1163     /* Calculate UDP checksum. */
;;;1164     UDPBUF->udpchksum = ~(uip_udpchksum());
;;;1165     if(UDPBUF->udpchksum == 0) {
;;;1166       UDPBUF->udpchksum = 0xffff;
;;;1167     }
;;;1168   #endif /* UIP_UDP_CHECKSUMS */
;;;1169   
;;;1170     goto ip_send_nolen;
;;;1171   #endif /* UIP_UDP */
;;;1172   
;;;1173     /* TCP input processing. */
;;;1174    tcp_input:
;;;1175     UIP_STAT(++uip_stat.tcp.recv);
000314  4842              LDR      r0,|L10.1056|
000316  8b80              LDRH     r0,[r0,#0x1c]
000318  1c40              ADDS     r0,r0,#1
00031a  b281              UXTH     r1,r0
00031c  4840              LDR      r0,|L10.1056|
00031e  8381              STRH     r1,[r0,#0x1c]
;;;1176   
;;;1177     /* Start of TCP input header processing code. */
;;;1178   
;;;1179     if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
000320  f7fffffe          BL       uip_tcpchksum
000324  f5a0417f          SUB      r1,r0,#0xff00
000328  39ff              SUBS     r1,r1,#0xff
00032a  d00e              BEQ      |L10.842|
;;;1180   				       checksum. */
;;;1181       UIP_STAT(++uip_stat.tcp.drop);
00032c  483c              LDR      r0,|L10.1056|
00032e  8b40              LDRH     r0,[r0,#0x1a]  ; uip_stat
000330  1c40              ADDS     r0,r0,#1
000332  493b              LDR      r1,|L10.1056|
000334  8348              STRH     r0,[r1,#0x1a]
;;;1182       UIP_STAT(++uip_stat.tcp.chkerr);
000336  4608              MOV      r0,r1
000338  8c00              LDRH     r0,[r0,#0x20]
00033a  1c40              ADDS     r0,r0,#1
00033c  b281              UXTH     r1,r0
00033e  4838              LDR      r0,|L10.1056|
000340  8401              STRH     r1,[r0,#0x20]
;;;1183       UIP_LOG("tcp: bad checksum.");
000342  a068              ADR      r0,|L10.1252|
000344  f7fffffe          BL       uip_log
;;;1184       goto drop;
000348  e672              B        |L10.48|
                  |L10.842|
;;;1185     }
;;;1186   
;;;1187   
;;;1188     /* Demultiplex this segment. */
;;;1189     /* First check any active connections. */
;;;1190     for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
00034a  4c6b              LDR      r4,|L10.1272|
00034c  e01b              B        |L10.902|
                  |L10.846|
;;;1191         ++uip_connr) {
;;;1192       if(uip_connr->tcpstateflags != UIP_CLOSED &&
00034e  7e60              LDRB     r0,[r4,#0x19]
000350  b1c0              CBZ      r0,|L10.900|
;;;1193          BUF->destport == uip_connr->lport &&
000352  482c              LDR      r0,|L10.1028|
000354  3836              SUBS     r0,r0,#0x36
000356  8c80              LDRH     r0,[r0,#0x24]
000358  88a1              LDRH     r1,[r4,#4]
00035a  4288              CMP      r0,r1
00035c  d112              BNE      |L10.900|
;;;1194          BUF->srcport == uip_connr->rport &&
00035e  4829              LDR      r0,|L10.1028|
000360  3836              SUBS     r0,r0,#0x36
000362  8c40              LDRH     r0,[r0,#0x22]
000364  88e1              LDRH     r1,[r4,#6]
000366  4288              CMP      r0,r1
000368  d10c              BNE      |L10.900|
;;;1195          uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
00036a  4826              LDR      r0,|L10.1028|
00036c  3836              SUBS     r0,r0,#0x36
00036e  8b40              LDRH     r0,[r0,#0x1a]
000370  8821              LDRH     r1,[r4,#0]
000372  4288              CMP      r0,r1
000374  d106              BNE      |L10.900|
000376  4823              LDR      r0,|L10.1028|
000378  3836              SUBS     r0,r0,#0x36
00037a  8b80              LDRH     r0,[r0,#0x1c]
00037c  8861              LDRH     r1,[r4,#2]
00037e  4288              CMP      r0,r1
000380  d100              BNE      |L10.900|
;;;1196         goto found;
000382  e254              B        |L10.2094|
                  |L10.900|
000384  3428              ADDS     r4,r4,#0x28           ;1191
                  |L10.902|
000386  485d              LDR      r0,|L10.1276|
000388  4284              CMP      r4,r0                 ;1190
00038a  d9e0              BLS      |L10.846|
;;;1197       }
;;;1198     }
;;;1199   
;;;1200     /* If we didn't find and active connection that expected the packet,
;;;1201        either this packet is an old duplicate, or this is a SYN packet
;;;1202        destined for a connection in LISTEN. If the SYN flag isn't set,
;;;1203        it is an old packet and we send a RST. */
;;;1204     if((BUF->flags & TCP_CTL) != TCP_SYN) {
00038c  481d              LDR      r0,|L10.1028|
00038e  3836              SUBS     r0,r0,#0x36
000390  f890002f          LDRB     r0,[r0,#0x2f]
000394  f000003f          AND      r0,r0,#0x3f
000398  2802              CMP      r0,#2
00039a  d000              BEQ      |L10.926|
;;;1205       goto reset;
00039c  e028              B        |L10.1008|
                  |L10.926|
;;;1206     }
;;;1207   
;;;1208     tmp16 = BUF->destport;
00039e  4819              LDR      r0,|L10.1028|
0003a0  3836              SUBS     r0,r0,#0x36
0003a2  8c80              LDRH     r0,[r0,#0x24]
0003a4  491b              LDR      r1,|L10.1044|
0003a6  310c              ADDS     r1,r1,#0xc
0003a8  8008              STRH     r0,[r1,#0]
;;;1209     /* Next, check listening connections. */
;;;1210     for(c = 0; c < UIP_LISTENPORTS; ++c) {
0003aa  2000              MOVS     r0,#0
0003ac  1e89              SUBS     r1,r1,#2
0003ae  7008              STRB     r0,[r1,#0]
0003b0  e012              B        |L10.984|
                  |L10.946|
;;;1211       if(tmp16 == uip_listenports[c])
0003b2  4853              LDR      r0,|L10.1280|
0003b4  4917              LDR      r1,|L10.1044|
0003b6  310a              ADDS     r1,r1,#0xa
0003b8  7809              LDRB     r1,[r1,#0]  ; c
0003ba  f8300011          LDRH     r0,[r0,r1,LSL #1]
0003be  4915              LDR      r1,|L10.1044|
0003c0  310c              ADDS     r1,r1,#0xc
0003c2  8809              LDRH     r1,[r1,#0]  ; tmp16
0003c4  4288              CMP      r0,r1
0003c6  d100              BNE      |L10.970|
;;;1212         goto found_listen;
0003c8  e127              B        |L10.1562|
                  |L10.970|
0003ca  4812              LDR      r0,|L10.1044|
0003cc  300a              ADDS     r0,r0,#0xa            ;1210
0003ce  7800              LDRB     r0,[r0,#0]            ;1210  ; c
0003d0  1c40              ADDS     r0,r0,#1              ;1210
0003d2  4910              LDR      r1,|L10.1044|
0003d4  310a              ADDS     r1,r1,#0xa            ;1210
0003d6  7008              STRB     r0,[r1,#0]            ;1210
                  |L10.984|
0003d8  480e              LDR      r0,|L10.1044|
0003da  300a              ADDS     r0,r0,#0xa            ;1210
0003dc  7800              LDRB     r0,[r0,#0]            ;1210  ; c
0003de  2828              CMP      r0,#0x28              ;1210
0003e0  dbe7              BLT      |L10.946|
;;;1213     }
;;;1214   
;;;1215     /* No matching connection found, so we send a RST packet. */
;;;1216     UIP_STAT(++uip_stat.tcp.synrst);
0003e2  480f              LDR      r0,|L10.1056|
0003e4  8d40              LDRH     r0,[r0,#0x2a]
0003e6  1c40              ADDS     r0,r0,#1
0003e8  b281              UXTH     r1,r0
0003ea  480d              LDR      r0,|L10.1056|
0003ec  8541              STRH     r1,[r0,#0x2a]
;;;1217    reset:
0003ee  bf00              NOP      
                  |L10.1008|
;;;1218   
;;;1219     /* We do not send resets in response to resets. */
;;;1220     if(BUF->flags & TCP_RST) {
0003f0  4804              LDR      r0,|L10.1028|
0003f2  3836              SUBS     r0,r0,#0x36
0003f4  f890002f          LDRB     r0,[r0,#0x2f]
0003f8  f0100f04          TST      r0,#4
0003fc  e082              B        |L10.1284|
0003fe  0000              DCW      0x0000
                  |L10.1024|
                          DCD      uip_conn
                  |L10.1028|
                          DCD      uip_buf+0x36
                  |L10.1032|
                          DCD      uip_appdata
                  |L10.1036|
                          DCD      uip_sappdata
                  |L10.1040|
                          DCD      uip_flags
                  |L10.1044|
                          DCD      ||.data||+0x2a
                  |L10.1048|
                          DCD      uip_len
                  |L10.1052|
                          DCD      uip_slen
                  |L10.1056|
                          DCD      uip_stat
                  |L10.1060|
000424  69703a20696e76616c69642076657273696f6e206f7220686561646572206c656e6774682e00        DCB      "ip: invalid version or header length.",0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L10.1100|
00044c  69703a207061636b65742073686f72746572207468616e207265706f7274656420696e204950206865616465722e00        DCB      "ip: packet shorter than reported in IP header.",0
00047b  00                DCB      0
                  |L10.1148|
00047c  69703a20667261676d656e742064726f707065642e00        DCB      "ip: fragment dropped.",0
000492  00                DCB      0
000493  00                DCB      0
                  |L10.1172|
                          DCD      uip_hostaddr
                  |L10.1176|
                          DCD      ||.constdata||+0x4
                  |L10.1180|
00049c  69703a2062616420636865636b73756d2e00        DCB      "ip: bad checksum.",0
0004ae  00                DCB      0
0004af  00                DCB      0
                  |L10.1200|
0004b0  69703a206e65697468657220746370206e6f722069636d702e00        DCB      "ip: neither tcp nor icmp.",0
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L10.1228|
0004cc  69636d703a206e6f742069636d70206563686f2e00        DCB      "icmp: not icmp echo.",0
0004e1  00                DCB      0
0004e2  00                DCB      0
0004e3  00                DCB      0
                  |L10.1252|
0004e4  7463703a2062616420636865636b73756d2e00        DCB      "tcp: bad checksum.",0
0004f7  00                DCB      0
                  |L10.1272|
                          DCD      uip_conns
                  |L10.1276|
                          DCD      uip_conns+0x618
                  |L10.1280|
                          DCD      uip_listenports
                  |L10.1284|
000504  d000              BEQ      |L10.1288|
;;;1221       goto drop;
000506  e593              B        |L10.48|
                  |L10.1288|
;;;1222     }
;;;1223   
;;;1224     UIP_STAT(++uip_stat.tcp.rst);
000508  48ff              LDR      r0,|L10.2312|
00050a  8c80              LDRH     r0,[r0,#0x24]
00050c  1c40              ADDS     r0,r0,#1
00050e  b281              UXTH     r1,r0
000510  48fd              LDR      r0,|L10.2312|
000512  8481              STRH     r1,[r0,#0x24]
;;;1225   
;;;1226     BUF->flags = TCP_RST | TCP_ACK;
000514  2114              MOVS     r1,#0x14
000516  48fd              LDR      r0,|L10.2316|
000518  f880102f          STRB     r1,[r0,#0x2f]
;;;1227     uip_len = UIP_IPTCPH_LEN;
00051c  2028              MOVS     r0,#0x28
00051e  49fc              LDR      r1,|L10.2320|
000520  8008              STRH     r0,[r1,#0]
;;;1228     BUF->tcpoffset = 5 << 4;
000522  2150              MOVS     r1,#0x50
000524  48f9              LDR      r0,|L10.2316|
000526  f880102e          STRB     r1,[r0,#0x2e]
;;;1229   
;;;1230     /* Flip the seqno and ackno fields in the TCP header. */
;;;1231     c = BUF->seqno[3];
00052a  f8900029          LDRB     r0,[r0,#0x29]
00052e  49f9              LDR      r1,|L10.2324|
000530  7008              STRB     r0,[r1,#0]
;;;1232     BUF->seqno[3] = BUF->ackno[3];
000532  48f6              LDR      r0,|L10.2316|
000534  f890102d          LDRB     r1,[r0,#0x2d]
000538  f8801029          STRB     r1,[r0,#0x29]
;;;1233     BUF->ackno[3] = c;
00053c  48f5              LDR      r0,|L10.2324|
00053e  7801              LDRB     r1,[r0,#0]  ; c
000540  48f2              LDR      r0,|L10.2316|
000542  f880102d          STRB     r1,[r0,#0x2d]
;;;1234   
;;;1235     c = BUF->seqno[2];
000546  f8900028          LDRB     r0,[r0,#0x28]
00054a  49f2              LDR      r1,|L10.2324|
00054c  7008              STRB     r0,[r1,#0]
;;;1236     BUF->seqno[2] = BUF->ackno[2];
00054e  48ef              LDR      r0,|L10.2316|
000550  f890102c          LDRB     r1,[r0,#0x2c]
000554  f8801028          STRB     r1,[r0,#0x28]
;;;1237     BUF->ackno[2] = c;
000558  48ee              LDR      r0,|L10.2324|
00055a  7801              LDRB     r1,[r0,#0]  ; c
00055c  48eb              LDR      r0,|L10.2316|
00055e  f880102c          STRB     r1,[r0,#0x2c]
;;;1238   
;;;1239     c = BUF->seqno[1];
000562  f8900027          LDRB     r0,[r0,#0x27]
000566  49eb              LDR      r1,|L10.2324|
000568  7008              STRB     r0,[r1,#0]
;;;1240     BUF->seqno[1] = BUF->ackno[1];
00056a  48e8              LDR      r0,|L10.2316|
00056c  f890102b          LDRB     r1,[r0,#0x2b]
000570  f8801027          STRB     r1,[r0,#0x27]
;;;1241     BUF->ackno[1] = c;
000574  48e7              LDR      r0,|L10.2324|
000576  7801              LDRB     r1,[r0,#0]  ; c
000578  48e4              LDR      r0,|L10.2316|
00057a  f880102b          STRB     r1,[r0,#0x2b]
;;;1242   
;;;1243     c = BUF->seqno[0];
00057e  f8900026          LDRB     r0,[r0,#0x26]
000582  49e4              LDR      r1,|L10.2324|
000584  7008              STRB     r0,[r1,#0]
;;;1244     BUF->seqno[0] = BUF->ackno[0];
000586  48e1              LDR      r0,|L10.2316|
000588  f890102a          LDRB     r1,[r0,#0x2a]
00058c  f8801026          STRB     r1,[r0,#0x26]
;;;1245     BUF->ackno[0] = c;
000590  48e0              LDR      r0,|L10.2324|
000592  7801              LDRB     r1,[r0,#0]  ; c
000594  48dd              LDR      r0,|L10.2316|
000596  f880102a          STRB     r1,[r0,#0x2a]
;;;1246   
;;;1247     /* We also have to increase the sequence number we are
;;;1248        acknowledging. If the least significant byte overflowed, we need
;;;1249        to propagate the carry to the other bytes as well. */
;;;1250     if(++BUF->ackno[3] == 0) {
00059a  f890002d          LDRB     r0,[r0,#0x2d]
00059e  1c40              ADDS     r0,r0,#1
0005a0  f01001ff          ANDS     r1,r0,#0xff
0005a4  48d9              LDR      r0,|L10.2316|
0005a6  f880102d          STRB     r1,[r0,#0x2d]
0005aa  d118              BNE      |L10.1502|
;;;1251       if(++BUF->ackno[2] == 0) {
0005ac  f890002c          LDRB     r0,[r0,#0x2c]
0005b0  1c40              ADDS     r0,r0,#1
0005b2  f01001ff          ANDS     r1,r0,#0xff
0005b6  48d5              LDR      r0,|L10.2316|
0005b8  f880102c          STRB     r1,[r0,#0x2c]
0005bc  d10f              BNE      |L10.1502|
;;;1252         if(++BUF->ackno[1] == 0) {
0005be  f890002b          LDRB     r0,[r0,#0x2b]
0005c2  1c40              ADDS     r0,r0,#1
0005c4  f01001ff          ANDS     r1,r0,#0xff
0005c8  48d0              LDR      r0,|L10.2316|
0005ca  f880102b          STRB     r1,[r0,#0x2b]
0005ce  d106              BNE      |L10.1502|
;;;1253   	++BUF->ackno[0];
0005d0  f890002a          LDRB     r0,[r0,#0x2a]
0005d4  1c40              ADDS     r0,r0,#1
0005d6  b2c1              UXTB     r1,r0
0005d8  48cc              LDR      r0,|L10.2316|
0005da  f880102a          STRB     r1,[r0,#0x2a]
                  |L10.1502|
;;;1254         }
;;;1255       }
;;;1256     }
;;;1257   
;;;1258     /* Swap port numbers. */
;;;1259     tmp16 = BUF->srcport;
0005de  48cb              LDR      r0,|L10.2316|
0005e0  8c40              LDRH     r0,[r0,#0x22]
0005e2  49cc              LDR      r1,|L10.2324|
0005e4  1c89              ADDS     r1,r1,#2
0005e6  8008              STRH     r0,[r1,#0]
;;;1260     BUF->srcport = BUF->destport;
0005e8  48c8              LDR      r0,|L10.2316|
0005ea  8c81              LDRH     r1,[r0,#0x24]
0005ec  8441              STRH     r1,[r0,#0x22]
;;;1261     BUF->destport = tmp16;
0005ee  48c9              LDR      r0,|L10.2324|
0005f0  1c80              ADDS     r0,r0,#2
0005f2  8801              LDRH     r1,[r0,#0]  ; tmp16
0005f4  48c5              LDR      r0,|L10.2316|
0005f6  8481              STRH     r1,[r0,#0x24]
;;;1262   
;;;1263     /* Swap IP addresses. */
;;;1264     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
0005f8  bf00              NOP      
0005fa  8b41              LDRH     r1,[r0,#0x1a]
0005fc  83c1              STRH     r1,[r0,#0x1e]
0005fe  8b81              LDRH     r1,[r0,#0x1c]
000600  8401              STRH     r1,[r0,#0x20]
000602  bf00              NOP      
;;;1265     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000604  bf00              NOP      
000606  48c4              LDR      r0,|L10.2328|
000608  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
00060a  48c0              LDR      r0,|L10.2316|
00060c  8341              STRH     r1,[r0,#0x1a]
00060e  48c2              LDR      r0,|L10.2328|
000610  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
000612  48be              LDR      r0,|L10.2316|
000614  8381              STRH     r1,[r0,#0x1c]
000616  bf00              NOP      
;;;1266   
;;;1267     /* And send out the RST packet! */
;;;1268     goto tcp_send_noconn;
000618  e3f0              B        |L10.3580|
                  |L10.1562|
;;;1269   
;;;1270     /* This label will be jumped to if we matched the incoming packet
;;;1271        with a connection in LISTEN. In that case, we should create a new
;;;1272        connection and send a SYNACK in return. */
;;;1273    found_listen:
;;;1274     /* First we check if there are any connections avaliable. Unused
;;;1275        connections are kept in the same table as used connections, but
;;;1276        unused ones have the tcpstate set to CLOSED. Also, connections in
;;;1277        TIME_WAIT are kept track of and we'll use the oldest one if no
;;;1278        CLOSED connections are found. Thanks to Eddie C. Dost for a very
;;;1279        nice algorithm for the TIME_WAIT search. */
;;;1280     uip_connr = 0;
00061a  2400              MOVS     r4,#0
;;;1281     for(c = 0; c < UIP_CONNS; ++c) {
00061c  2000              MOVS     r0,#0
00061e  49bd              LDR      r1,|L10.2324|
000620  7008              STRB     r0,[r1,#0]
000622  e030              B        |L10.1670|
                  |L10.1572|
;;;1282       if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
000624  48bb              LDR      r0,|L10.2324|
000626  7800              LDRB     r0,[r0,#0]  ; c
000628  eb000080          ADD      r0,r0,r0,LSL #2
00062c  49bb              LDR      r1,|L10.2332|
00062e  eb0100c0          ADD      r0,r1,r0,LSL #3
000632  7e40              LDRB     r0,[r0,#0x19]
000634  b930              CBNZ     r0,|L10.1604|
;;;1283         uip_connr = &uip_conns[c];
000636  48b7              LDR      r0,|L10.2324|
000638  7800              LDRB     r0,[r0,#0]  ; c
00063a  eb000080          ADD      r0,r0,r0,LSL #2
00063e  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;1284         break;
000642  e024              B        |L10.1678|
                  |L10.1604|
;;;1285       }
;;;1286       if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
000644  48b3              LDR      r0,|L10.2324|
000646  7800              LDRB     r0,[r0,#0]  ; c
000648  eb000080          ADD      r0,r0,r0,LSL #2
00064c  49b3              LDR      r1,|L10.2332|
00064e  eb0100c0          ADD      r0,r1,r0,LSL #3
000652  7e40              LDRB     r0,[r0,#0x19]
000654  2807              CMP      r0,#7
000656  d111              BNE      |L10.1660|
;;;1287         if(uip_connr == 0 ||
000658  b14c              CBZ      r4,|L10.1646|
;;;1288   	 uip_conns[c].timer > uip_connr->timer) {
00065a  48ae              LDR      r0,|L10.2324|
00065c  7800              LDRB     r0,[r0,#0]  ; c
00065e  eb000080          ADD      r0,r0,r0,LSL #2
000662  eb0100c0          ADD      r0,r1,r0,LSL #3
000666  7e80              LDRB     r0,[r0,#0x1a]
000668  7ea1              LDRB     r1,[r4,#0x1a]
00066a  4288              CMP      r0,r1
00066c  dd06              BLE      |L10.1660|
                  |L10.1646|
;;;1289   	uip_connr = &uip_conns[c];
00066e  48a9              LDR      r0,|L10.2324|
000670  7800              LDRB     r0,[r0,#0]  ; c
000672  eb000080          ADD      r0,r0,r0,LSL #2
000676  49a9              LDR      r1,|L10.2332|
000678  eb0104c0          ADD      r4,r1,r0,LSL #3
                  |L10.1660|
00067c  48a5              LDR      r0,|L10.2324|
00067e  7800              LDRB     r0,[r0,#0]            ;1281  ; c
000680  1c40              ADDS     r0,r0,#1              ;1281
000682  49a4              LDR      r1,|L10.2324|
000684  7008              STRB     r0,[r1,#0]            ;1281
                  |L10.1670|
000686  48a3              LDR      r0,|L10.2324|
000688  7800              LDRB     r0,[r0,#0]            ;1281  ; c
00068a  2828              CMP      r0,#0x28              ;1281
00068c  dbca              BLT      |L10.1572|
                  |L10.1678|
00068e  bf00              NOP                            ;1284
;;;1290         }
;;;1291       }
;;;1292     }
;;;1293   
;;;1294     if(uip_connr == 0) {
000690  b94c              CBNZ     r4,|L10.1702|
;;;1295       /* All connections are used already, we drop packet and hope that
;;;1296          the remote end will retransmit the packet at a time when we
;;;1297          have more spare connections. */
;;;1298       UIP_STAT(++uip_stat.tcp.syndrop);
000692  489d              LDR      r0,|L10.2312|
000694  8d00              LDRH     r0,[r0,#0x28]
000696  1c40              ADDS     r0,r0,#1
000698  b281              UXTH     r1,r0
00069a  489b              LDR      r0,|L10.2312|
00069c  8501              STRH     r1,[r0,#0x28]
;;;1299       UIP_LOG("tcp: found no unused connections.");
00069e  a0a0              ADR      r0,|L10.2336|
0006a0  f7fffffe          BL       uip_log
;;;1300       goto drop;
0006a4  e4c4              B        |L10.48|
                  |L10.1702|
;;;1301     }
;;;1302     uip_conn = uip_connr;
0006a6  48a7              LDR      r0,|L10.2372|
0006a8  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1303   
;;;1304     /* Fill in the necessary fields for the new connection. */
;;;1305     uip_connr->rto = uip_connr->timer = UIP_RTO;
0006aa  2003              MOVS     r0,#3
0006ac  76a0              STRB     r0,[r4,#0x1a]
0006ae  7620              STRB     r0,[r4,#0x18]
;;;1306     uip_connr->sa = 0;
0006b0  2000              MOVS     r0,#0
0006b2  75a0              STRB     r0,[r4,#0x16]
;;;1307     uip_connr->sv = 4;
0006b4  2004              MOVS     r0,#4
0006b6  75e0              STRB     r0,[r4,#0x17]
;;;1308     uip_connr->nrtx = 0;
0006b8  2000              MOVS     r0,#0
0006ba  76e0              STRB     r0,[r4,#0x1b]
;;;1309     uip_connr->lport = BUF->destport;
0006bc  4893              LDR      r0,|L10.2316|
0006be  8c80              LDRH     r0,[r0,#0x24]
0006c0  80a0              STRH     r0,[r4,#4]
;;;1310     uip_connr->rport = BUF->srcport;
0006c2  4892              LDR      r0,|L10.2316|
0006c4  8c40              LDRH     r0,[r0,#0x22]
0006c6  80e0              STRH     r0,[r4,#6]
;;;1311     uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
0006c8  bf00              NOP      
0006ca  4890              LDR      r0,|L10.2316|
0006cc  8b40              LDRH     r0,[r0,#0x1a]
0006ce  8020              STRH     r0,[r4,#0]
0006d0  488e              LDR      r0,|L10.2316|
0006d2  8b80              LDRH     r0,[r0,#0x1c]
0006d4  8060              STRH     r0,[r4,#2]
0006d6  bf00              NOP      
;;;1312     uip_connr->tcpstateflags = UIP_SYN_RCVD;
0006d8  2001              MOVS     r0,#1
0006da  7660              STRB     r0,[r4,#0x19]
;;;1313   
;;;1314     uip_connr->snd_nxt[0] = iss[0];
0006dc  488d              LDR      r0,|L10.2324|
0006de  380a              SUBS     r0,r0,#0xa
0006e0  7800              LDRB     r0,[r0,#0]  ; iss
0006e2  7320              STRB     r0,[r4,#0xc]
;;;1315     uip_connr->snd_nxt[1] = iss[1];
0006e4  488b              LDR      r0,|L10.2324|
0006e6  380a              SUBS     r0,r0,#0xa
0006e8  7841              LDRB     r1,[r0,#1]  ; iss
0006ea  7361              STRB     r1,[r4,#0xd]
;;;1316     uip_connr->snd_nxt[2] = iss[2];
0006ec  7881              LDRB     r1,[r0,#2]  ; iss
0006ee  73a1              STRB     r1,[r4,#0xe]
;;;1317     uip_connr->snd_nxt[3] = iss[3];
0006f0  78c1              LDRB     r1,[r0,#3]  ; iss
0006f2  73e1              STRB     r1,[r4,#0xf]
;;;1318     uip_connr->len = 1;
0006f4  2001              MOVS     r0,#1
0006f6  8220              STRH     r0,[r4,#0x10]
;;;1319   
;;;1320     /* rcv_nxt should be the seqno from the incoming packet + 1. */
;;;1321     uip_connr->rcv_nxt[3] = BUF->seqno[3];
0006f8  4884              LDR      r0,|L10.2316|
0006fa  f8901029          LDRB     r1,[r0,#0x29]
0006fe  72e1              STRB     r1,[r4,#0xb]
;;;1322     uip_connr->rcv_nxt[2] = BUF->seqno[2];
000700  f8901028          LDRB     r1,[r0,#0x28]
000704  72a1              STRB     r1,[r4,#0xa]
;;;1323     uip_connr->rcv_nxt[1] = BUF->seqno[1];
000706  f8901027          LDRB     r1,[r0,#0x27]
00070a  7261              STRB     r1,[r4,#9]
;;;1324     uip_connr->rcv_nxt[0] = BUF->seqno[0];
00070c  f8900026          LDRB     r0,[r0,#0x26]
000710  7220              STRB     r0,[r4,#8]
;;;1325     uip_add_rcv_nxt(1);
000712  2001              MOVS     r0,#1
000714  f7fffffe          BL       uip_add_rcv_nxt
;;;1326   
;;;1327     /* Parse the TCP MSS option, if present. */
;;;1328     if((BUF->tcpoffset & 0xf0) > 0x50) {
000718  487c              LDR      r0,|L10.2316|
00071a  f890002e          LDRB     r0,[r0,#0x2e]
00071e  f00000f0          AND      r0,r0,#0xf0
000722  2850              CMP      r0,#0x50
000724  dd60              BLE      |L10.2024|
;;;1329       for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
000726  2000              MOVS     r0,#0
000728  497a              LDR      r1,|L10.2324|
00072a  7008              STRB     r0,[r1,#0]
00072c  e050              B        |L10.2000|
                  |L10.1838|
;;;1330         opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
00072e  4879              LDR      r0,|L10.2324|
000730  7800              LDRB     r0,[r0,#0]  ; c
000732  3036              ADDS     r0,r0,#0x36
000734  4975              LDR      r1,|L10.2316|
000736  5c08              LDRB     r0,[r1,r0]
000738  4976              LDR      r1,|L10.2324|
00073a  1c49              ADDS     r1,r1,#1
00073c  7008              STRB     r0,[r1,#0]
;;;1331         if(opt == TCP_OPT_END) {
00073e  4608              MOV      r0,r1
000740  7800              LDRB     r0,[r0,#0]  ; opt
000742  b900              CBNZ     r0,|L10.1862|
;;;1332   	/* End of options. */
;;;1333   	break;
000744  e04f              B        |L10.2022|
                  |L10.1862|
;;;1334         } else if(opt == TCP_OPT_NOOP) {
000746  4873              LDR      r0,|L10.2324|
000748  1c40              ADDS     r0,r0,#1
00074a  7800              LDRB     r0,[r0,#0]  ; opt
00074c  2801              CMP      r0,#1
00074e  d105              BNE      |L10.1884|
;;;1335   	++c;
000750  4870              LDR      r0,|L10.2324|
000752  7800              LDRB     r0,[r0,#0]  ; c
000754  1c40              ADDS     r0,r0,#1
000756  496f              LDR      r1,|L10.2324|
000758  7008              STRB     r0,[r1,#0]
00075a  e039              B        |L10.2000|
                  |L10.1884|
;;;1336   	/* NOP option. */
;;;1337         } else if(opt == TCP_OPT_MSS &&
00075c  486d              LDR      r0,|L10.2324|
00075e  1c40              ADDS     r0,r0,#1
000760  7800              LDRB     r0,[r0,#0]  ; opt
000762  2802              CMP      r0,#2
000764  d123              BNE      |L10.1966|
;;;1338   		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
000766  486b              LDR      r0,|L10.2324|
000768  7800              LDRB     r0,[r0,#0]  ; c
00076a  3037              ADDS     r0,r0,#0x37
00076c  4967              LDR      r1,|L10.2316|
00076e  5c08              LDRB     r0,[r1,r0]
000770  2804              CMP      r0,#4
000772  d11c              BNE      |L10.1966|
;;;1339   	/* An MSS option with the right option length. */
;;;1340   	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
000774  4867              LDR      r0,|L10.2324|
000776  7800              LDRB     r0,[r0,#0]  ; c
000778  3039              ADDS     r0,r0,#0x39
00077a  5c09              LDRB     r1,[r1,r0]
00077c  4865              LDR      r0,|L10.2324|
00077e  7800              LDRB     r0,[r0,#0]  ; c
000780  3038              ADDS     r0,r0,#0x38
000782  4a62              LDR      r2,|L10.2316|
000784  5c10              LDRB     r0,[r2,r0]
000786  ea412000          ORR      r0,r1,r0,LSL #8
00078a  4962              LDR      r1,|L10.2324|
00078c  1c89              ADDS     r1,r1,#2
00078e  8008              STRH     r0,[r1,#0]
;;;1341   	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
;;;1342   	uip_connr->initialmss = uip_connr->mss =
000790  4608              MOV      r0,r1
000792  8800              LDRH     r0,[r0,#0]  ; tmp16
000794  f64071ca          MOV      r1,#0xfca
000798  4288              CMP      r0,r1
00079a  dd01              BLE      |L10.1952|
;;;1343   	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
00079c  4608              MOV      r0,r1
00079e  e002              B        |L10.1958|
                  |L10.1952|
0007a0  485c              LDR      r0,|L10.2324|
0007a2  1c80              ADDS     r0,r0,#2
0007a4  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.1958|
0007a6  b280              UXTH     r0,r0
0007a8  8260              STRH     r0,[r4,#0x12]
0007aa  82a0              STRH     r0,[r4,#0x14]
;;;1344   
;;;1345   	/* And we are done processing options. */
;;;1346   	break;
0007ac  e01b              B        |L10.2022|
                  |L10.1966|
;;;1347         } else {
;;;1348   	/* All other options have a length field, so that we easily
;;;1349   	   can skip past them. */
;;;1350   	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
0007ae  4859              LDR      r0,|L10.2324|
0007b0  7800              LDRB     r0,[r0,#0]  ; c
0007b2  3037              ADDS     r0,r0,#0x37
0007b4  4955              LDR      r1,|L10.2316|
0007b6  5c08              LDRB     r0,[r1,r0]
0007b8  b900              CBNZ     r0,|L10.1980|
;;;1351   	  /* If the length field is zero, the options are malformed
;;;1352   	     and we don't process them further. */
;;;1353   	  break;
0007ba  e014              B        |L10.2022|
                  |L10.1980|
;;;1354   	}
;;;1355   	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
0007bc  4855              LDR      r0,|L10.2324|
0007be  7800              LDRB     r0,[r0,#0]  ; c
0007c0  3037              ADDS     r0,r0,#0x37
0007c2  4952              LDR      r1,|L10.2316|
0007c4  5c08              LDRB     r0,[r1,r0]
0007c6  4953              LDR      r1,|L10.2324|
0007c8  7809              LDRB     r1,[r1,#0]  ; c
0007ca  4408              ADD      r0,r0,r1
0007cc  4951              LDR      r1,|L10.2324|
0007ce  7008              STRB     r0,[r1,#0]
                  |L10.2000|
0007d0  484e              LDR      r0,|L10.2316|
0007d2  f890002e          LDRB     r0,[r0,#0x2e]         ;1329
0007d6  2105              MOVS     r1,#5                 ;1329
0007d8  ebc11020          RSB      r0,r1,r0,ASR #4       ;1329
0007dc  494d              LDR      r1,|L10.2324|
0007de  7809              LDRB     r1,[r1,#0]            ;1329  ; c
0007e0  ebb10f80          CMP      r1,r0,LSL #2          ;1329
0007e4  dba3              BLT      |L10.1838|
                  |L10.2022|
0007e6  bf00              NOP                            ;1333
                  |L10.2024|
;;;1356         }
;;;1357       }
;;;1358     }
;;;1359   
;;;1360     /* Our response will be a SYNACK. */
;;;1361   #if UIP_ACTIVE_OPEN
;;;1362    tcp_send_synack:
0007e8  bf00              NOP      
                  |L10.2026|
;;;1363     BUF->flags = TCP_ACK;
0007ea  2110              MOVS     r1,#0x10
0007ec  4847              LDR      r0,|L10.2316|
0007ee  f880102f          STRB     r1,[r0,#0x2f]
;;;1364   
;;;1365    tcp_send_syn:
0007f2  bf00              NOP      
                  |L10.2036|
;;;1366     BUF->flags |= TCP_SYN;
0007f4  4845              LDR      r0,|L10.2316|
0007f6  f890002f          LDRB     r0,[r0,#0x2f]
0007fa  f0400102          ORR      r1,r0,#2
0007fe  4843              LDR      r0,|L10.2316|
000800  f880102f          STRB     r1,[r0,#0x2f]
;;;1367   #else /* UIP_ACTIVE_OPEN */
;;;1368    tcp_send_synack:
;;;1369     BUF->flags = TCP_SYN | TCP_ACK;
;;;1370   #endif /* UIP_ACTIVE_OPEN */
;;;1371   
;;;1372     /* We send out the TCP Maximum Segment Size option with our
;;;1373        SYNACK. */
;;;1374     BUF->optdata[0] = TCP_OPT_MSS;
000804  2102              MOVS     r1,#2
000806  f8801036          STRB     r1,[r0,#0x36]
;;;1375     BUF->optdata[1] = TCP_OPT_MSS_LEN;
00080a  2104              MOVS     r1,#4
00080c  f8801037          STRB     r1,[r0,#0x37]
;;;1376     BUF->optdata[2] = (UIP_TCP_MSS) / 256;
000810  210f              MOVS     r1,#0xf
000812  f8801038          STRB     r1,[r0,#0x38]
;;;1377     BUF->optdata[3] = (UIP_TCP_MSS) & 255;
000816  21ca              MOVS     r1,#0xca
000818  f8801039          STRB     r1,[r0,#0x39]
;;;1378     uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
00081c  202c              MOVS     r0,#0x2c
00081e  493c              LDR      r1,|L10.2320|
000820  8008              STRH     r0,[r1,#0]
;;;1379     BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
000822  2160              MOVS     r1,#0x60
000824  4839              LDR      r0,|L10.2316|
000826  f880102e          STRB     r1,[r0,#0x2e]
;;;1380     goto tcp_send;
00082a  e334              B        |L10.3734|
                  |L10.2092|
00082c  e240              B        |L10.3248|
                  |L10.2094|
;;;1381   
;;;1382     /* This label will be jumped to if we found an active connection. */
;;;1383    found:
;;;1384     uip_conn = uip_connr;
00082e  4845              LDR      r0,|L10.2372|
000830  6004              STR      r4,[r0,#0]  ; uip_conn
;;;1385     uip_flags = 0;
000832  2000              MOVS     r0,#0
000834  4944              LDR      r1,|L10.2376|
000836  7008              STRB     r0,[r1,#0]
;;;1386     /* We do a very naive form of TCP reset processing; we just accept
;;;1387        any RST and kill our connection. We should in fact check if the
;;;1388        sequence number of this reset is wihtin our advertised window
;;;1389        before we accept the reset. */
;;;1390     if(BUF->flags & TCP_RST) {
000838  4834              LDR      r0,|L10.2316|
00083a  f890002f          LDRB     r0,[r0,#0x2f]
00083e  f0100f04          TST      r0,#4
000842  d00a              BEQ      |L10.2138|
;;;1391       uip_connr->tcpstateflags = UIP_CLOSED;
000844  2000              MOVS     r0,#0
000846  7660              STRB     r0,[r4,#0x19]
;;;1392       UIP_LOG("tcp: got reset, aborting connection.");
000848  a040              ADR      r0,|L10.2380|
00084a  f7fffffe          BL       uip_log
;;;1393       uip_flags = UIP_ABORT;
00084e  2020              MOVS     r0,#0x20
000850  493d              LDR      r1,|L10.2376|
000852  7008              STRB     r0,[r1,#0]
;;;1394       UIP_APPCALL();
000854  f7fffffe          BL       tcp_server_appcall
;;;1395       goto drop;
000858  e3a7              B        |L10.4010|
                  |L10.2138|
;;;1396     }
;;;1397     /* Calculated the length of the data, if the application has sent
;;;1398        any data to us. */
;;;1399     c = (BUF->tcpoffset >> 4) << 2;
00085a  482c              LDR      r0,|L10.2316|
00085c  f890002e          LDRB     r0,[r0,#0x2e]
000860  1100              ASRS     r0,r0,#4
000862  0080              LSLS     r0,r0,#2
000864  492b              LDR      r1,|L10.2324|
000866  7008              STRB     r0,[r1,#0]
;;;1400     /* uip_len will contain the length of the actual TCP data. This is
;;;1401        calculated by subtracing the length of the TCP header (in
;;;1402        c) and the length of the IP header (20 bytes). */
;;;1403     uip_len = uip_len - c - UIP_IPH_LEN;
000868  4829              LDR      r0,|L10.2320|
00086a  8800              LDRH     r0,[r0,#0]  ; uip_len
00086c  7809              LDRB     r1,[r1,#0]  ; c
00086e  1a40              SUBS     r0,r0,r1
000870  3814              SUBS     r0,r0,#0x14
000872  4927              LDR      r1,|L10.2320|
000874  8008              STRH     r0,[r1,#0]
;;;1404   
;;;1405     /* First, check if the sequence number of the incoming packet is
;;;1406        what we're expecting next. If not, we send out an ACK with the
;;;1407        correct numbers in. */
;;;1408     if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
000876  7e60              LDRB     r0,[r4,#0x19]
000878  f000000f          AND      r0,r0,#0xf
00087c  2802              CMP      r0,#2
00087e  d106              BNE      |L10.2190|
000880  4822              LDR      r0,|L10.2316|
000882  f890002f          LDRB     r0,[r0,#0x2f]
000886  f000003f          AND      r0,r0,#0x3f
00088a  2812              CMP      r0,#0x12
00088c  d022              BEQ      |L10.2260|
                  |L10.2190|
;;;1409          ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
;;;1410       if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
00088e  4820              LDR      r0,|L10.2320|
000890  8800              LDRH     r0,[r0,#0]  ; uip_len
000892  2800              CMP      r0,#0
000894  dc05              BGT      |L10.2210|
000896  481d              LDR      r0,|L10.2316|
000898  f890002f          LDRB     r0,[r0,#0x2f]
00089c  f0100f03          TST      r0,#3
0008a0  d018              BEQ      |L10.2260|
                  |L10.2210|
;;;1411          (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
0008a2  481a              LDR      r0,|L10.2316|
0008a4  f8900026          LDRB     r0,[r0,#0x26]
0008a8  7a21              LDRB     r1,[r4,#8]
0008aa  4288              CMP      r0,r1
0008ac  d111              BNE      |L10.2258|
;;;1412   	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
0008ae  4817              LDR      r0,|L10.2316|
0008b0  f8901027          LDRB     r1,[r0,#0x27]
0008b4  7a60              LDRB     r0,[r4,#9]
0008b6  4281              CMP      r1,r0
0008b8  d10b              BNE      |L10.2258|
;;;1413   	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
0008ba  4814              LDR      r0,|L10.2316|
0008bc  f8901028          LDRB     r1,[r0,#0x28]
0008c0  7aa0              LDRB     r0,[r4,#0xa]
0008c2  4281              CMP      r1,r0
0008c4  d105              BNE      |L10.2258|
;;;1414   	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
0008c6  4811              LDR      r0,|L10.2316|
0008c8  f8901029          LDRB     r1,[r0,#0x29]
0008cc  7ae0              LDRB     r0,[r4,#0xb]
0008ce  4281              CMP      r1,r0
0008d0  d000              BEQ      |L10.2260|
                  |L10.2258|
;;;1415         goto tcp_send_ack;
0008d2  e2d2              B        |L10.3706|
                  |L10.2260|
;;;1416       }
;;;1417     }
;;;1418   
;;;1419     /* Next, check if the incoming segment acknowledges any outstanding
;;;1420        data. If so, we update the sequence number, reset the length of
;;;1421        the outstanding data, calculate RTT estimations, and reset the
;;;1422        retransmission timer. */
;;;1423     if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
0008d4  480d              LDR      r0,|L10.2316|
0008d6  f890002f          LDRB     r0,[r0,#0x2f]
0008da  f0100f10          TST      r0,#0x10
0008de  d07e              BEQ      |L10.2526|
0008e0  8a20              LDRH     r0,[r4,#0x10]
0008e2  2800              CMP      r0,#0
0008e4  d07b              BEQ      |L10.2526|
;;;1424       uip_add32(uip_connr->snd_nxt, uip_connr->len);
0008e6  8a21              LDRH     r1,[r4,#0x10]
0008e8  f104000c          ADD      r0,r4,#0xc
0008ec  f7fffffe          BL       uip_add32
;;;1425   
;;;1426       if(BUF->ackno[0] == uip_acc32[0] &&
0008f0  4806              LDR      r0,|L10.2316|
0008f2  f890002a          LDRB     r0,[r0,#0x2a]
0008f6  491f              LDR      r1,|L10.2420|
0008f8  7809              LDRB     r1,[r1,#0]  ; uip_acc32
0008fa  4288              CMP      r0,r1
0008fc  d16f              BNE      |L10.2526|
;;;1427          BUF->ackno[1] == uip_acc32[1] &&
0008fe  4803              LDR      r0,|L10.2316|
000900  e03a              B        |L10.2424|
                  |L10.2306|
000902  e215              B        |L10.3376|
                  |L10.2308|
000904  e175              B        |L10.3058|
000906  0000              DCW      0x0000
                  |L10.2312|
                          DCD      uip_stat
                  |L10.2316|
                          DCD      uip_buf
                  |L10.2320|
                          DCD      uip_len
                  |L10.2324|
                          DCD      ||.data||+0x34
                  |L10.2328|
                          DCD      uip_hostaddr
                  |L10.2332|
                          DCD      uip_conns
                  |L10.2336|
000920  7463703a20666f756e64206e6f20756e7573656420636f6e6e656374696f6e732e00        DCB      "tcp: found no unused connections.",0
000942  00                DCB      0
000943  00                DCB      0
                  |L10.2372|
                          DCD      uip_conn
                  |L10.2376|
                          DCD      uip_flags
                  |L10.2380|
00094c  7463703a20676f742072657365742c2061626f7274696e6720636f6e6e656374696f6e2e00        DCB      "tcp: got reset, aborting connection.",0
000971  00                DCB      0
000972  00                DCB      0
000973  00                DCB      0
                  |L10.2420|
                          DCD      uip_acc32
                  |L10.2424|
000978  f890002b          LDRB     r0,[r0,#0x2b]
00097c  49fd              LDR      r1,|L10.3444|
00097e  7849              LDRB     r1,[r1,#1]  ; uip_acc32
000980  4288              CMP      r0,r1
000982  d13e              BNE      |L10.2562|
;;;1428          BUF->ackno[2] == uip_acc32[2] &&
000984  48fc              LDR      r0,|L10.3448|
000986  f890002c          LDRB     r0,[r0,#0x2c]
00098a  49fa              LDR      r1,|L10.3444|
00098c  7889              LDRB     r1,[r1,#2]  ; uip_acc32
00098e  4288              CMP      r0,r1
000990  d137              BNE      |L10.2562|
;;;1429          BUF->ackno[3] == uip_acc32[3]) {
000992  48f9              LDR      r0,|L10.3448|
000994  f890002d          LDRB     r0,[r0,#0x2d]
000998  49f6              LDR      r1,|L10.3444|
00099a  78c9              LDRB     r1,[r1,#3]  ; uip_acc32
00099c  4288              CMP      r0,r1
00099e  d130              BNE      |L10.2562|
;;;1430         /* Update sequence number. */
;;;1431         uip_connr->snd_nxt[0] = uip_acc32[0];
0009a0  48f4              LDR      r0,|L10.3444|
0009a2  7800              LDRB     r0,[r0,#0]  ; uip_acc32
0009a4  7320              STRB     r0,[r4,#0xc]
;;;1432         uip_connr->snd_nxt[1] = uip_acc32[1];
0009a6  48f3              LDR      r0,|L10.3444|
0009a8  7841              LDRB     r1,[r0,#1]  ; uip_acc32
0009aa  7361              STRB     r1,[r4,#0xd]
;;;1433         uip_connr->snd_nxt[2] = uip_acc32[2];
0009ac  7881              LDRB     r1,[r0,#2]  ; uip_acc32
0009ae  73a1              STRB     r1,[r4,#0xe]
;;;1434         uip_connr->snd_nxt[3] = uip_acc32[3];
0009b0  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
0009b2  73e1              STRB     r1,[r4,#0xf]
;;;1435   
;;;1436   
;;;1437         /* Do RTT estimation, unless we have done retransmissions. */
;;;1438         if(uip_connr->nrtx == 0) {
0009b4  7ee0              LDRB     r0,[r4,#0x1b]
0009b6  b9e8              CBNZ     r0,|L10.2548|
;;;1439   	signed char m;
;;;1440   	m = uip_connr->rto - uip_connr->timer;
0009b8  7e21              LDRB     r1,[r4,#0x18]
0009ba  7ea2              LDRB     r2,[r4,#0x1a]
0009bc  1a89              SUBS     r1,r1,r2
0009be  b248              SXTB     r0,r1
;;;1441   	/* This is taken directly from VJs original code in his paper */
;;;1442   	m = m - (uip_connr->sa >> 3);
0009c0  7da1              LDRB     r1,[r4,#0x16]
0009c2  eba001e1          SUB      r1,r0,r1,ASR #3
0009c6  b248              SXTB     r0,r1
;;;1443   	uip_connr->sa += m;
0009c8  7da1              LDRB     r1,[r4,#0x16]
0009ca  4401              ADD      r1,r1,r0
0009cc  75a1              STRB     r1,[r4,#0x16]
;;;1444   	if(m < 0) {
0009ce  2800              CMP      r0,#0
0009d0  da01              BGE      |L10.2518|
;;;1445   	  m = -m;
0009d2  4241              RSBS     r1,r0,#0
0009d4  b248              SXTB     r0,r1
                  |L10.2518|
;;;1446   	}
;;;1447   	m = m - (uip_connr->sv >> 2);
0009d6  7de1              LDRB     r1,[r4,#0x17]
0009d8  eba001a1          SUB      r1,r0,r1,ASR #2
0009dc  e000              B        |L10.2528|
                  |L10.2526|
0009de  e010              B        |L10.2562|
                  |L10.2528|
0009e0  b248              SXTB     r0,r1
;;;1448   	uip_connr->sv += m;
0009e2  7de1              LDRB     r1,[r4,#0x17]
0009e4  4401              ADD      r1,r1,r0
0009e6  75e1              STRB     r1,[r4,#0x17]
;;;1449   	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
0009e8  7de1              LDRB     r1,[r4,#0x17]
0009ea  7da2              LDRB     r2,[r4,#0x16]
0009ec  eb0101e2          ADD      r1,r1,r2,ASR #3
0009f0  7621              STRB     r1,[r4,#0x18]
;;;1450   
;;;1451         }
0009f2  bf00              NOP      
                  |L10.2548|
;;;1452         /* Set the acknowledged flag. */
;;;1453         uip_flags = UIP_ACKDATA;
0009f4  2001              MOVS     r0,#1
0009f6  49e1              LDR      r1,|L10.3452|
0009f8  7008              STRB     r0,[r1,#0]
;;;1454         /* Reset the retransmission timer. */
;;;1455         uip_connr->timer = uip_connr->rto;
0009fa  7e20              LDRB     r0,[r4,#0x18]
0009fc  76a0              STRB     r0,[r4,#0x1a]
;;;1456   
;;;1457         /* Reset length of outstanding data. */
;;;1458         uip_connr->len = 0;
0009fe  2000              MOVS     r0,#0
000a00  8220              STRH     r0,[r4,#0x10]
                  |L10.2562|
;;;1459       }
;;;1460   
;;;1461     }
;;;1462   
;;;1463     /* Do different things depending on in what state the connection is. */
;;;1464     switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
000a02  7e60              LDRB     r0,[r4,#0x19]
000a04  f000000f          AND      r0,r0,#0xf
000a08  2809              CMP      r0,#9
000a0a  d276              BCS      |L10.2810|
000a0c  e8dff000          TBB      [pc,r0]
000a10  750525c6          DCB      0x75,0x05,0x25,0xc6
000a14  faf9f8f7          DCB      0xfa,0xf9,0xf8,0xf7
000a18  f600              DCB      0xf6,0x00
;;;1465       /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
;;;1466   	implemented, since we force the application to close when the
;;;1467   	peer sends a FIN (hence the application goes directly from
;;;1468   	ESTABLISHED to LAST_ACK). */
;;;1469     case UIP_SYN_RCVD:
;;;1470       /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
;;;1471          we are waiting for an ACK that acknowledges the data we sent
;;;1472          out the last time. Therefore, we want to have the UIP_ACKDATA
;;;1473          flag set. If so, we enter the ESTABLISHED state. */
;;;1474       if(uip_flags & UIP_ACKDATA) {
000a1a  48d8              LDR      r0,|L10.3452|
000a1c  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a1e  f0100f01          TST      r0,#1
000a22  d019              BEQ      |L10.2648|
;;;1475         uip_connr->tcpstateflags = UIP_ESTABLISHED;
000a24  2003              MOVS     r0,#3
000a26  7660              STRB     r0,[r4,#0x19]
;;;1476         uip_flags = UIP_CONNECTED;
000a28  2040              MOVS     r0,#0x40
000a2a  49d4              LDR      r1,|L10.3452|
000a2c  7008              STRB     r0,[r1,#0]
;;;1477         uip_connr->len = 0;
000a2e  2000              MOVS     r0,#0
000a30  8220              STRH     r0,[r4,#0x10]
;;;1478         if(uip_len > 0) {
000a32  48d3              LDR      r0,|L10.3456|
000a34  8800              LDRH     r0,[r0,#0]  ; uip_len
000a36  2800              CMP      r0,#0
000a38  dd08              BLE      |L10.2636|
;;;1479           uip_flags |= UIP_NEWDATA;
000a3a  4608              MOV      r0,r1
000a3c  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a3e  f0400002          ORR      r0,r0,#2
000a42  7008              STRB     r0,[r1,#0]
;;;1480           uip_add_rcv_nxt(uip_len);
000a44  48ce              LDR      r0,|L10.3456|
000a46  8800              LDRH     r0,[r0,#0]  ; uip_len
000a48  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2636|
;;;1481         }
;;;1482         uip_slen = 0;
000a4c  2000              MOVS     r0,#0
000a4e  49cd              LDR      r1,|L10.3460|
000a50  8008              STRH     r0,[r1,#0]
;;;1483         UIP_APPCALL();
000a52  f7fffffe          BL       tcp_server_appcall
;;;1484         goto appsend;
000a56  e12b              B        |L10.3248|
                  |L10.2648|
;;;1485       }
;;;1486       goto drop;
000a58  e2a7              B        |L10.4010|
;;;1487   #if UIP_ACTIVE_OPEN
;;;1488     case UIP_SYN_SENT:
;;;1489       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
;;;1490          our SYN. The rcv_nxt is set to sequence number in the SYNACK
;;;1491          plus one, and we send an ACK. We move into the ESTABLISHED
;;;1492          state. */
;;;1493       if((uip_flags & UIP_ACKDATA) &&
000a5a  48c8              LDR      r0,|L10.3452|
000a5c  7800              LDRB     r0,[r0,#0]  ; uip_flags
000a5e  f0100f01          TST      r0,#1
000a62  d07e              BEQ      |L10.2914|
;;;1494          (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
000a64  48c4              LDR      r0,|L10.3448|
000a66  f890002f          LDRB     r0,[r0,#0x2f]
000a6a  f000003f          AND      r0,r0,#0x3f
000a6e  2812              CMP      r0,#0x12
000a70  d177              BNE      |L10.2914|
;;;1495   
;;;1496         /* Parse the TCP MSS option, if present. */
;;;1497         if((BUF->tcpoffset & 0xf0) > 0x50) {
000a72  48c1              LDR      r0,|L10.3448|
000a74  f890002e          LDRB     r0,[r0,#0x2e]
000a78  f00000f0          AND      r0,r0,#0xf0
000a7c  2850              CMP      r0,#0x50
000a7e  dd62              BLE      |L10.2886|
;;;1498   	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
000a80  2000              MOVS     r0,#0
000a82  49c1              LDR      r1,|L10.3464|
000a84  7008              STRB     r0,[r1,#0]
000a86  e052              B        |L10.2862|
                  |L10.2696|
;;;1499   	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
000a88  48bf              LDR      r0,|L10.3464|
000a8a  7800              LDRB     r0,[r0,#0]  ; c
000a8c  3036              ADDS     r0,r0,#0x36
000a8e  49ba              LDR      r1,|L10.3448|
000a90  5c08              LDRB     r0,[r1,r0]
000a92  49bd              LDR      r1,|L10.3464|
000a94  1c49              ADDS     r1,r1,#1
000a96  7008              STRB     r0,[r1,#0]
;;;1500   	  if(opt == TCP_OPT_END) {
000a98  4608              MOV      r0,r1
000a9a  7800              LDRB     r0,[r0,#0]  ; opt
000a9c  b900              CBNZ     r0,|L10.2720|
;;;1501   	    /* End of options. */
;;;1502   	    break;
000a9e  e051              B        |L10.2884|
                  |L10.2720|
;;;1503   	  } else if(opt == TCP_OPT_NOOP) {
000aa0  48b9              LDR      r0,|L10.3464|
000aa2  1c40              ADDS     r0,r0,#1
000aa4  7800              LDRB     r0,[r0,#0]  ; opt
000aa6  2801              CMP      r0,#1
000aa8  d105              BNE      |L10.2742|
;;;1504   	    ++c;
000aaa  48b7              LDR      r0,|L10.3464|
000aac  7800              LDRB     r0,[r0,#0]  ; c
000aae  1c40              ADDS     r0,r0,#1
000ab0  49b5              LDR      r1,|L10.3464|
000ab2  7008              STRB     r0,[r1,#0]
000ab4  e03b              B        |L10.2862|
                  |L10.2742|
;;;1505   	    /* NOP option. */
;;;1506   	  } else if(opt == TCP_OPT_MSS &&
000ab6  48b4              LDR      r0,|L10.3464|
000ab8  1c40              ADDS     r0,r0,#1
000aba  7800              LDRB     r0,[r0,#0]  ; opt
000abc  2802              CMP      r0,#2
000abe  d125              BNE      |L10.2828|
;;;1507   		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
000ac0  48b1              LDR      r0,|L10.3464|
000ac2  7800              LDRB     r0,[r0,#0]  ; c
000ac4  3037              ADDS     r0,r0,#0x37
000ac6  49ac              LDR      r1,|L10.3448|
000ac8  5c08              LDRB     r0,[r1,r0]
000aca  2804              CMP      r0,#4
000acc  d11e              BNE      |L10.2828|
;;;1508   	    /* An MSS option with the right option length. */
;;;1509   	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
000ace  48ae              LDR      r0,|L10.3464|
000ad0  7800              LDRB     r0,[r0,#0]  ; c
000ad2  3039              ADDS     r0,r0,#0x39
000ad4  5c09              LDRB     r1,[r1,r0]
000ad6  48ac              LDR      r0,|L10.3464|
000ad8  7800              LDRB     r0,[r0,#0]  ; c
000ada  3038              ADDS     r0,r0,#0x38
000adc  4aa6              LDR      r2,|L10.3448|
000ade  5c10              LDRB     r0,[r2,r0]
000ae0  ea412000          ORR      r0,r1,r0,LSL #8
000ae4  49a8              LDR      r1,|L10.3464|
000ae6  1c89              ADDS     r1,r1,#2
000ae8  8008              STRH     r0,[r1,#0]
;;;1510   	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
;;;1511   	    uip_connr->initialmss =
000aea  4608              MOV      r0,r1
000aec  8800              LDRH     r0,[r0,#0]  ; tmp16
000aee  f64071ca          MOV      r1,#0xfca
000af2  4288              CMP      r0,r1
000af4  dd03              BLE      |L10.2814|
;;;1512   	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
000af6  4608              MOV      r0,r1
000af8  e004              B        |L10.2820|
                  |L10.2810|
000afa  e1bc              B        |L10.3702|
                  |L10.2812|
000afc  e24c              B        |L10.3992|
                  |L10.2814|
000afe  48a2              LDR      r0,|L10.3464|
000b00  1c80              ADDS     r0,r0,#2
000b02  8800              LDRH     r0,[r0,#0]  ; tmp16
                  |L10.2820|
000b04  b280              UXTH     r0,r0
000b06  8260              STRH     r0,[r4,#0x12]
000b08  82a0              STRH     r0,[r4,#0x14]
;;;1513   
;;;1514   	    /* And we are done processing options. */
;;;1515   	    break;
000b0a  e01b              B        |L10.2884|
                  |L10.2828|
;;;1516   	  } else {
;;;1517   	    /* All other options have a length field, so that we easily
;;;1518   	       can skip past them. */
;;;1519   	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
000b0c  489e              LDR      r0,|L10.3464|
000b0e  7800              LDRB     r0,[r0,#0]  ; c
000b10  3037              ADDS     r0,r0,#0x37
000b12  4999              LDR      r1,|L10.3448|
000b14  5c08              LDRB     r0,[r1,r0]
000b16  b900              CBNZ     r0,|L10.2842|
;;;1520   	      /* If the length field is zero, the options are malformed
;;;1521   		 and we don't process them further. */
;;;1522   	      break;
000b18  e014              B        |L10.2884|
                  |L10.2842|
;;;1523   	    }
;;;1524   	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
000b1a  489b              LDR      r0,|L10.3464|
000b1c  7800              LDRB     r0,[r0,#0]  ; c
000b1e  3037              ADDS     r0,r0,#0x37
000b20  4995              LDR      r1,|L10.3448|
000b22  5c08              LDRB     r0,[r1,r0]
000b24  4998              LDR      r1,|L10.3464|
000b26  7809              LDRB     r1,[r1,#0]  ; c
000b28  4408              ADD      r0,r0,r1
000b2a  4997              LDR      r1,|L10.3464|
000b2c  7008              STRB     r0,[r1,#0]
                  |L10.2862|
000b2e  4892              LDR      r0,|L10.3448|
000b30  f890002e          LDRB     r0,[r0,#0x2e]         ;1498
000b34  2105              MOVS     r1,#5                 ;1498
000b36  ebc11020          RSB      r0,r1,r0,ASR #4       ;1498
000b3a  4993              LDR      r1,|L10.3464|
000b3c  7809              LDRB     r1,[r1,#0]            ;1498  ; c
000b3e  ebb10f80          CMP      r1,r0,LSL #2          ;1498
000b42  dba1              BLT      |L10.2696|
                  |L10.2884|
000b44  bf00              NOP                            ;1502
                  |L10.2886|
;;;1525   	  }
;;;1526   	}
;;;1527         }
;;;1528         uip_connr->tcpstateflags = UIP_ESTABLISHED;
000b46  2003              MOVS     r0,#3
000b48  7660              STRB     r0,[r4,#0x19]
;;;1529         uip_connr->rcv_nxt[0] = BUF->seqno[0];
000b4a  488b              LDR      r0,|L10.3448|
000b4c  f8900026          LDRB     r0,[r0,#0x26]
000b50  7220              STRB     r0,[r4,#8]
;;;1530         uip_connr->rcv_nxt[1] = BUF->seqno[1];
000b52  4889              LDR      r0,|L10.3448|
000b54  f8901027          LDRB     r1,[r0,#0x27]
000b58  7261              STRB     r1,[r4,#9]
;;;1531         uip_connr->rcv_nxt[2] = BUF->seqno[2];
000b5a  f8901028          LDRB     r1,[r0,#0x28]
000b5e  72a1              STRB     r1,[r4,#0xa]
;;;1532         uip_connr->rcv_nxt[3] = BUF->seqno[3];
000b60  e000              B        |L10.2916|
                  |L10.2914|
000b62  e011              B        |L10.2952|
                  |L10.2916|
000b64  f8901029          LDRB     r1,[r0,#0x29]
000b68  72e1              STRB     r1,[r4,#0xb]
;;;1533         uip_add_rcv_nxt(1);
000b6a  2001              MOVS     r0,#1
000b6c  f7fffffe          BL       uip_add_rcv_nxt
;;;1534         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
000b70  2042              MOVS     r0,#0x42
000b72  4982              LDR      r1,|L10.3452|
000b74  7008              STRB     r0,[r1,#0]
;;;1535         uip_connr->len = 0;
000b76  2000              MOVS     r0,#0
000b78  8220              STRH     r0,[r4,#0x10]
;;;1536         uip_len = 0;
000b7a  4981              LDR      r1,|L10.3456|
000b7c  8008              STRH     r0,[r1,#0]
;;;1537         uip_slen = 0;
000b7e  4981              LDR      r1,|L10.3460|
000b80  8008              STRH     r0,[r1,#0]
;;;1538         UIP_APPCALL();
000b82  f7fffffe          BL       tcp_server_appcall
;;;1539         goto appsend;
000b86  e093              B        |L10.3248|
                  |L10.2952|
;;;1540       }
;;;1541       /* Inform the application that the connection failed */
;;;1542       uip_flags = UIP_ABORT;
000b88  2020              MOVS     r0,#0x20
000b8a  497c              LDR      r1,|L10.3452|
000b8c  7008              STRB     r0,[r1,#0]
;;;1543       UIP_APPCALL();
000b8e  f7fffffe          BL       tcp_server_appcall
;;;1544       /* The connection is closed after we send the RST */
;;;1545       uip_conn->tcpstateflags = UIP_CLOSED;
000b92  2000              MOVS     r0,#0
000b94  497d              LDR      r1,|L10.3468|
000b96  6809              LDR      r1,[r1,#0]  ; uip_conn
000b98  7648              STRB     r0,[r1,#0x19]
;;;1546       goto reset;
000b9a  e429              B        |L10.1008|
;;;1547   #endif /* UIP_ACTIVE_OPEN */
;;;1548   
;;;1549     case UIP_ESTABLISHED:
;;;1550       /* In the ESTABLISHED state, we call upon the application to feed
;;;1551       data into the uip_buf. If the UIP_ACKDATA flag is set, the
;;;1552       application should put new data into the buffer, otherwise we are
;;;1553       retransmitting an old segment, and the application should put that
;;;1554       data into the buffer.
;;;1555   
;;;1556       If the incoming packet is a FIN, we should close the connection on
;;;1557       this side as well, and we send out a FIN and enter the LAST_ACK
;;;1558       state. We require that there is no outstanding data; otherwise the
;;;1559       sequence numbers will be screwed up. */
;;;1560   
;;;1561       if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
000b9c  4876              LDR      r0,|L10.3448|
000b9e  f890002f          LDRB     r0,[r0,#0x2f]
000ba2  f0100f01          TST      r0,#1
000ba6  d02e              BEQ      |L10.3078|
000ba8  7e60              LDRB     r0,[r4,#0x19]
000baa  f0100f10          TST      r0,#0x10
000bae  d12a              BNE      |L10.3078|
;;;1562         if(uip_outstanding(uip_connr)) {
000bb0  8a20              LDRH     r0,[r4,#0x10]
000bb2  b100              CBZ      r0,|L10.2998|
;;;1563   	goto drop;
000bb4  e1f9              B        |L10.4010|
                  |L10.2998|
;;;1564         }
;;;1565         uip_add_rcv_nxt(1 + uip_len);
000bb6  4972              LDR      r1,|L10.3456|
000bb8  8809              LDRH     r1,[r1,#0]  ; uip_len
000bba  1c49              ADDS     r1,r1,#1
000bbc  b288              UXTH     r0,r1
000bbe  f7fffffe          BL       uip_add_rcv_nxt
;;;1566         uip_flags |= UIP_CLOSE;
000bc2  486e              LDR      r0,|L10.3452|
000bc4  7800              LDRB     r0,[r0,#0]  ; uip_flags
000bc6  f0400010          ORR      r0,r0,#0x10
000bca  496c              LDR      r1,|L10.3452|
000bcc  7008              STRB     r0,[r1,#0]
;;;1567         if(uip_len > 0) {
000bce  486c              LDR      r0,|L10.3456|
000bd0  8800              LDRH     r0,[r0,#0]  ; uip_len
000bd2  2800              CMP      r0,#0
000bd4  dd04              BLE      |L10.3040|
;;;1568   	uip_flags |= UIP_NEWDATA;
000bd6  4608              MOV      r0,r1
000bd8  7800              LDRB     r0,[r0,#0]  ; uip_flags
000bda  f0400002          ORR      r0,r0,#2
000bde  7008              STRB     r0,[r1,#0]
                  |L10.3040|
;;;1569         }
;;;1570         UIP_APPCALL();
000be0  f7fffffe          BL       tcp_server_appcall
;;;1571         uip_connr->len = 1;
000be4  2001              MOVS     r0,#1
000be6  8220              STRH     r0,[r4,#0x10]
;;;1572         uip_connr->tcpstateflags = UIP_LAST_ACK;
000be8  2008              MOVS     r0,#8
000bea  7660              STRB     r0,[r4,#0x19]
;;;1573         uip_connr->nrtx = 0;
000bec  2000              MOVS     r0,#0
000bee  76e0              STRB     r0,[r4,#0x1b]
;;;1574       tcp_send_finack:
000bf0  bf00              NOP      
                  |L10.3058|
;;;1575         BUF->flags = TCP_FIN | TCP_ACK;
000bf2  2111              MOVS     r1,#0x11
000bf4  4860              LDR      r0,|L10.3448|
000bf6  f880102f          STRB     r1,[r0,#0x2f]
;;;1576         goto tcp_send_nodata;
000bfa  e143              B        |L10.3716|
000bfc  e0cd              B        |L10.3482|
000bfe  e12f              B        |L10.3680|
000c00  e12f              B        |L10.3682|
000c02  e10c              B        |L10.3614|
000c04  e0d6              B        |L10.3508|
                  |L10.3078|
;;;1577       }
;;;1578   
;;;1579       /* Check the URG flag. If this is set, the segment carries urgent
;;;1580          data that we must pass to the application. */
;;;1581       if((BUF->flags & TCP_URG) != 0) {
000c06  485c              LDR      r0,|L10.3448|
000c08  f890002f          LDRB     r0,[r0,#0x2f]
000c0c  f0100f20          TST      r0,#0x20
000c10  d017              BEQ      |L10.3138|
;;;1582   #if UIP_URGDATA > 0
;;;1583         uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
;;;1584         if(uip_urglen > uip_len) {
;;;1585   	/* There is more urgent data in the next segment to come. */
;;;1586   	uip_urglen = uip_len;
;;;1587         }
;;;1588         uip_add_rcv_nxt(uip_urglen);
;;;1589         uip_len -= uip_urglen;
;;;1590         uip_urgdata = uip_appdata;
;;;1591         uip_appdata += uip_urglen;
;;;1592       } else {
;;;1593         uip_urglen = 0;
;;;1594   #else /* UIP_URGDATA > 0 */
;;;1595         uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
000c12  4859              LDR      r0,|L10.3448|
000c14  f8901035          LDRB     r1,[r0,#0x35]
000c18  f8900034          LDRB     r0,[r0,#0x34]
000c1c  ea412000          ORR      r0,r1,r0,LSL #8
000c20  495b              LDR      r1,|L10.3472|
000c22  6809              LDR      r1,[r1,#0]  ; uip_appdata
000c24  4408              ADD      r0,r0,r1
000c26  495a              LDR      r1,|L10.3472|
000c28  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1596         uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
000c2a  4853              LDR      r0,|L10.3448|
000c2c  f8901035          LDRB     r1,[r0,#0x35]
000c30  f8900034          LDRB     r0,[r0,#0x34]
000c34  ea412000          ORR      r0,r1,r0,LSL #8
000c38  4951              LDR      r1,|L10.3456|
000c3a  8809              LDRH     r1,[r1,#0]  ; uip_len
000c3c  1a08              SUBS     r0,r1,r0
000c3e  4950              LDR      r1,|L10.3456|
000c40  8008              STRH     r0,[r1,#0]
                  |L10.3138|
;;;1597   #endif /* UIP_URGDATA > 0 */
;;;1598       }
;;;1599   
;;;1600       /* If uip_len > 0 we have TCP data in the packet, and we flag this
;;;1601          by setting the UIP_NEWDATA flag and update the sequence number
;;;1602          we acknowledge. If the application has stopped the dataflow
;;;1603          using uip_stop(), we must not accept any data packets from the
;;;1604          remote host. */
;;;1605       if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
000c42  484f              LDR      r0,|L10.3456|
000c44  8800              LDRH     r0,[r0,#0]  ; uip_len
000c46  2800              CMP      r0,#0
000c48  dd0d              BLE      |L10.3174|
000c4a  7e60              LDRB     r0,[r4,#0x19]
000c4c  f0100f10          TST      r0,#0x10
000c50  d109              BNE      |L10.3174|
;;;1606         uip_flags |= UIP_NEWDATA;
000c52  484a              LDR      r0,|L10.3452|
000c54  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c56  f0400002          ORR      r0,r0,#2
000c5a  4948              LDR      r1,|L10.3452|
000c5c  7008              STRB     r0,[r1,#0]
;;;1607         uip_add_rcv_nxt(uip_len);
000c5e  4848              LDR      r0,|L10.3456|
000c60  8800              LDRH     r0,[r0,#0]  ; uip_len
000c62  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3174|
;;;1608       }
;;;1609   
;;;1610       /* Check if the available buffer space advertised by the other end
;;;1611          is smaller than the initial MSS for this connection. If so, we
;;;1612          set the current MSS to the window size to ensure that the
;;;1613          application does not send more data than the other end can
;;;1614          handle.
;;;1615   
;;;1616          If the remote host advertises a zero window, we set the MSS to
;;;1617          the initial MSS so that the application will send an entire MSS
;;;1618          of data. This data will not be acknowledged by the receiver,
;;;1619          and the application will retransmit it. This is called the
;;;1620          "persistent timer" and uses the retransmission mechanim.
;;;1621       */
;;;1622       tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
000c66  4844              LDR      r0,|L10.3448|
000c68  f8901031          LDRB     r1,[r0,#0x31]
000c6c  f8900030          LDRB     r0,[r0,#0x30]
000c70  eb012000          ADD      r0,r1,r0,LSL #8
000c74  4944              LDR      r1,|L10.3464|
000c76  1c89              ADDS     r1,r1,#2
000c78  8008              STRH     r0,[r1,#0]
;;;1623       if(tmp16 > uip_connr->initialmss ||
000c7a  8aa0              LDRH     r0,[r4,#0x14]
000c7c  8809              LDRH     r1,[r1,#0]  ; tmp16
000c7e  4288              CMP      r0,r1
000c80  db03              BLT      |L10.3210|
;;;1624          tmp16 == 0) {
000c82  4841              LDR      r0,|L10.3464|
000c84  1c80              ADDS     r0,r0,#2
000c86  8800              LDRH     r0,[r0,#0]  ; tmp16
000c88  b918              CBNZ     r0,|L10.3218|
                  |L10.3210|
;;;1625         tmp16 = uip_connr->initialmss;
000c8a  8aa0              LDRH     r0,[r4,#0x14]
000c8c  493e              LDR      r1,|L10.3464|
000c8e  1c89              ADDS     r1,r1,#2
000c90  8008              STRH     r0,[r1,#0]
                  |L10.3218|
;;;1626       }
;;;1627       uip_connr->mss = tmp16;
000c92  483d              LDR      r0,|L10.3464|
000c94  1c80              ADDS     r0,r0,#2
000c96  8800              LDRH     r0,[r0,#0]  ; tmp16
000c98  8260              STRH     r0,[r4,#0x12]
;;;1628   
;;;1629       /* If this packet constitutes an ACK for outstanding data (flagged
;;;1630          by the UIP_ACKDATA flag, we should call the application since it
;;;1631          might want to send more data. If the incoming packet had data
;;;1632          from the peer (as flagged by the UIP_NEWDATA flag), the
;;;1633          application must also be notified.
;;;1634   
;;;1635          When the application is called, the global variable uip_len
;;;1636          contains the length of the incoming data. The application can
;;;1637          access the incoming data through the global pointer
;;;1638          uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
;;;1639          bytes into the uip_buf array.
;;;1640   
;;;1641          If the application wishes to send any data, this data should be
;;;1642          put into the uip_appdata and the length of the data should be
;;;1643          put into uip_len. If the application don't have any data to
;;;1644          send, uip_len must be set to 0. */
;;;1645       if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
000c9a  4838              LDR      r0,|L10.3452|
000c9c  7800              LDRB     r0,[r0,#0]  ; uip_flags
000c9e  f0100f03          TST      r0,#3
000ca2  d079              BEQ      |L10.3480|
;;;1646         uip_slen = 0;
000ca4  2000              MOVS     r0,#0
000ca6  4937              LDR      r1,|L10.3460|
000ca8  8008              STRH     r0,[r1,#0]
;;;1647         UIP_APPCALL();
000caa  f7fffffe          BL       tcp_server_appcall
;;;1648   
;;;1649       appsend:
000cae  bf00              NOP      
                  |L10.3248|
;;;1650   
;;;1651         if(uip_flags & UIP_ABORT) {
000cb0  4832              LDR      r0,|L10.3452|
000cb2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000cb4  f0100f20          TST      r0,#0x20
000cb8  d008              BEQ      |L10.3276|
;;;1652   	uip_slen = 0;
000cba  2000              MOVS     r0,#0
000cbc  4931              LDR      r1,|L10.3460|
000cbe  8008              STRH     r0,[r1,#0]
;;;1653   	uip_connr->tcpstateflags = UIP_CLOSED;
000cc0  7660              STRB     r0,[r4,#0x19]
;;;1654   	BUF->flags = TCP_RST | TCP_ACK;
000cc2  2114              MOVS     r1,#0x14
000cc4  482c              LDR      r0,|L10.3448|
000cc6  f880102f          STRB     r1,[r0,#0x2f]
;;;1655   	goto tcp_send_nodata;
000cca  e0db              B        |L10.3716|
                  |L10.3276|
;;;1656         }
;;;1657   
;;;1658         if(uip_flags & UIP_CLOSE) {
000ccc  482b              LDR      r0,|L10.3452|
000cce  7800              LDRB     r0,[r0,#0]  ; uip_flags
000cd0  f0100f10          TST      r0,#0x10
000cd4  d00d              BEQ      |L10.3314|
;;;1659   	uip_slen = 0;
000cd6  2000              MOVS     r0,#0
000cd8  492a              LDR      r1,|L10.3460|
000cda  8008              STRH     r0,[r1,#0]
;;;1660   	uip_connr->len = 1;
000cdc  2001              MOVS     r0,#1
000cde  8220              STRH     r0,[r4,#0x10]
;;;1661   	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
000ce0  2004              MOVS     r0,#4
000ce2  7660              STRB     r0,[r4,#0x19]
;;;1662   	uip_connr->nrtx = 0;
000ce4  2000              MOVS     r0,#0
000ce6  76e0              STRB     r0,[r4,#0x1b]
;;;1663   	BUF->flags = TCP_FIN | TCP_ACK;
000ce8  2111              MOVS     r1,#0x11
000cea  4823              LDR      r0,|L10.3448|
000cec  f880102f          STRB     r1,[r0,#0x2f]
;;;1664   	goto tcp_send_nodata;
000cf0  e0c8              B        |L10.3716|
                  |L10.3314|
;;;1665         }
;;;1666   
;;;1667         /* If uip_slen > 0, the application has data to be sent. */
;;;1668         if(uip_slen > 0) {
000cf2  4824              LDR      r0,|L10.3460|
000cf4  8800              LDRH     r0,[r0,#0]  ; uip_slen
000cf6  2800              CMP      r0,#0
000cf8  dd17              BLE      |L10.3370|
;;;1669   
;;;1670   	/* If the connection has acknowledged data, the contents of
;;;1671   	   the ->len variable should be discarded. */
;;;1672   	if((uip_flags & UIP_ACKDATA) != 0) {
000cfa  4820              LDR      r0,|L10.3452|
000cfc  7800              LDRB     r0,[r0,#0]  ; uip_flags
000cfe  f0100f01          TST      r0,#1
000d02  d001              BEQ      |L10.3336|
;;;1673   	  uip_connr->len = 0;
000d04  2000              MOVS     r0,#0
000d06  8220              STRH     r0,[r4,#0x10]
                  |L10.3336|
;;;1674   	}
;;;1675   
;;;1676   	/* If the ->len variable is non-zero the connection has
;;;1677   	   already data in transit and cannot send anymore right
;;;1678   	   now. */
;;;1679   	if(uip_connr->len == 0) {
000d08  8a20              LDRH     r0,[r4,#0x10]
000d0a  b958              CBNZ     r0,|L10.3364|
;;;1680   
;;;1681   	  /* The application cannot send more than what is allowed by
;;;1682   	     the mss (the minumum of the MSS and the available
;;;1683   	     window). */
;;;1684   	  if(uip_slen > uip_connr->mss) {
000d0c  8a60              LDRH     r0,[r4,#0x12]
000d0e  491d              LDR      r1,|L10.3460|
000d10  8809              LDRH     r1,[r1,#0]  ; uip_slen
000d12  4288              CMP      r0,r1
000d14  da02              BGE      |L10.3356|
;;;1685   	    uip_slen = uip_connr->mss;
000d16  8a60              LDRH     r0,[r4,#0x12]
000d18  491a              LDR      r1,|L10.3460|
000d1a  8008              STRH     r0,[r1,#0]
                  |L10.3356|
;;;1686   	  }
;;;1687   
;;;1688   	  /* Remember how much data we send out now so that we know
;;;1689   	     when everything has been acknowledged. */
;;;1690   	  uip_connr->len = uip_slen;
000d1c  4819              LDR      r0,|L10.3460|
000d1e  8800              LDRH     r0,[r0,#0]  ; uip_slen
000d20  8220              STRH     r0,[r4,#0x10]
000d22  e002              B        |L10.3370|
                  |L10.3364|
;;;1691   	} else {
;;;1692   
;;;1693   	  /* If the application already had unacknowledged data, we
;;;1694   	     make sure that the application does not send (i.e.,
;;;1695   	     retransmit) out more than it previously sent out. */
;;;1696   	  uip_slen = uip_connr->len;
000d24  8a20              LDRH     r0,[r4,#0x10]
000d26  4917              LDR      r1,|L10.3460|
000d28  8008              STRH     r0,[r1,#0]
                  |L10.3370|
;;;1697   	}
;;;1698         }
;;;1699         uip_connr->nrtx = 0;
000d2a  2000              MOVS     r0,#0
000d2c  76e0              STRB     r0,[r4,#0x1b]
;;;1700       apprexmit:
000d2e  bf00              NOP      
                  |L10.3376|
;;;1701         uip_appdata = uip_sappdata;
000d30  4818              LDR      r0,|L10.3476|
000d32  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000d34  4916              LDR      r1,|L10.3472|
000d36  6008              STR      r0,[r1,#0]  ; uip_appdata
;;;1702   
;;;1703         /* If the application has data to be sent, or if the incoming
;;;1704            packet had new data in it, we must send out a packet. */
;;;1705         if(uip_slen > 0 && uip_connr->len > 0) {
000d38  4812              LDR      r0,|L10.3460|
000d3a  8800              LDRH     r0,[r0,#0]  ; uip_slen
000d3c  2800              CMP      r0,#0
000d3e  dd0b              BLE      |L10.3416|
000d40  8a20              LDRH     r0,[r4,#0x10]
000d42  2800              CMP      r0,#0
000d44  dd08              BLE      |L10.3416|
;;;1706   	/* Add the length of the IP and TCP headers. */
;;;1707   	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
000d46  8a20              LDRH     r0,[r4,#0x10]
000d48  3028              ADDS     r0,r0,#0x28
000d4a  490d              LDR      r1,|L10.3456|
000d4c  8008              STRH     r0,[r1,#0]
;;;1708   	/* We always set the ACK flag in response packets. */
;;;1709   	BUF->flags = TCP_ACK | TCP_PSH;
000d4e  2118              MOVS     r1,#0x18
000d50  4809              LDR      r0,|L10.3448|
000d52  f880102f          STRB     r1,[r0,#0x2f]
;;;1710   	/* Send the packet. */
;;;1711   	goto tcp_send_noopts;
000d56  e099              B        |L10.3724|
                  |L10.3416|
;;;1712         }
;;;1713         /* If there is no data to send, just send out a pure ACK if
;;;1714   	 there is newdata. */
;;;1715         if(uip_flags & UIP_NEWDATA) {
000d58  4808              LDR      r0,|L10.3452|
000d5a  7800              LDRB     r0,[r0,#0]  ; uip_flags
000d5c  f0100f02          TST      r0,#2
000d60  d01a              BEQ      |L10.3480|
;;;1716   	uip_len = UIP_TCPIP_HLEN;
000d62  2028              MOVS     r0,#0x28
000d64  4906              LDR      r1,|L10.3456|
000d66  8008              STRH     r0,[r1,#0]
;;;1717   	BUF->flags = TCP_ACK;
000d68  2110              MOVS     r1,#0x10
000d6a  4803              LDR      r0,|L10.3448|
000d6c  f880102f          STRB     r1,[r0,#0x2f]
;;;1718   	goto tcp_send_noopts;
000d70  e08c              B        |L10.3724|
000d72  e011              B        |L10.3480|
                  |L10.3444|
                          DCD      uip_acc32
                  |L10.3448|
                          DCD      uip_buf
                  |L10.3452|
                          DCD      uip_flags
                  |L10.3456|
                          DCD      uip_len
                  |L10.3460|
                          DCD      uip_slen
                  |L10.3464|
                          DCD      ||.data||+0x34
                  |L10.3468|
                          DCD      uip_conn
                  |L10.3472|
                          DCD      uip_appdata
                  |L10.3476|
                          DCD      uip_sappdata
                  |L10.3480|
;;;1719         }
;;;1720       }
;;;1721       goto drop;
000d98  e107              B        |L10.4010|
                  |L10.3482|
;;;1722     case UIP_LAST_ACK:
;;;1723       /* We can close this connection if the peer has acknowledged our
;;;1724          FIN. This is indicated by the UIP_ACKDATA flag. */
;;;1725       if(uip_flags & UIP_ACKDATA) {
000d9a  4887              LDR      r0,|L10.4024|
000d9c  7800              LDRB     r0,[r0,#0]  ; uip_flags
000d9e  f0100f01          TST      r0,#1
000da2  d006              BEQ      |L10.3506|
;;;1726         uip_connr->tcpstateflags = UIP_CLOSED;
000da4  2000              MOVS     r0,#0
000da6  7660              STRB     r0,[r4,#0x19]
;;;1727         uip_flags = UIP_CLOSE;
000da8  2010              MOVS     r0,#0x10
000daa  4983              LDR      r1,|L10.4024|
000dac  7008              STRB     r0,[r1,#0]
;;;1728         UIP_APPCALL();
000dae  f7fffffe          BL       tcp_server_appcall
                  |L10.3506|
;;;1729       }
;;;1730       break;
000db2  e060              B        |L10.3702|
                  |L10.3508|
;;;1731   
;;;1732     case UIP_FIN_WAIT_1:
;;;1733       /* The application has closed the connection, but the remote host
;;;1734          hasn't closed its end yet. Thus we do nothing but wait for a
;;;1735          FIN from the other side. */
;;;1736       if(uip_len > 0) {
000db4  4881              LDR      r0,|L10.4028|
000db6  8800              LDRH     r0,[r0,#0]  ; uip_len
000db8  2800              CMP      r0,#0
000dba  dd03              BLE      |L10.3524|
;;;1737         uip_add_rcv_nxt(uip_len);
000dbc  487f              LDR      r0,|L10.4028|
000dbe  8800              LDRH     r0,[r0,#0]  ; uip_len
000dc0  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3524|
;;;1738       }
;;;1739       if(BUF->flags & TCP_FIN) {
000dc4  487e              LDR      r0,|L10.4032|
000dc6  f890002f          LDRB     r0,[r0,#0x2f]
000dca  f0100f01          TST      r0,#1
000dce  d016              BEQ      |L10.3582|
;;;1740         if(uip_flags & UIP_ACKDATA) {
000dd0  4879              LDR      r0,|L10.4024|
000dd2  7800              LDRB     r0,[r0,#0]  ; uip_flags
000dd4  f0100f01          TST      r0,#1
000dd8  d005              BEQ      |L10.3558|
;;;1741   	uip_connr->tcpstateflags = UIP_TIME_WAIT;
000dda  2007              MOVS     r0,#7
000ddc  7660              STRB     r0,[r4,#0x19]
;;;1742   	uip_connr->timer = 0;
000dde  2000              MOVS     r0,#0
000de0  76a0              STRB     r0,[r4,#0x1a]
;;;1743   	uip_connr->len = 0;
000de2  8220              STRH     r0,[r4,#0x10]
000de4  e001              B        |L10.3562|
                  |L10.3558|
;;;1744         } else {
;;;1745   	uip_connr->tcpstateflags = UIP_CLOSING;
000de6  2006              MOVS     r0,#6
000de8  7660              STRB     r0,[r4,#0x19]
                  |L10.3562|
;;;1746         }
;;;1747         uip_add_rcv_nxt(1);
000dea  2001              MOVS     r0,#1
000dec  f7fffffe          BL       uip_add_rcv_nxt
;;;1748         uip_flags = UIP_CLOSE;
000df0  2010              MOVS     r0,#0x10
000df2  4971              LDR      r1,|L10.4024|
000df4  7008              STRB     r0,[r1,#0]
;;;1749         UIP_APPCALL();
000df6  f7fffffe          BL       tcp_server_appcall
;;;1750         goto tcp_send_ack;
000dfa  e03e              B        |L10.3706|
                  |L10.3580|
000dfc  e08d              B        |L10.3866|
                  |L10.3582|
;;;1751       } else if(uip_flags & UIP_ACKDATA) {
000dfe  486e              LDR      r0,|L10.4024|
000e00  7800              LDRB     r0,[r0,#0]  ; uip_flags
000e02  f0100f01          TST      r0,#1
000e06  d004              BEQ      |L10.3602|
;;;1752         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
000e08  2005              MOVS     r0,#5
000e0a  7660              STRB     r0,[r4,#0x19]
;;;1753         uip_connr->len = 0;
000e0c  2000              MOVS     r0,#0
000e0e  8220              STRH     r0,[r4,#0x10]
;;;1754         goto drop;
000e10  e0cb              B        |L10.4010|
                  |L10.3602|
;;;1755       }
;;;1756       if(uip_len > 0) {
000e12  486a              LDR      r0,|L10.4028|
000e14  8800              LDRH     r0,[r0,#0]  ; uip_len
000e16  2800              CMP      r0,#0
000e18  dd00              BLE      |L10.3612|
;;;1757         goto tcp_send_ack;
000e1a  e02e              B        |L10.3706|
                  |L10.3612|
;;;1758       }
;;;1759       goto drop;
000e1c  e0c5              B        |L10.4010|
                  |L10.3614|
;;;1760   
;;;1761     case UIP_FIN_WAIT_2:
;;;1762       if(uip_len > 0) {
000e1e  4867              LDR      r0,|L10.4028|
000e20  8800              LDRH     r0,[r0,#0]  ; uip_len
000e22  2800              CMP      r0,#0
000e24  dd03              BLE      |L10.3630|
;;;1763         uip_add_rcv_nxt(uip_len);
000e26  4865              LDR      r0,|L10.4028|
000e28  8800              LDRH     r0,[r0,#0]  ; uip_len
000e2a  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.3630|
;;;1764       }
;;;1765       if(BUF->flags & TCP_FIN) {
000e2e  4864              LDR      r0,|L10.4032|
000e30  f890002f          LDRB     r0,[r0,#0x2f]
000e34  f0100f01          TST      r0,#1
000e38  d00c              BEQ      |L10.3668|
;;;1766         uip_connr->tcpstateflags = UIP_TIME_WAIT;
000e3a  2007              MOVS     r0,#7
000e3c  7660              STRB     r0,[r4,#0x19]
;;;1767         uip_connr->timer = 0;
000e3e  2000              MOVS     r0,#0
000e40  76a0              STRB     r0,[r4,#0x1a]
;;;1768         uip_add_rcv_nxt(1);
000e42  2001              MOVS     r0,#1
000e44  f7fffffe          BL       uip_add_rcv_nxt
;;;1769         uip_flags = UIP_CLOSE;
000e48  2010              MOVS     r0,#0x10
000e4a  495b              LDR      r1,|L10.4024|
000e4c  7008              STRB     r0,[r1,#0]
;;;1770         UIP_APPCALL();
000e4e  f7fffffe          BL       tcp_server_appcall
;;;1771         goto tcp_send_ack;
000e52  e012              B        |L10.3706|
                  |L10.3668|
;;;1772       }
;;;1773       if(uip_len > 0) {
000e54  4859              LDR      r0,|L10.4028|
000e56  8800              LDRH     r0,[r0,#0]  ; uip_len
000e58  2800              CMP      r0,#0
000e5a  dd00              BLE      |L10.3678|
;;;1774         goto tcp_send_ack;
000e5c  e00d              B        |L10.3706|
                  |L10.3678|
;;;1775       }
;;;1776       goto drop;
000e5e  e0a4              B        |L10.4010|
                  |L10.3680|
;;;1777   
;;;1778     case UIP_TIME_WAIT:
;;;1779       goto tcp_send_ack;
000e60  e00b              B        |L10.3706|
                  |L10.3682|
;;;1780   
;;;1781     case UIP_CLOSING:
;;;1782       if(uip_flags & UIP_ACKDATA) {
000e62  4855              LDR      r0,|L10.4024|
000e64  7800              LDRB     r0,[r0,#0]  ; uip_flags
000e66  f0100f01          TST      r0,#1
000e6a  d003              BEQ      |L10.3700|
;;;1783         uip_connr->tcpstateflags = UIP_TIME_WAIT;
000e6c  2007              MOVS     r0,#7
000e6e  7660              STRB     r0,[r4,#0x19]
;;;1784         uip_connr->timer = 0;
000e70  2000              MOVS     r0,#0
000e72  76a0              STRB     r0,[r4,#0x1a]
                  |L10.3700|
000e74  bf00              NOP                            ;1464
                  |L10.3702|
000e76  bf00              NOP                            ;1730
;;;1785       }
;;;1786     }
;;;1787     goto drop;
000e78  e097              B        |L10.4010|
                  |L10.3706|
;;;1788   
;;;1789   
;;;1790     /* We jump here when we are ready to send the packet, and just want
;;;1791        to set the appropriate TCP sequence numbers in the TCP header. */
;;;1792    tcp_send_ack:
;;;1793     BUF->flags = TCP_ACK;
000e7a  2110              MOVS     r1,#0x10
000e7c  4850              LDR      r0,|L10.4032|
000e7e  f880102f          STRB     r1,[r0,#0x2f]
;;;1794    tcp_send_nodata:
000e82  bf00              NOP      
                  |L10.3716|
;;;1795     uip_len = UIP_IPTCPH_LEN;
000e84  2028              MOVS     r0,#0x28
000e86  494d              LDR      r1,|L10.4028|
000e88  8008              STRH     r0,[r1,#0]
;;;1796    tcp_send_noopts:
000e8a  bf00              NOP      
                  |L10.3724|
;;;1797     BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
000e8c  2150              MOVS     r1,#0x50
000e8e  484c              LDR      r0,|L10.4032|
000e90  f880102e          STRB     r1,[r0,#0x2e]
;;;1798    tcp_send:
000e94  bf00              NOP      
                  |L10.3734|
;;;1799     /* We're done with the input processing. We are now ready to send a
;;;1800        reply. Our job is to fill in all the fields of the TCP and IP
;;;1801        headers before calculating the checksum and finally send the
;;;1802        packet. */
;;;1803     BUF->ackno[0] = uip_connr->rcv_nxt[0];
000e96  7a21              LDRB     r1,[r4,#8]
000e98  4849              LDR      r0,|L10.4032|
000e9a  f880102a          STRB     r1,[r0,#0x2a]
;;;1804     BUF->ackno[1] = uip_connr->rcv_nxt[1];
000e9e  7a61              LDRB     r1,[r4,#9]
000ea0  f880102b          STRB     r1,[r0,#0x2b]
;;;1805     BUF->ackno[2] = uip_connr->rcv_nxt[2];
000ea4  7aa1              LDRB     r1,[r4,#0xa]
000ea6  f880102c          STRB     r1,[r0,#0x2c]
;;;1806     BUF->ackno[3] = uip_connr->rcv_nxt[3];
000eaa  7ae1              LDRB     r1,[r4,#0xb]
000eac  f880102d          STRB     r1,[r0,#0x2d]
;;;1807   
;;;1808     BUF->seqno[0] = uip_connr->snd_nxt[0];
000eb0  7b21              LDRB     r1,[r4,#0xc]
000eb2  f8801026          STRB     r1,[r0,#0x26]
;;;1809     BUF->seqno[1] = uip_connr->snd_nxt[1];
000eb6  7b61              LDRB     r1,[r4,#0xd]
000eb8  f8801027          STRB     r1,[r0,#0x27]
;;;1810     BUF->seqno[2] = uip_connr->snd_nxt[2];
000ebc  7ba1              LDRB     r1,[r4,#0xe]
000ebe  f8801028          STRB     r1,[r0,#0x28]
;;;1811     BUF->seqno[3] = uip_connr->snd_nxt[3];
000ec2  7be1              LDRB     r1,[r4,#0xf]
000ec4  f8801029          STRB     r1,[r0,#0x29]
;;;1812   
;;;1813     BUF->proto = UIP_PROTO_TCP;
000ec8  2106              MOVS     r1,#6
000eca  75c1              STRB     r1,[r0,#0x17]
;;;1814   
;;;1815     BUF->srcport  = uip_connr->lport;
000ecc  88a1              LDRH     r1,[r4,#4]
000ece  8441              STRH     r1,[r0,#0x22]
;;;1816     BUF->destport = uip_connr->rport;
000ed0  88e1              LDRH     r1,[r4,#6]
000ed2  8481              STRH     r1,[r0,#0x24]
;;;1817   
;;;1818     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000ed4  bf00              NOP      
000ed6  483b              LDR      r0,|L10.4036|
000ed8  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000eda  4839              LDR      r0,|L10.4032|
000edc  8341              STRH     r1,[r0,#0x1a]
000ede  4839              LDR      r0,|L10.4036|
000ee0  8841              LDRH     r1,[r0,#2]  ; uip_hostaddr
000ee2  4837              LDR      r0,|L10.4032|
000ee4  8381              STRH     r1,[r0,#0x1c]
000ee6  bf00              NOP      
;;;1819     uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
000ee8  bf00              NOP      
000eea  8821              LDRH     r1,[r4,#0]
000eec  83c1              STRH     r1,[r0,#0x1e]
000eee  8861              LDRH     r1,[r4,#2]
000ef0  8401              STRH     r1,[r0,#0x20]
000ef2  bf00              NOP      
;;;1820   
;;;1821     if(uip_connr->tcpstateflags & UIP_STOPPED) {
000ef4  7e60              LDRB     r0,[r4,#0x19]
000ef6  f0100f10          TST      r0,#0x10
000efa  d006              BEQ      |L10.3850|
;;;1822       /* If the connection has issued uip_stop(), we advertise a zero
;;;1823          window so that the remote host will stop sending data. */
;;;1824       BUF->wnd[0] = BUF->wnd[1] = 0;
000efc  2100              MOVS     r1,#0
000efe  4830              LDR      r0,|L10.4032|
000f00  f8801031          STRB     r1,[r0,#0x31]
000f04  f8801030          STRB     r1,[r0,#0x30]
000f08  e006              B        |L10.3864|
                  |L10.3850|
;;;1825     } else {
;;;1826       BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
000f0a  210f              MOVS     r1,#0xf
000f0c  482c              LDR      r0,|L10.4032|
000f0e  f8801030          STRB     r1,[r0,#0x30]
;;;1827       BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
000f12  21ca              MOVS     r1,#0xca
000f14  f8801031          STRB     r1,[r0,#0x31]
                  |L10.3864|
;;;1828     }
;;;1829   
;;;1830    tcp_send_noconn:
000f18  bf00              NOP      
                  |L10.3866|
;;;1831     BUF->ttl = UIP_TTL;
000f1a  2140              MOVS     r1,#0x40
000f1c  4828              LDR      r0,|L10.4032|
000f1e  7581              STRB     r1,[r0,#0x16]
;;;1832   #if UIP_CONF_IPV6
;;;1833     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1834        length. */
;;;1835     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1836     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1837   #else /* UIP_CONF_IPV6 */
;;;1838     BUF->len[0] = (uip_len >> 8);
000f20  4826              LDR      r0,|L10.4028|
000f22  8800              LDRH     r0,[r0,#0]  ; uip_len
000f24  1201              ASRS     r1,r0,#8
000f26  4826              LDR      r0,|L10.4032|
000f28  7401              STRB     r1,[r0,#0x10]
;;;1839     BUF->len[1] = (uip_len & 0xff);
000f2a  4824              LDR      r0,|L10.4028|
000f2c  8800              LDRH     r0,[r0,#0]  ; uip_len
000f2e  b2c1              UXTB     r1,r0
000f30  4823              LDR      r0,|L10.4032|
000f32  7441              STRB     r1,[r0,#0x11]
;;;1840   #endif /* UIP_CONF_IPV6 */
;;;1841   
;;;1842     BUF->urgp[0] = BUF->urgp[1] = 0;
000f34  2100              MOVS     r1,#0
000f36  f8801035          STRB     r1,[r0,#0x35]
000f3a  f8801034          STRB     r1,[r0,#0x34]
;;;1843   
;;;1844     /* Calculate TCP checksum. */
;;;1845     BUF->tcpchksum = 0;
000f3e  8641              STRH     r1,[r0,#0x32]
;;;1846     BUF->tcpchksum = ~(uip_tcpchksum());
000f40  f7fffffe          BL       uip_tcpchksum
000f44  43c0              MVNS     r0,r0
000f46  b281              UXTH     r1,r0
000f48  481d              LDR      r0,|L10.4032|
000f4a  8641              STRH     r1,[r0,#0x32]
;;;1847   
;;;1848    ip_send_nolen:
;;;1849   
;;;1850   #if UIP_CONF_IPV6
;;;1851     BUF->vtc = 0x60;
;;;1852     BUF->tcflow = 0x00;
;;;1853     BUF->flow = 0x00;
;;;1854   #else /* UIP_CONF_IPV6 */
;;;1855     BUF->vhl = 0x45;
000f4c  2045              MOVS     r0,#0x45
000f4e  491c              LDR      r1,|L10.4032|
000f50  7388              STRB     r0,[r1,#0xe]
;;;1856     BUF->tos = 0;
000f52  2100              MOVS     r1,#0
000f54  481a              LDR      r0,|L10.4032|
000f56  73c1              STRB     r1,[r0,#0xf]
;;;1857     BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
000f58  7541              STRB     r1,[r0,#0x15]
000f5a  7501              STRB     r1,[r0,#0x14]
;;;1858     ++ipid;
000f5c  481a              LDR      r0,|L10.4040|
000f5e  8800              LDRH     r0,[r0,#0]  ; ipid
000f60  1c40              ADDS     r0,r0,#1
000f62  4919              LDR      r1,|L10.4040|
000f64  8008              STRH     r0,[r1,#0]
;;;1859     BUF->ipid[0] = ipid >> 8;
000f66  4608              MOV      r0,r1
000f68  8800              LDRH     r0,[r0,#0]  ; ipid
000f6a  1201              ASRS     r1,r0,#8
000f6c  4814              LDR      r0,|L10.4032|
000f6e  7481              STRB     r1,[r0,#0x12]
;;;1860     BUF->ipid[1] = ipid & 0xff;
000f70  4815              LDR      r0,|L10.4040|
000f72  8800              LDRH     r0,[r0,#0]  ; ipid
000f74  b2c1              UXTB     r1,r0
000f76  4812              LDR      r0,|L10.4032|
000f78  74c1              STRB     r1,[r0,#0x13]
;;;1861     /* Calculate IP checksum. */
;;;1862     BUF->ipchksum = 0;
000f7a  2100              MOVS     r1,#0
000f7c  8301              STRH     r1,[r0,#0x18]
;;;1863     BUF->ipchksum = ~(uip_ipchksum());
000f7e  f7fffffe          BL       uip_ipchksum
000f82  43c0              MVNS     r0,r0
000f84  b281              UXTH     r1,r0
000f86  480e              LDR      r0,|L10.4032|
000f88  8301              STRH     r1,[r0,#0x18]
;;;1864     DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
;;;1865   #endif /* UIP_CONF_IPV6 */
;;;1866   
;;;1867     UIP_STAT(++uip_stat.tcp.sent);
000f8a  4810              LDR      r0,|L10.4044|
000f8c  8bc0              LDRH     r0,[r0,#0x1e]
000f8e  1c40              ADDS     r0,r0,#1
000f90  b281              UXTH     r1,r0
000f92  480e              LDR      r0,|L10.4044|
000f94  83c1              STRH     r1,[r0,#0x1e]
;;;1868    send:
000f96  bf00              NOP      
                  |L10.3992|
;;;1869     DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
;;;1870   	       (BUF->len[0] << 8) | BUF->len[1]);
;;;1871   
;;;1872     UIP_STAT(++uip_stat.ip.sent);
000f98  480c              LDR      r0,|L10.4044|
000f9a  8880              LDRH     r0,[r0,#4]  ; uip_stat
000f9c  1c40              ADDS     r0,r0,#1
000f9e  490b              LDR      r1,|L10.4044|
000fa0  8088              STRH     r0,[r1,#4]
;;;1873     /* Return and let the caller do the actual transmission. */
;;;1874     uip_flags = 0;
000fa2  2000              MOVS     r0,#0
000fa4  4904              LDR      r1,|L10.4024|
000fa6  7008              STRB     r0,[r1,#0]
                  |L10.4008|
;;;1875     return;
;;;1876    drop:
;;;1877     uip_len = 0;
;;;1878     uip_flags = 0;
;;;1879     return;
;;;1880   }
000fa8  bd70              POP      {r4-r6,pc}
                  |L10.4010|
000faa  2000              MOVS     r0,#0                 ;1877
000fac  4903              LDR      r1,|L10.4028|
000fae  8008              STRH     r0,[r1,#0]            ;1877
000fb0  4901              LDR      r1,|L10.4024|
000fb2  7008              STRB     r0,[r1,#0]            ;1878
000fb4  e7f8              B        |L10.4008|
;;;1881   /*---------------------------------------------------------------------------*/
                          ENDP

000fb6  0000              DCW      0x0000
                  |L10.4024|
                          DCD      uip_flags
                  |L10.4028|
                          DCD      uip_len
                  |L10.4032|
                          DCD      uip_buf
                  |L10.4036|
                          DCD      uip_hostaddr
                  |L10.4040|
                          DCD      ||.data||+0x28
                  |L10.4044|
                          DCD      uip_stat

                          AREA ||i.uip_send||, CODE, READONLY, ALIGN=2

                  uip_send PROC
;;;1888   void
;;;1889   uip_send(const void *data, int len)
000000  b570              PUSH     {r4-r6,lr}
;;;1890   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1891     if(len > 0) {
000006  2c00              CMP      r4,#0
000008  dd0c              BLE      |L11.36|
;;;1892       uip_slen = len;
00000a  4907              LDR      r1,|L11.40|
00000c  800c              STRH     r4,[r1,#0]
;;;1893       if(data != uip_sappdata) {
00000e  4807              LDR      r0,|L11.44|
000010  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000012  4285              CMP      r5,r0
000014  d006              BEQ      |L11.36|
;;;1894         memcpy(uip_sappdata, (data), uip_slen);
000016  4608              MOV      r0,r1
000018  8802              LDRH     r2,[r0,#0]  ; uip_slen
00001a  4629              MOV      r1,r5
00001c  4803              LDR      r0,|L11.44|
00001e  6800              LDR      r0,[r0,#0]  ; uip_sappdata
000020  f7fffffe          BL       __aeabi_memcpy
                  |L11.36|
;;;1895       }
;;;1896     }
;;;1897   }
000024  bd70              POP      {r4-r6,pc}
;;;1898   /** @} */
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      uip_slen
                  |L11.44|
                          DCD      uip_sappdata

                          AREA ||i.uip_setipid||, CODE, READONLY, ALIGN=2

                  uip_setipid PROC
;;;180    
;;;181    void uip_setipid(u16_t id) { ipid = id; }
000000  4901              LDR      r1,|L12.8|
000002  8008              STRH     r0,[r1,#0]
000004  4770              BX       lr
;;;182    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||+0x28

                          AREA ||i.uip_tcpchksum||, CODE, READONLY, ALIGN=1

                  uip_tcpchksum PROC
;;;363    u16_t
;;;364    uip_tcpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;365    {
;;;366      return upper_layer_chksum(UIP_PROTO_TCP);
000002  2006              MOVS     r0,#6
000004  f7fffffe          BL       upper_layer_chksum
;;;367    }
000008  bd10              POP      {r4,pc}
;;;368    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_udpchksum||, CODE, READONLY, ALIGN=1

                  uip_udpchksum PROC
;;;370    u16_t
;;;371    uip_udpchksum(void)
000000  b510              PUSH     {r4,lr}
;;;372    {
;;;373      return upper_layer_chksum(UIP_PROTO_UDP);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       upper_layer_chksum
;;;374    }
000008  bd10              POP      {r4,pc}
;;;375    #endif /* UIP_UDP_CHECKSUMS */
                          ENDP


                          AREA ||i.uip_unlisten||, CODE, READONLY, ALIGN=2

                  uip_unlisten PROC
;;;517    void
;;;518    uip_unlisten(u16_t port)
000000  2100              MOVS     r1,#0
;;;519    {
;;;520      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4a0d              LDR      r2,|L15.56|
000004  7011              STRB     r1,[r2,#0]
000006  e012              B        |L15.46|
                  |L15.8|
;;;521        if(uip_listenports[c] == port) {
000008  490c              LDR      r1,|L15.60|
00000a  4a0b              LDR      r2,|L15.56|
00000c  7812              LDRB     r2,[r2,#0]  ; c
00000e  f8311012          LDRH     r1,[r1,r2,LSL #1]
000012  4281              CMP      r1,r0
000014  d106              BNE      |L15.36|
;;;522          uip_listenports[c] = 0;
000016  2100              MOVS     r1,#0
000018  4a08              LDR      r2,|L15.60|
00001a  4b07              LDR      r3,|L15.56|
00001c  781b              LDRB     r3,[r3,#0]  ; c
00001e  f8221013          STRH     r1,[r2,r3,LSL #1]
                  |L15.34|
;;;523          return;
;;;524        }
;;;525      }
;;;526    }
000022  4770              BX       lr
                  |L15.36|
000024  4904              LDR      r1,|L15.56|
000026  7809              LDRB     r1,[r1,#0]            ;520  ; c
000028  1c49              ADDS     r1,r1,#1              ;520
00002a  4a03              LDR      r2,|L15.56|
00002c  7011              STRB     r1,[r2,#0]            ;520
                  |L15.46|
00002e  4902              LDR      r1,|L15.56|
000030  7809              LDRB     r1,[r1,#0]            ;520  ; c
000032  2928              CMP      r1,#0x28              ;520
000034  dbe8              BLT      |L15.8|
000036  e7f4              B        |L15.34|
;;;527    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L15.56|
                          DCD      ||.data||+0x34
                  |L15.60|
                          DCD      uip_listenports

                          AREA ||i.upper_layer_chksum||, CODE, READONLY, ALIGN=2

                  upper_layer_chksum PROC
;;;328    static u16_t
;;;329    upper_layer_chksum(u8_t proto)
000000  b570              PUSH     {r4-r6,lr}
;;;330    {
000002  4604              MOV      r4,r0
;;;331      u16_t upper_layer_len;
;;;332      u16_t sum;
;;;333    
;;;334    #if UIP_CONF_IPV6
;;;335      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
;;;336    #else /* UIP_CONF_IPV6 */
;;;337      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
000004  480f              LDR      r0,|L16.68|
000006  7c41              LDRB     r1,[r0,#0x11]
000008  7c00              LDRB     r0,[r0,#0x10]
00000a  eb012000          ADD      r0,r1,r0,LSL #8
00000e  3814              SUBS     r0,r0,#0x14
000010  b285              UXTH     r5,r0
;;;338    #endif /* UIP_CONF_IPV6 */
;;;339    
;;;340      /* First sum pseudoheader. */
;;;341    
;;;342      /* IP protocol and length fields. This addition cannot carry. */
;;;343      sum = upper_layer_len + proto;
000012  1928              ADDS     r0,r5,r4
000014  b286              UXTH     r6,r0
;;;344      /* Sum IP source and destination addresses. */
;;;345      sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
000016  2208              MOVS     r2,#8
000018  490a              LDR      r1,|L16.68|
00001a  311a              ADDS     r1,r1,#0x1a
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       chksum
000022  4606              MOV      r6,r0
;;;346    
;;;347      /* Sum TCP header and data. */
;;;348      sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
000024  462a              MOV      r2,r5
000026  4907              LDR      r1,|L16.68|
000028  3122              ADDS     r1,r1,#0x22
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       chksum
000030  4606              MOV      r6,r0
;;;349    	       upper_layer_len);
;;;350    
;;;351      return (sum == 0) ? 0xffff : htons(sum);
000032  b916              CBNZ     r6,|L16.58|
000034  f64f70ff          MOV      r0,#0xffff
000038  e002              B        |L16.64|
                  |L16.58|
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       htons
                  |L16.64|
000040  b280              UXTH     r0,r0
;;;352    }
000042  bd70              POP      {r4-r6,pc}
;;;353    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L16.68|
                          DCD      uip_buf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uip_buf
                          %        4100
                  uip_conns
                          %        1600
                  uip_listenports
                          %        80
                  uip_stat
                          %        44

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  all_ones_addr
000000  ffffffff          DCW      0xffff,0xffff
                  all_zeroes_addr
000004  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  uip_ethaddr
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00
                  uip_hostaddr
                          DCDU     0x00000000
                  uip_draddr
                          DCDU     0x00000000
                  uip_netmask
                          DCDU     0x00000000
000012  0000              DCB      0x00,0x00
                  uip_appdata
                          DCD      0x00000000
                  uip_sappdata
                          DCD      0x00000000
                  uip_len
00001c  0000              DCB      0x00,0x00
                  uip_slen
00001e  0000              DCB      0x00,0x00
                  uip_flags
000020  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_conn
                          DCD      0x00000000
                  ipid
000028  0000              DCB      0x00,0x00
                  iss
                          DCDU     0x00000000
                  lastport
00002e  0000              DCB      0x00,0x00
                  uip_acc32
                          DCD      0x00000000
                  c
000034  00                DCB      0x00
                  opt
000035  00                DCB      0x00
                  tmp16
000036  0000              DCB      0x00,0x00
