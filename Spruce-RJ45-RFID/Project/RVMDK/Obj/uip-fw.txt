; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\uip-fw.o --depend=.\Obj\uip-fw.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\uip-fw.crf ..\..\Libraries\uIP-1.0\uip\uip-fw.c]
                          THUMB

                          AREA ||i.find_netif||, CODE, READONLY, ALIGN=2

                  find_netif PROC
;;;322    static struct uip_fw_netif *
;;;323    find_netif(void)
000000  b510              PUSH     {r4,lr}
;;;324    {
;;;325      struct uip_fw_netif *netif;
;;;326    
;;;327      /* Walk through every network interface to check for a match. */
;;;328      for(netif = netifs; netif != NULL; netif = netif->next) {
000002  4809              LDR      r0,|L1.40|
000004  6804              LDR      r4,[r0,#0]  ; netifs
000006  e009              B        |L1.28|
                  |L1.8|
;;;329        if(ipaddr_maskcmp(BUF->destipaddr, netif->ipaddr,
000008  f1040208          ADD      r2,r4,#8
00000c  1d21              ADDS     r1,r4,#4
00000e  4807              LDR      r0,|L1.44|
000010  f7fffffe          BL       ipaddr_maskcmp
000014  b108              CBZ      r0,|L1.26|
;;;330    		      netif->netmask)) {
;;;331          /* If there was a match, we break the loop. */
;;;332          return netif;
000016  4620              MOV      r0,r4
                  |L1.24|
;;;333        }
;;;334      }
;;;335    
;;;336      /* If no matching netif was found, we use default netif. */
;;;337      return defaultnetif;
;;;338    }
000018  bd10              POP      {r4,pc}
                  |L1.26|
00001a  6824              LDR      r4,[r4,#0]            ;328
                  |L1.28|
00001c  2c00              CMP      r4,#0                 ;328
00001e  d1f3              BNE      |L1.8|
000020  4801              LDR      r0,|L1.40|
000022  1d00              ADDS     r0,r0,#4              ;337
000024  6800              LDR      r0,[r0,#0]            ;337  ; defaultnetif
000026  e7f7              B        |L1.24|
;;;339    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L1.40|
                          DCD      ||.data||
                  |L1.44|
                          DCD      uip_buf+0x1e

                          AREA ||i.fwcache_register||, CODE, READONLY, ALIGN=2

                  fwcache_register PROC
;;;280    static void
;;;281    fwcache_register(void)
000000  b510              PUSH     {r4,lr}
;;;282    {
;;;283      struct fwcache_entry *fw;
;;;284      int i, oldest;
;;;285    
;;;286      oldest = FW_TIME;
000002  2214              MOVS     r2,#0x14
;;;287      fw = NULL;
000004  2000              MOVS     r0,#0
;;;288    
;;;289      /* Find the oldest entry in the cache. */
;;;290      for(i = 0; i < FWCACHE_SIZE; ++i) {
000006  2100              MOVS     r1,#0
000008  e01a              B        |L2.64|
                  |L2.10|
;;;291        if(fwcache[i].timer == 0) {
00000a  ebc103c1          RSB      r3,r1,r1,LSL #3
00000e  4c17              LDR      r4,|L2.108|
000010  f8343013          LDRH     r3,[r4,r3,LSL #1]
000014  b923              CBNZ     r3,|L2.32|
;;;292          fw = &fwcache[i];
000016  ebc103c1          RSB      r3,r1,r1,LSL #3
00001a  eb040043          ADD      r0,r4,r3,LSL #1
;;;293          break;
00001e  e011              B        |L2.68|
                  |L2.32|
;;;294        } else if(fwcache[i].timer <= oldest) {
000020  ebc103c1          RSB      r3,r1,r1,LSL #3
000024  4c11              LDR      r4,|L2.108|
000026  f8343013          LDRH     r3,[r4,r3,LSL #1]
00002a  4293              CMP      r3,r2
00002c  dc07              BGT      |L2.62|
;;;295          fw = &fwcache[i];
00002e  ebc103c1          RSB      r3,r1,r1,LSL #3
000032  eb040043          ADD      r0,r4,r3,LSL #1
;;;296          oldest = fwcache[i].timer;
000036  ebc103c1          RSB      r3,r1,r1,LSL #3
00003a  f8342013          LDRH     r2,[r4,r3,LSL #1]
                  |L2.62|
00003e  1c49              ADDS     r1,r1,#1              ;290
                  |L2.64|
000040  2902              CMP      r1,#2                 ;290
000042  dbe2              BLT      |L2.10|
                  |L2.68|
000044  bf00              NOP                            ;293
;;;297        }
;;;298      }
;;;299    
;;;300      fw->timer = FW_TIME;
000046  2314              MOVS     r3,#0x14
000048  8003              STRH     r3,[r0,#0]
;;;301      fw->ipid = BUF->ipid;
00004a  4b09              LDR      r3,|L2.112|
00004c  8a5b              LDRH     r3,[r3,#0x12]
00004e  8143              STRH     r3,[r0,#0xa]
;;;302      fw->srcipaddr[0] = BUF->srcipaddr[0];
000050  4b07              LDR      r3,|L2.112|
000052  8b5b              LDRH     r3,[r3,#0x1a]
000054  8043              STRH     r3,[r0,#2]
;;;303      fw->srcipaddr[1] = BUF->srcipaddr[1];
000056  4b06              LDR      r3,|L2.112|
000058  8b9c              LDRH     r4,[r3,#0x1c]
00005a  8084              STRH     r4,[r0,#4]
;;;304      fw->destipaddr[0] = BUF->destipaddr[0];
00005c  8bdb              LDRH     r3,[r3,#0x1e]
00005e  80c3              STRH     r3,[r0,#6]
;;;305      fw->destipaddr[1] = BUF->destipaddr[1];
000060  4b03              LDR      r3,|L2.112|
000062  8c1c              LDRH     r4,[r3,#0x20]
000064  8104              STRH     r4,[r0,#8]
;;;306      fw->proto = BUF->proto;
000066  7ddb              LDRB     r3,[r3,#0x17]
000068  7303              STRB     r3,[r0,#0xc]
;;;307    #if notdef
;;;308      fw->payload[0] = BUF->srcport;
;;;309      fw->payload[1] = BUF->destport;
;;;310    #endif
;;;311    #if UIP_REASSEMBLY > 0
;;;312      fw->len = BUF->len;
;;;313      fw->offset = BUF->ipoffset;
;;;314    #endif
;;;315    }
00006a  bd10              POP      {r4,pc}
;;;316    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L2.108|
                          DCD      ||.bss||
                  |L2.112|
                          DCD      uip_buf

                          AREA ||i.ipaddr_maskcmp||, CODE, READONLY, ALIGN=1

                  ipaddr_maskcmp PROC
;;;205    static unsigned char
;;;206    ipaddr_maskcmp(u16_t *ipaddr, u16_t *netipaddr, u16_t *netmask)
000000  b530              PUSH     {r4,r5,lr}
;;;207    {
000002  4603              MOV      r3,r0
;;;208      return (ipaddr[0] & netmask [0]) == (netipaddr[0] & netmask[0]) &&
000004  8818              LDRH     r0,[r3,#0]
000006  8814              LDRH     r4,[r2,#0]
000008  4020              ANDS     r0,r0,r4
00000a  880c              LDRH     r4,[r1,#0]
00000c  8815              LDRH     r5,[r2,#0]
00000e  402c              ANDS     r4,r4,r5
000010  42a0              CMP      r0,r4
000012  d109              BNE      |L3.40|
;;;209        (ipaddr[1] & netmask[1]) == (netipaddr[1] & netmask[1]);
000014  885c              LDRH     r4,[r3,#2]
000016  8850              LDRH     r0,[r2,#2]
000018  4004              ANDS     r4,r4,r0
00001a  8848              LDRH     r0,[r1,#2]
00001c  8855              LDRH     r5,[r2,#2]
00001e  4028              ANDS     r0,r0,r5
000020  4284              CMP      r4,r0
000022  d101              BNE      |L3.40|
000024  2001              MOVS     r0,#1
000026  e000              B        |L3.42|
                  |L3.40|
000028  2000              MOVS     r0,#0
                  |L3.42|
00002a  b2c0              UXTB     r0,r0
;;;210    }
00002c  bd30              POP      {r4,r5,pc}
;;;211    /*------------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.time_exceeded||, CODE, READONLY, ALIGN=2

                  time_exceeded PROC
;;;220    static void
;;;221    time_exceeded(void)
000000  b510              PUSH     {r4,lr}
;;;222    {
;;;223      u16_t tmp16;
;;;224    
;;;225      /* We don't send out ICMP errors for ICMP messages. */
;;;226      if(ICMPBUF->proto == UIP_PROTO_ICMP) {
000002  4827              LDR      r0,|L4.160|
000004  7dc0              LDRB     r0,[r0,#0x17]
000006  2801              CMP      r0,#1
000008  d103              BNE      |L4.18|
;;;227        uip_len = 0;
00000a  2000              MOVS     r0,#0
00000c  4925              LDR      r1,|L4.164|
00000e  8008              STRH     r0,[r1,#0]
                  |L4.16|
;;;228        return;
;;;229      }
;;;230      /* Copy fields from packet header into payload of this ICMP packet. */
;;;231      memcpy(&(ICMPBUF->payload[0]), ICMPBUF, 28);
;;;232    
;;;233      /* Set the ICMP type and code. */
;;;234      ICMPBUF->type = ICMP_TE;
;;;235      ICMPBUF->icode = 0;
;;;236    
;;;237      /* Calculate the ICMP checksum. */
;;;238      ICMPBUF->icmpchksum = 0;
;;;239      ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
;;;240    
;;;241      /* Set the IP destination address to be the source address of the
;;;242         original packet. */
;;;243      tmp16= BUF->destipaddr[0];
;;;244      BUF->destipaddr[0] = BUF->srcipaddr[0];
;;;245      BUF->srcipaddr[0] = tmp16;
;;;246      tmp16 = BUF->destipaddr[1];
;;;247      BUF->destipaddr[1] = BUF->srcipaddr[1];
;;;248      BUF->srcipaddr[1] = tmp16;
;;;249    
;;;250      /* Set our IP address as the source address. */
;;;251      BUF->srcipaddr[0] = uip_hostaddr[0];
;;;252      BUF->srcipaddr[1] = uip_hostaddr[1];
;;;253    
;;;254      /* The size of the ICMP time exceeded packet is 36 + the size of the
;;;255         IP header (20) = 56. */
;;;256      uip_len = 56;
;;;257      ICMPBUF->len[0] = 0;
;;;258      ICMPBUF->len[1] = uip_len;
;;;259    
;;;260      /* Fill in the other fields in the IP header. */
;;;261      ICMPBUF->vhl = 0x45;
;;;262      ICMPBUF->tos = 0;
;;;263      ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;
;;;264      ICMPBUF->ttl  = UIP_TTL;
;;;265      ICMPBUF->proto = UIP_PROTO_ICMP;
;;;266    
;;;267      /* Calculate IP checksum. */
;;;268      ICMPBUF->ipchksum = 0;
;;;269      ICMPBUF->ipchksum = ~(uip_ipchksum());
;;;270    
;;;271    
;;;272    }
000010  bd10              POP      {r4,pc}
                  |L4.18|
000012  221c              MOVS     r2,#0x1c              ;231
000014  4922              LDR      r1,|L4.160|
000016  310e              ADDS     r1,r1,#0xe            ;231
000018  f101001c          ADD      r0,r1,#0x1c           ;231
00001c  f7fffffe          BL       __aeabi_memcpy
000020  210b              MOVS     r1,#0xb               ;234
000022  481f              LDR      r0,|L4.160|
000024  f8801022          STRB     r1,[r0,#0x22]         ;234
000028  2100              MOVS     r1,#0                 ;235
00002a  f8801023          STRB     r1,[r0,#0x23]         ;235
00002e  8481              STRH     r1,[r0,#0x24]         ;238
000030  2124              MOVS     r1,#0x24              ;239
000032  3022              ADDS     r0,r0,#0x22           ;239
000034  f7fffffe          BL       uip_chksum
000038  43c0              MVNS     r0,r0                 ;239
00003a  b281              UXTH     r1,r0                 ;239
00003c  4818              LDR      r0,|L4.160|
00003e  8481              STRH     r1,[r0,#0x24]         ;239
000040  8bc4              LDRH     r4,[r0,#0x1e]         ;243
000042  8b41              LDRH     r1,[r0,#0x1a]         ;244
000044  83c1              STRH     r1,[r0,#0x1e]         ;244
000046  8344              STRH     r4,[r0,#0x1a]         ;245
000048  8c04              LDRH     r4,[r0,#0x20]         ;246
00004a  8b81              LDRH     r1,[r0,#0x1c]         ;247
00004c  8401              STRH     r1,[r0,#0x20]         ;247
00004e  8384              STRH     r4,[r0,#0x1c]         ;248
000050  4815              LDR      r0,|L4.168|
000052  8801              LDRH     r1,[r0,#0]            ;251  ; uip_hostaddr
000054  4812              LDR      r0,|L4.160|
000056  8341              STRH     r1,[r0,#0x1a]         ;251
000058  4813              LDR      r0,|L4.168|
00005a  8841              LDRH     r1,[r0,#2]            ;252  ; uip_hostaddr
00005c  4810              LDR      r0,|L4.160|
00005e  8381              STRH     r1,[r0,#0x1c]         ;252
000060  2038              MOVS     r0,#0x38              ;256
000062  4910              LDR      r1,|L4.164|
000064  8008              STRH     r0,[r1,#0]            ;256
000066  2100              MOVS     r1,#0                 ;257
000068  480d              LDR      r0,|L4.160|
00006a  7401              STRB     r1,[r0,#0x10]         ;257
00006c  480d              LDR      r0,|L4.164|
00006e  8800              LDRH     r0,[r0,#0]            ;258  ; uip_len
000070  b2c1              UXTB     r1,r0                 ;258
000072  480b              LDR      r0,|L4.160|
000074  7441              STRB     r1,[r0,#0x11]         ;258
000076  2045              MOVS     r0,#0x45              ;261
000078  4909              LDR      r1,|L4.160|
00007a  7388              STRB     r0,[r1,#0xe]          ;261
00007c  2100              MOVS     r1,#0                 ;262
00007e  4808              LDR      r0,|L4.160|
000080  73c1              STRB     r1,[r0,#0xf]          ;262
000082  7541              STRB     r1,[r0,#0x15]         ;263
000084  7501              STRB     r1,[r0,#0x14]         ;263
000086  2140              MOVS     r1,#0x40              ;264
000088  7581              STRB     r1,[r0,#0x16]         ;264
00008a  2101              MOVS     r1,#1                 ;265
00008c  75c1              STRB     r1,[r0,#0x17]         ;265
00008e  2100              MOVS     r1,#0                 ;268
000090  8301              STRH     r1,[r0,#0x18]         ;268
000092  f7fffffe          BL       uip_ipchksum
000096  43c0              MVNS     r0,r0                 ;269
000098  b281              UXTH     r1,r0                 ;269
00009a  4801              LDR      r0,|L4.160|
00009c  8301              STRH     r1,[r0,#0x18]         ;269
00009e  e7b7              B        |L4.16|
;;;273    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L4.160|
                          DCD      uip_buf
                  |L4.164|
                          DCD      uip_len
                  |L4.168|
                          DCD      uip_hostaddr

                          AREA ||i.uip_fw_default||, CODE, READONLY, ALIGN=2

                  uip_fw_default PROC
;;;511    void
;;;512    uip_fw_default(struct uip_fw_netif *netif)
000000  4901              LDR      r1,|L5.8|
;;;513    {
;;;514      defaultnetif = netif;
000002  6008              STR      r0,[r1,#0]  ; defaultnetif
;;;515    }
000004  4770              BX       lr
;;;516    /*------------------------------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||+0x4

                          AREA ||i.uip_fw_forward||, CODE, READONLY, ALIGN=2

                  uip_fw_forward PROC
;;;404    u8_t
;;;405    uip_fw_forward(void)
000000  b510              PUSH     {r4,lr}
;;;406    {
;;;407      struct fwcache_entry *fw;
;;;408    
;;;409      /* First check if the packet is destined for ourselves and return 0
;;;410         to indicate that the packet should be processed locally. */
;;;411      if(BUF->destipaddr[0] == uip_hostaddr[0] &&
000002  4837              LDR      r0,|L6.224|
000004  8bc0              LDRH     r0,[r0,#0x1e]
000006  4937              LDR      r1,|L6.228|
000008  8809              LDRH     r1,[r1,#0]  ; uip_hostaddr
00000a  4288              CMP      r0,r1
00000c  d107              BNE      |L6.30|
;;;412         BUF->destipaddr[1] == uip_hostaddr[1]) {
00000e  4834              LDR      r0,|L6.224|
000010  8c00              LDRH     r0,[r0,#0x20]
000012  4934              LDR      r1,|L6.228|
000014  8849              LDRH     r1,[r1,#2]  ; uip_hostaddr
000016  4288              CMP      r0,r1
000018  d101              BNE      |L6.30|
;;;413        return UIP_FW_LOCAL;
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;414      }
;;;415    
;;;416      /* If we use ping IP address configuration, and our IP address is
;;;417         not yet configured, we should intercept all ICMP echo packets. */
;;;418    #if UIP_PINGADDRCONF
;;;419      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&
;;;420         BUF->proto == UIP_PROTO_ICMP &&
;;;421         ICMPBUF->type == ICMP_ECHO) {
;;;422        return UIP_FW_LOCAL;
;;;423      }
;;;424    #endif /* UIP_PINGADDRCONF */
;;;425    
;;;426      /* Check if the packet is in the forwarding cache already, and if so
;;;427         we drop it. */
;;;428    
;;;429      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
;;;430        if(fw->timer != 0 &&
;;;431    #if UIP_REASSEMBLY > 0
;;;432           fw->len == BUF->len &&
;;;433           fw->offset == BUF->ipoffset &&
;;;434    #endif
;;;435           fw->ipid == BUF->ipid &&
;;;436           fw->srcipaddr[0] == BUF->srcipaddr[0] &&
;;;437           fw->srcipaddr[1] == BUF->srcipaddr[1] &&
;;;438           fw->destipaddr[0] == BUF->destipaddr[0] &&
;;;439           fw->destipaddr[1] == BUF->destipaddr[1] &&
;;;440    #if notdef
;;;441           fw->payload[0] == BUF->srcport &&
;;;442           fw->payload[1] == BUF->destport &&
;;;443    #endif
;;;444           fw->proto == BUF->proto) {
;;;445          /* Drop packet. */
;;;446          return UIP_FW_FORWARDED;
;;;447        }
;;;448      }
;;;449    
;;;450      /* If the TTL reaches zero we produce an ICMP time exceeded message
;;;451         in the uip_buf buffer and forward that packet back to the sender
;;;452         of the packet. */
;;;453      if(BUF->ttl <= 1) {
;;;454        /* No time exceeded for broadcasts and multicasts! */
;;;455        if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;456          return UIP_FW_LOCAL;
;;;457        }
;;;458        time_exceeded();
;;;459      }
;;;460    
;;;461      /* Decrement the TTL (time-to-live) value in the IP header */
;;;462      BUF->ttl = BUF->ttl - 1;
;;;463    
;;;464      /* Update the IP checksum. */
;;;465      if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {
;;;466        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;
;;;467      } else {
;;;468        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);
;;;469      }
;;;470    
;;;471      if(uip_len > 0) {
;;;472        uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];
;;;473        uip_fw_output();
;;;474      }
;;;475    
;;;476    #if UIP_BROADCAST
;;;477      if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;478        return UIP_FW_LOCAL;
;;;479      }
;;;480    #endif /* UIP_BROADCAST */
;;;481    
;;;482      /* Return non-zero to indicate that the packet was forwarded and that no
;;;483         other processing should be made. */
;;;484      return UIP_FW_FORWARDED;
;;;485    }
00001c  bd10              POP      {r4,pc}
                  |L6.30|
00001e  4c32              LDR      r4,|L6.232|
000020  e022              B        |L6.104|
                  |L6.34|
000022  8820              LDRH     r0,[r4,#0]            ;430
000024  b1f8              CBZ      r0,|L6.102|
000026  8961              LDRH     r1,[r4,#0xa]          ;435
000028  482d              LDR      r0,|L6.224|
00002a  8a40              LDRH     r0,[r0,#0x12]         ;435
00002c  4281              CMP      r1,r0                 ;435
00002e  d11a              BNE      |L6.102|
000030  8861              LDRH     r1,[r4,#2]            ;436
000032  482b              LDR      r0,|L6.224|
000034  8b40              LDRH     r0,[r0,#0x1a]         ;436
000036  4281              CMP      r1,r0                 ;436
000038  d115              BNE      |L6.102|
00003a  88a1              LDRH     r1,[r4,#4]            ;437
00003c  4828              LDR      r0,|L6.224|
00003e  8b80              LDRH     r0,[r0,#0x1c]         ;437
000040  4281              CMP      r1,r0                 ;437
000042  d110              BNE      |L6.102|
000044  88e1              LDRH     r1,[r4,#6]            ;438
000046  4826              LDR      r0,|L6.224|
000048  8bc0              LDRH     r0,[r0,#0x1e]         ;438
00004a  4281              CMP      r1,r0                 ;438
00004c  d10b              BNE      |L6.102|
00004e  8921              LDRH     r1,[r4,#8]            ;439
000050  4823              LDR      r0,|L6.224|
000052  8c00              LDRH     r0,[r0,#0x20]         ;439
000054  4281              CMP      r1,r0                 ;439
000056  d106              BNE      |L6.102|
000058  7b21              LDRB     r1,[r4,#0xc]          ;444
00005a  4821              LDR      r0,|L6.224|
00005c  7dc0              LDRB     r0,[r0,#0x17]         ;444
00005e  4281              CMP      r1,r0                 ;444
000060  d101              BNE      |L6.102|
000062  2001              MOVS     r0,#1                 ;446
000064  e7da              B        |L6.28|
                  |L6.102|
000066  340e              ADDS     r4,r4,#0xe            ;429
                  |L6.104|
000068  481f              LDR      r0,|L6.232|
00006a  301c              ADDS     r0,r0,#0x1c           ;429
00006c  4284              CMP      r4,r0                 ;429
00006e  d3d8              BCC      |L6.34|
000070  481b              LDR      r0,|L6.224|
000072  7d80              LDRB     r0,[r0,#0x16]         ;453
000074  2801              CMP      r0,#1                 ;453
000076  dc0f              BGT      |L6.152|
000078  4819              LDR      r0,|L6.224|
00007a  8bc0              LDRH     r0,[r0,#0x1e]         ;455
00007c  f5a0417f          SUB      r1,r0,#0xff00         ;455
000080  39ff              SUBS     r1,r1,#0xff           ;455
000082  d107              BNE      |L6.148|
000084  4816              LDR      r0,|L6.224|
000086  8c00              LDRH     r0,[r0,#0x20]         ;455
000088  f5a0417f          SUB      r1,r0,#0xff00         ;455
00008c  39ff              SUBS     r1,r1,#0xff           ;455
00008e  d101              BNE      |L6.148|
000090  2000              MOVS     r0,#0                 ;456
000092  e7c3              B        |L6.28|
                  |L6.148|
000094  f7fffffe          BL       time_exceeded
                  |L6.152|
000098  4811              LDR      r0,|L6.224|
00009a  7d80              LDRB     r0,[r0,#0x16]         ;462
00009c  1e40              SUBS     r0,r0,#1              ;462
00009e  b2c1              UXTB     r1,r0                 ;462
0000a0  480f              LDR      r0,|L6.224|
0000a2  7581              STRB     r1,[r0,#0x16]         ;462
0000a4  8b00              LDRH     r0,[r0,#0x18]         ;465
0000a6  f64f71fe          MOV      r1,#0xfffe            ;465
0000aa  4288              CMP      r0,r1                 ;465
0000ac  db06              BLT      |L6.188|
0000ae  480c              LDR      r0,|L6.224|
0000b0  8b00              LDRH     r0,[r0,#0x18]         ;466
0000b2  1c80              ADDS     r0,r0,#2              ;466
0000b4  b281              UXTH     r1,r0                 ;466
0000b6  480a              LDR      r0,|L6.224|
0000b8  8301              STRH     r1,[r0,#0x18]         ;466
0000ba  e005              B        |L6.200|
                  |L6.188|
0000bc  4808              LDR      r0,|L6.224|
0000be  8b00              LDRH     r0,[r0,#0x18]         ;468
0000c0  1c40              ADDS     r0,r0,#1              ;468
0000c2  b281              UXTH     r1,r0                 ;468
0000c4  4806              LDR      r0,|L6.224|
0000c6  8301              STRH     r1,[r0,#0x18]         ;468
                  |L6.200|
0000c8  4808              LDR      r0,|L6.236|
0000ca  8800              LDRH     r0,[r0,#0]            ;471  ; uip_len
0000cc  2800              CMP      r0,#0                 ;471
0000ce  dd05              BLE      |L6.220|
0000d0  4803              LDR      r0,|L6.224|
0000d2  3036              ADDS     r0,r0,#0x36           ;472
0000d4  4906              LDR      r1,|L6.240|
0000d6  6008              STR      r0,[r1,#0]            ;472  ; uip_appdata
0000d8  f7fffffe          BL       uip_fw_output
                  |L6.220|
0000dc  2001              MOVS     r0,#1                 ;484
0000de  e79d              B        |L6.28|
;;;486    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L6.224|
                          DCD      uip_buf
                  |L6.228|
                          DCD      uip_hostaddr
                  |L6.232|
                          DCD      ||.bss||
                  |L6.236|
                          DCD      uip_len
                  |L6.240|
                          DCD      uip_appdata

                          AREA ||i.uip_fw_init||, CODE, READONLY, ALIGN=2

                  uip_fw_init PROC
;;;181    void
;;;182    uip_fw_init(void)
000000  2100              MOVS     r1,#0
;;;183    {
;;;184      struct uip_fw_netif *t;
;;;185      defaultnetif = NULL;
000002  4a09              LDR      r2,|L7.40|
000004  6011              STR      r1,[r2,#0]  ; defaultnetif
;;;186      while(netifs != NULL) {
000006  e009              B        |L7.28|
                  |L7.8|
;;;187        t = netifs;
000008  4907              LDR      r1,|L7.40|
00000a  1f09              SUBS     r1,r1,#4
00000c  6808              LDR      r0,[r1,#0]  ; netifs
;;;188        netifs = netifs->next;
00000e  6809              LDR      r1,[r1,#0]  ; netifs
000010  6809              LDR      r1,[r1,#0]
000012  4a05              LDR      r2,|L7.40|
000014  1f12              SUBS     r2,r2,#4
000016  6011              STR      r1,[r2,#0]  ; netifs
;;;189        t->next = NULL;
000018  2100              MOVS     r1,#0
00001a  6001              STR      r1,[r0,#0]
                  |L7.28|
00001c  4902              LDR      r1,|L7.40|
00001e  1f09              SUBS     r1,r1,#4              ;186
000020  6809              LDR      r1,[r1,#0]            ;186  ; netifs
000022  2900              CMP      r1,#0                 ;186
000024  d1f0              BNE      |L7.8|
;;;190      }
;;;191    }
000026  4770              BX       lr
;;;192    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L7.40|
                          DCD      ||.data||+0x4

                          AREA ||i.uip_fw_output||, CODE, READONLY, ALIGN=2

                  uip_fw_output PROC
;;;356    u8_t
;;;357    uip_fw_output(void)
000000  b510              PUSH     {r4,lr}
;;;358    {
;;;359      struct uip_fw_netif *netif;
;;;360    
;;;361      if(uip_len == 0) {
000002  4808              LDR      r0,|L8.36|
000004  8800              LDRH     r0,[r0,#0]  ; uip_len
000006  b908              CBNZ     r0,|L8.12|
;;;362        return UIP_FW_ZEROLEN;
000008  2002              MOVS     r0,#2
                  |L8.10|
;;;363      }
;;;364    
;;;365      fwcache_register();
;;;366    
;;;367    #if UIP_BROADCAST
;;;368      /* Link local broadcasts go out on all interfaces. */
;;;369      if(/*BUF->proto == UIP_PROTO_UDP &&*/
;;;370         BUF->destipaddr[0] == 0xffff &&
;;;371         BUF->destipaddr[1] == 0xffff) {
;;;372        if(defaultnetif != NULL) {
;;;373          defaultnetif->output();
;;;374        }
;;;375        for(netif = netifs; netif != NULL; netif = netif->next) {
;;;376          netif->output();
;;;377        }
;;;378        return UIP_FW_OK;
;;;379      }
;;;380    #endif /* UIP_BROADCAST */
;;;381    
;;;382      netif = find_netif();
;;;383      /*  printf("uip_fw_output: netif %p ->output %p len %d\n", netif,
;;;384    	 netif->output,
;;;385    	 uip_len);*/
;;;386    
;;;387      if(netif == NULL) {
;;;388        return UIP_FW_NOROUTE;
;;;389      }
;;;390      /* If we now have found a suitable network interface, we call its
;;;391         output function to send out the packet. */
;;;392      return netif->output();
;;;393    }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  f7fffffe          BL       fwcache_register
000010  f7fffffe          BL       find_netif
000014  4604              MOV      r4,r0                 ;382
000016  b90c              CBNZ     r4,|L8.28|
000018  2004              MOVS     r0,#4                 ;388
00001a  e7f6              B        |L8.10|
                  |L8.28|
00001c  68e0              LDR      r0,[r4,#0xc]          ;392
00001e  4780              BLX      r0                    ;392
000020  e7f3              B        |L8.10|
;;;394    /*------------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      uip_len

                          AREA ||i.uip_fw_periodic||, CODE, READONLY, ALIGN=2

                  uip_fw_periodic PROC
;;;521    void
;;;522    uip_fw_periodic(void)
000000  4806              LDR      r0,|L9.28|
;;;523    {
;;;524      struct fwcache_entry *fw;
;;;525      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
000002  e006              B        |L9.18|
                  |L9.4|
;;;526        if(fw->timer > 0) {
000004  8801              LDRH     r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  dd02              BLE      |L9.16|
;;;527          --fw->timer;
00000a  8801              LDRH     r1,[r0,#0]
00000c  1e49              SUBS     r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]
                  |L9.16|
000010  300e              ADDS     r0,r0,#0xe            ;525
                  |L9.18|
000012  4902              LDR      r1,|L9.28|
000014  311c              ADDS     r1,r1,#0x1c           ;525
000016  4288              CMP      r0,r1                 ;525
000018  d3f4              BCC      |L9.4|
;;;528        }
;;;529      }
;;;530    }
00001a  4770              BX       lr
;;;531    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L9.28|
                          DCD      ||.bss||

                          AREA ||i.uip_fw_register||, CODE, READONLY, ALIGN=2

                  uip_fw_register PROC
;;;494    void
;;;495    uip_fw_register(struct uip_fw_netif *netif)
000000  4902              LDR      r1,|L10.12|
;;;496    {
;;;497      netif->next = netifs;
000002  6809              LDR      r1,[r1,#0]  ; netifs
000004  6001              STR      r1,[r0,#0]
;;;498      netifs = netif;
000006  4901              LDR      r1,|L10.12|
000008  6008              STR      r0,[r1,#0]  ; netifs
;;;499    }
00000a  4770              BX       lr
;;;500    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L10.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  fwcache
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  netifs
                          DCD      0x00000000
                  defaultnetif
                          DCD      0x00000000
