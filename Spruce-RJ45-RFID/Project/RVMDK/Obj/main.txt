; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\main.crf ..\..\Source\src\main.c]
                          THUMB

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;214    
;;;215    void Delay(vu32 nCount) {
000000  e000              B        |L1.4|
                  |L1.2|
;;;216      for(; nCount != 0; nCount--);
000002  1e40              SUBS     r0,r0,#1
                  |L1.4|
000004  2800              CMP      r0,#0
000006  d1fc              BNE      |L1.2|
;;;217      }
000008  4770              BX       lr
;;;218    /*******************************************************************************
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;177    
;;;178    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;179    {
;;;180      
;;;181      GPIO_InitTypeDef GPIO_InitStructure;
;;;182      RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 |RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |
000002  2101              MOVS     r1,#1
000004  f244007c          MOV      r0,#0x407c
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;183                             RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD |
;;;184                             RCC_APB2Periph_GPIOE, ENABLE);
;;;185      	
;;;186      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;				     //LED1
00000c  2020              MOVS     r0,#0x20
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;187      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;188      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;189      GPIO_Init(GPIOB, &GPIO_InitStructure);					 
00001e  4669              MOV      r1,sp
000020  481b              LDR      r0,|L2.144|
000022  f7fffffe          BL       GPIO_Init
;;;190    
;;;191      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_3;		 //LED2, LED3
000026  2048              MOVS     r0,#0x48
000028  f8ad0000          STRH     r0,[sp,#0]
;;;192      GPIO_Init(GPIOD, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4819              LDR      r0,|L2.148|
000030  f7fffffe          BL       GPIO_Init
;;;193    
;;;194      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;		
000034  2010              MOVS     r0,#0x10
000036  f8ad0000          STRH     r0,[sp,#0]
;;;195      GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4816              LDR      r0,|L2.152|
00003e  f7fffffe          BL       GPIO_Init
;;;196      
;;;197      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_7;
000042  f44f5084          MOV      r0,#0x1080
000046  f8ad0000          STRH     r0,[sp,#0]
;;;198      GPIO_Init(GPIOB, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  4810              LDR      r0,|L2.144|
00004e  f7fffffe          BL       GPIO_Init
;;;199      
;;;200      GPIO_ResetBits(GPIOE, GPIO_Pin_0);  
000052  2101              MOVS     r1,#1
000054  4811              LDR      r0,|L2.156|
000056  f7fffffe          BL       GPIO_ResetBits
;;;201      GPIO_ResetBits(GPIOE, GPIO_Pin_1);
00005a  2102              MOVS     r1,#2
00005c  480f              LDR      r0,|L2.156|
00005e  f7fffffe          BL       GPIO_ResetBits
;;;202      Delay(0xAFFF);					   
000062  f64a70ff          MOV      r0,#0xafff
000066  f7fffffe          BL       Delay
;;;203      GPIO_SetBits(GPIOE, GPIO_Pin_1 );		 	 	   //复位ENC28J60
00006a  2102              MOVS     r1,#2
00006c  480b              LDR      r0,|L2.156|
00006e  f7fffffe          BL       GPIO_SetBits
;;;204      Delay(0xAFFF);		  	 	
000072  f64a70ff          MOV      r0,#0xafff
000076  f7fffffe          BL       Delay
;;;205    
;;;206    
;;;207     //禁止SPI1总线上的其他设备
;;;208      GPIO_SetBits(GPIOC, GPIO_Pin_4);			            //SPI CS1	       
00007a  2110              MOVS     r1,#0x10
00007c  4806              LDR      r0,|L2.152|
00007e  f7fffffe          BL       GPIO_SetBits
;;;209      GPIO_SetBits(GPIOB, GPIO_Pin_12|GPIO_Pin_7);			//SPI CS4   CS3
000082  f44f5184          MOV      r1,#0x1080
000086  4802              LDR      r0,|L2.144|
000088  f7fffffe          BL       GPIO_SetBits
;;;210     
;;;211    
;;;212    }
00008c  bd08              POP      {r3,pc}
;;;213    
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      0x40010c00
                  |L2.148|
                          DCD      0x40011400
                  |L2.152|
                          DCD      0x40011000
                  |L2.156|
                          DCD      0x40011800

                          AREA ||i.InitNet||, CODE, READONLY, ALIGN=2

                  InitNet PROC
;;;153    */
;;;154    void InitNet(void)
000000  b508              PUSH     {r3,lr}
;;;155    {
;;;156    	uip_ipaddr_t ipaddr;
;;;157    
;;;158    
;;;159    	tapdev_init();
000002  f7fffffe          BL       tapdev_init
;;;160    
;;;161    //	printf("uip_init\n\r");
;;;162    	uip_init();
000006  f7fffffe          BL       uip_init
;;;163    
;;;164    	//printf("uip ip address : 192,168,0,15\n\r");
;;;165    	uip_ipaddr(ipaddr, 192,168,1,15);
00000a  bf00              NOP      
00000c  f64a00c0          MOV      r0,#0xa8c0
000010  f8ad0000          STRH     r0,[sp,#0]
000014  f6407001          MOV      r0,#0xf01
000018  f8ad0002          STRH     r0,[sp,#2]
00001c  bf00              NOP      
;;;166    	uip_sethostaddr(ipaddr);
00001e  bf00              NOP      
000020  f8bd0000          LDRH     r0,[sp,#0]
000024  4915              LDR      r1,|L3.124|
000026  8008              STRH     r0,[r1,#0]
000028  f8bd0002          LDRH     r0,[sp,#2]
00002c  8048              STRH     r0,[r1,#2]
00002e  bf00              NOP      
;;;167    
;;;168    //	printf("uip route address : 192,168,0,1\n\r");
;;;169    	uip_ipaddr(ipaddr, 192,168,1,1);
000030  bf00              NOP      
000032  f64a00c0          MOV      r0,#0xa8c0
000036  f8ad0000          STRH     r0,[sp,#0]
00003a  f2401001          MOV      r0,#0x101
00003e  f8ad0002          STRH     r0,[sp,#2]
000042  bf00              NOP      
;;;170    	uip_setdraddr(ipaddr);
000044  bf00              NOP      
000046  f8bd0000          LDRH     r0,[sp,#0]
00004a  490d              LDR      r1,|L3.128|
00004c  8008              STRH     r0,[r1,#0]
00004e  f8bd0002          LDRH     r0,[sp,#2]
000052  8048              STRH     r0,[r1,#2]
000054  bf00              NOP      
;;;171    
;;;172    	//printf("uip net mask : 255,255,255,0\n\r");
;;;173    	uip_ipaddr(ipaddr, 255,255,255,0);
000056  bf00              NOP      
000058  f64f70ff          MOV      r0,#0xffff
00005c  f8ad0000          STRH     r0,[sp,#0]
000060  20ff              MOVS     r0,#0xff
000062  f8ad0002          STRH     r0,[sp,#2]
000066  bf00              NOP      
;;;174    	uip_setnetmask(ipaddr);
000068  bf00              NOP      
00006a  f8bd0000          LDRH     r0,[sp,#0]
00006e  4905              LDR      r1,|L3.132|
000070  8008              STRH     r0,[r1,#0]
000072  f8bd0002          LDRH     r0,[sp,#2]
000076  8048              STRH     r0,[r1,#2]
000078  bf00              NOP      
;;;175    
;;;176    }
00007a  bd08              POP      {r3,pc}
;;;177    
                          ENDP

                  |L3.124|
                          DCD      uip_hostaddr
                  |L3.128|
                          DCD      uip_draddr
                  |L3.132|
                          DCD      uip_netmask

                          AREA ||i.Init_fd||, CODE, READONLY, ALIGN=2

                  Init_fd PROC
;;;223    */
;;;224    static void Init_fd(void)
000000  b510              PUSH     {r4,lr}
;;;225    {
;;;226    	/*
;;;227    		这个函数是ST库中的函数，函数实体在
;;;228    		Libraries\CMSIS\Core\CM3\system_stm32f10x.c
;;;229    
;;;230    		配置内部Flash接口，初始化PLL，配置系统频率
;;;231    		系统时钟缺省配置为72MHz，你如果需要更改，则需要去修改相关的头文件中的宏定义
;;;232    	 */
;;;233    	SystemInit();
000002  f7fffffe          BL       SystemInit
;;;234    
;;;235    	/* 配置按键GPIO和LED GPIO */
;;;236    	GPIO_Configuration();
000006  f7fffffe          BL       GPIO_Configuration
;;;237    
;;;238    	/* 配置串口 */
;;;239    	USART_Configuration();
00000a  f7fffffe          BL       USART_Configuration
;;;240    
;;;241    
;;;242    
;;;243    	/* 配置systic作为1ms中断,这个函数在
;;;244    	\Libraries\CMSIS\Core\CM3\core_cm3.h */
;;;245    	SysTick_Config(SystemFrequency / 1000);
00000e  4914              LDR      r1,|L4.96|
000010  6809              LDR      r1,[r1,#0]  ; SystemFrequency
000012  f44f727a          MOV      r2,#0x3e8
000016  fbb1f0f2          UDIV     r0,r1,r2
00001a  f1b07f80          CMP      r0,#0x1000000
00001e  d300              BCC      |L4.34|
000020  e01c              B        |L4.92|
                  |L4.34|
000022  f020417f          BIC      r1,r0,#0xff000000
000026  1e49              SUBS     r1,r1,#1
000028  f04f22e0          MOV      r2,#0xe000e000
00002c  6151              STR      r1,[r2,#0x14]
00002e  bf00              NOP      
000030  1751              ASRS     r1,r2,#29
000032  2900              CMP      r1,#0
000034  da05              BGE      |L4.66|
000036  210f              MOVS     r1,#0xf
000038  0109              LSLS     r1,r1,#4
00003a  4a0a              LDR      r2,|L4.100|
00003c  230b              MOVS     r3,#0xb
00003e  54d1              STRB     r1,[r2,r3]
000040  e004              B        |L4.76|
                  |L4.66|
000042  210f              MOVS     r1,#0xf
000044  0109              LSLS     r1,r1,#4
000046  4a08              LDR      r2,|L4.104|
000048  1753              ASRS     r3,r2,#29
00004a  54d1              STRB     r1,[r2,r3]
                  |L4.76|
00004c  bf00              NOP      
00004e  2100              MOVS     r1,#0
000050  f04f22e0          MOV      r2,#0xe000e000
000054  6191              STR      r1,[r2,#0x18]
000056  2107              MOVS     r1,#7
000058  6111              STR      r1,[r2,#0x10]
00005a  bf00              NOP      
                  |L4.92|
;;;246    }
00005c  bd10              POP      {r4,pc}
;;;247    
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      SystemFrequency
                  |L4.100|
                          DCD      0xe000ed18
                  |L4.104|
                          DCD      0xe000e400

                          AREA ||i.UipPro||, CODE, READONLY, ALIGN=2

                  UipPro PROC
;;;53     */
;;;54     void UipPro(void)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56     	uint8_t i;
;;;57     	static struct timer periodic_timer, arp_timer;
;;;58     	static char timer_ok = 0;	/* fd*/
;;;59     
;;;60     	/* 创建2个定时器，只用执行1次 */
;;;61     	if (timer_ok == 0)
000002  4836              LDR      r0,|L5.220|
000004  7800              LDRB     r0,[r0,#0]  ; timer_ok
000006  b968              CBNZ     r0,|L5.36|
;;;62     	{
;;;63     		timer_ok = 1;
000008  2001              MOVS     r0,#1
00000a  4934              LDR      r1,|L5.220|
00000c  7008              STRB     r0,[r1,#0]
;;;64     		timer_set(&periodic_timer, CLOCK_SECOND / 2);  /* 创建1个0.5秒的定时器 */
00000e  2132              MOVS     r1,#0x32
000010  4832              LDR      r0,|L5.220|
000012  3810              SUBS     r0,r0,#0x10
000014  f7fffffe          BL       timer_set
;;;65     		timer_set(&arp_timer, CLOCK_SECOND * 10);	   /* 创建1个10秒的定时器 */
000018  f44f717a          MOV      r1,#0x3e8
00001c  482f              LDR      r0,|L5.220|
00001e  3808              SUBS     r0,r0,#8
000020  f7fffffe          BL       timer_set
                  |L5.36|
;;;66     	}
;;;67     
;;;68     	/*
;;;69     		从网络设备读取一个IP包,返回数据长度 (非阻塞)
;;;70     		这个地方没有使用DM9000AEP的中断功能，采用的是查询方式
;;;71     	*/
;;;72     	uip_len = tapdev_read();	/* uip_len 是在uip中定义的全局变量 */
000024  f7fffffe          BL       tapdev_read
000028  492d              LDR      r1,|L5.224|
00002a  8008              STRH     r0,[r1,#0]
;;;73     	if(uip_len > 0)
00002c  4608              MOV      r0,r1
00002e  8800              LDRH     r0,[r0,#0]  ; uip_len
000030  2800              CMP      r0,#0
000032  dd24              BLE      |L5.126|
;;;74     	{
;;;75     		/* 处理IP数据包(只有校验通过的IP包才会被接收) */
;;;76     		if(BUF->type == htons(UIP_ETHTYPE_IP))
000034  f44f6000          MOV      r0,#0x800
000038  f7fffffe          BL       htons
00003c  4929              LDR      r1,|L5.228|
00003e  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
000040  4288              CMP      r0,r1
000042  d10b              BNE      |L5.92|
;;;77     		{
;;;78     			uip_arp_ipin();
;;;79     			uip_input();
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       uip_process
;;;80     			/*
;;;81     				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;82     				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;83     			*/
;;;84     			if (uip_len > 0)
00004a  4825              LDR      r0,|L5.224|
00004c  8800              LDRH     r0,[r0,#0]  ; uip_len
00004e  2800              CMP      r0,#0
000050  dd43              BLE      |L5.218|
;;;85     			{
;;;86     				uip_arp_out();
000052  f7fffffe          BL       uip_arp_out
;;;87     				tapdev_send();
000056  f7fffffe          BL       tapdev_send
00005a  e03e              B        |L5.218|
                  |L5.92|
;;;88     			}
;;;89     		}
;;;90     		/* 处理arp报文 */
;;;91     		else if (BUF->type == htons(UIP_ETHTYPE_ARP))
00005c  f6400006          MOV      r0,#0x806
000060  f7fffffe          BL       htons
000064  491f              LDR      r1,|L5.228|
000066  8989              LDRH     r1,[r1,#0xc]  ; uip_buf
000068  4288              CMP      r0,r1
00006a  d136              BNE      |L5.218|
;;;92     		{
;;;93     			uip_arp_arpin();
00006c  f7fffffe          BL       uip_arp_arpin
;;;94     			/*
;;;95     				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;96     				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;97     			*/
;;;98     			if (uip_len > 0)
000070  481b              LDR      r0,|L5.224|
000072  8800              LDRH     r0,[r0,#0]  ; uip_len
000074  2800              CMP      r0,#0
000076  dd30              BLE      |L5.218|
;;;99     			{
;;;100    				tapdev_send();
000078  f7fffffe          BL       tapdev_send
00007c  e02d              B        |L5.218|
                  |L5.126|
;;;101    			}
;;;102    		}
;;;103    	}
;;;104    	else if(timer_expired(&periodic_timer))	/* 0.5秒定时器超时 */
00007e  4817              LDR      r0,|L5.220|
000080  3810              SUBS     r0,r0,#0x10
000082  f7fffffe          BL       timer_expired
000086  b340              CBZ      r0,|L5.218|
;;;105    	{
;;;106    		timer_reset(&periodic_timer);	/* 复位0.5秒定时器 */
000088  4814              LDR      r0,|L5.220|
00008a  3810              SUBS     r0,r0,#0x10
00008c  f7fffffe          BL       timer_reset
;;;107    
;;;108    		/* 轮流处理每个TCP连接, UIP_CONNS缺省是10个 */
;;;109    		for(i = 0; i < UIP_CONNS; i++)
000090  2400              MOVS     r4,#0
000092  e015              B        |L5.192|
                  |L5.148|
;;;110    		{
;;;111    			uip_periodic(i);	/* 处理TCP通信事件 */
000094  bf00              NOP      
000096  eb040084          ADD      r0,r4,r4,LSL #2
00009a  4913              LDR      r1,|L5.232|
00009c  eb0100c0          ADD      r0,r1,r0,LSL #3
0000a0  4912              LDR      r1,|L5.236|
0000a2  6008              STR      r0,[r1,#0]  ; uip_conn
0000a4  2002              MOVS     r0,#2
0000a6  f7fffffe          BL       uip_process
0000aa  bf00              NOP      
;;;112    			/*
;;;113    				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;114    				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;115    			*/
;;;116    			if(uip_len > 0)
0000ac  480c              LDR      r0,|L5.224|
0000ae  8800              LDRH     r0,[r0,#0]  ; uip_len
0000b0  2800              CMP      r0,#0
0000b2  dd03              BLE      |L5.188|
;;;117    			{
;;;118    				uip_arp_out();
0000b4  f7fffffe          BL       uip_arp_out
;;;119    				tapdev_send();
0000b8  f7fffffe          BL       tapdev_send
                  |L5.188|
0000bc  1c60              ADDS     r0,r4,#1              ;109
0000be  b2c4              UXTB     r4,r0                 ;109
                  |L5.192|
0000c0  2c28              CMP      r4,#0x28              ;109
0000c2  dbe7              BLT      |L5.148|
;;;120    			}
;;;121    		}
;;;122    
;;;123    	#if UIP_UDP
;;;124    		/* 轮流处理每个UDP连接, UIP_UDP_CONNS缺省是10个 */
;;;125    		for(i = 0; i < UIP_UDP_CONNS; i++)
;;;126    		{
;;;127    			uip_udp_periodic(i);	/*处理UDP通信事件 */
;;;128    			/* If the above function invocation resulted in data that
;;;129    			should be sent out on the network, the global variable
;;;130    			uip_len is set to a value > 0. */
;;;131    			if(uip_len > 0)
;;;132    			{
;;;133    			uip_arp_out();
;;;134    			tapdev_send();
;;;135    			}
;;;136    		}
;;;137    	#endif /* UIP_UDP */
;;;138    
;;;139    		/* 每隔10秒调用1次ARP定时器函数 */
;;;140    		if (timer_expired(&arp_timer))
0000c4  4805              LDR      r0,|L5.220|
0000c6  3808              SUBS     r0,r0,#8
0000c8  f7fffffe          BL       timer_expired
0000cc  b128              CBZ      r0,|L5.218|
;;;141    		{
;;;142    			timer_reset(&arp_timer);
0000ce  4803              LDR      r0,|L5.220|
0000d0  3808              SUBS     r0,r0,#8
0000d2  f7fffffe          BL       timer_reset
;;;143    			uip_arp_timer();
0000d6  f7fffffe          BL       uip_arp_timer
                  |L5.218|
;;;144    		}
;;;145    	}
;;;146    }
0000da  bd10              POP      {r4,pc}
;;;147    
                          ENDP

                  |L5.220|
                          DCD      ||.data||+0x10
                  |L5.224|
                          DCD      uip_len
                  |L5.228|
                          DCD      uip_buf
                  |L5.232|
                          DCD      uip_conns
                  |L5.236|
                          DCD      uip_conn

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;29     */
;;;30     int main(void)
000000  b510              PUSH     {r4,lr}
;;;31     {
;;;32     	Init_fd();	//板子资源的初始化
000002  f7fffffe          BL       Init_fd
;;;33     	SPI1_Init();
000006  f7fffffe          BL       SPI1_Init
;;;34         
;;;35     	InitNet();		/* 初始化网络设备以及UIP协议栈，配置IP地址 */
00000a  f7fffffe          BL       InitNet
;;;36     
;;;37     	/* 创建一个TCP监听端口和http监听端口，端口号为1200，80 */
;;;38     	uip_listen(HTONS(1200));
00000e  f24b0004          MOV      r0,#0xb004
000012  f7fffffe          BL       uip_listen
;;;39     	uip_listen(HTONS(80));
000016  f44f40a0          MOV      r0,#0x5000
00001a  f7fffffe          BL       uip_listen
;;;40     	while (1)
00001e  e001              B        |L6.36|
                  |L6.32|
;;;41     	{
;;;42     		UipPro();		/* 处理uip事件，必须插入到用户程序的循环体中 */
000020  f7fffffe          BL       UipPro
                  |L6.36|
000024  e7fc              B        |L6.32|
;;;43     
;;;44     
;;;45     	}
;;;46     }
;;;47     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  periodic_timer
                          %        8
                  arp_timer
                          %        8
                  timer_ok
000010  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
